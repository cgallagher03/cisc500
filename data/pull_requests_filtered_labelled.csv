PR Number,Title,Created At,Updated At,State,Files Changed,Total Comments,Decision Time,URL,Type of Change,LOC Changed,Closed Date,Integration,Author,Formatted Comments,Labels
129755,Add HassRespond intent,2024-11-03 21:07:40+00:00,2024-11-04 00:15:25+00:00,merged,3,1,0,https://github.com/home-assistant/core/pull/129755,New feature (which adds functionality to an existing integration),16,2024-11-03T22:38:52Z,intent,synesthesiam,"(from reviewer) [2024-11-04T00:11:31Z] Why is this added to the November release milestone?

---BEGIN THREAD---
Diff Hunk:
@@ -420,6 +421,17 @@ async def async_handle(self, intent_obj: intent.Intent) -> intent.IntentResponse
         return response
 
 
+class HelloIntentHandler(intent.IntentHandler):
+    """"""Responds with no action.""""""
+
+    intent_type = intent.INTENT_RESPOND
+    description = ""Returns the provided response with no action.""
+
+    async def async_handle(self, intent_obj: intent.Intent) -> intent.IntentResponse:
+        """"""Return the provided response, but take no action.""""""
+        return intent_obj.create_response()

(from reviewer) [2024-11-04T00:15:22Z] Tests are missing.
(from author) [2024-11-04T17:43:45Z] Waiting on an intents bump before the test can be added.
(from reviewer) [2024-11-04T20:41:22Z] Tests added in https://github.com/home-assistant/core/pull/129830
---END THREAD---

(from reviewer) [2024-11-04T07:38:47Z] I have removed this from the milestone, since there's no description in the PR description why this new feature should be added to the beta and November release.","Release, Testing"
129733,Add issue/repair on corrupt database rebuild,2024-11-03 16:04:56+00:00,2024-11-03 20:43:45+00:00,closed,3,0,0,https://github.com/home-assistant/core/pull/129733,New feature (which adds functionality to an existing integration),51,2024-11-03T16:07:47Z,recorder,rlaunch,"(from reviewer) [2024-11-03T16:07:44Z] Repairs must be actionable by users; this repair isn't (it explicitly mentions it). This is thus not a valid repair issue for this reason.

Nevertheless, thanks for being willing to contribute 👍

(from author) [2024-11-03T20:43:44Z] Hi @frenck,

Appologies, misinterpreted the repair/issues doc. Thanks for the quick feedback.

Best,
Ryan ",Invalid contribution
129675,Add DHCP discovery to lamarzocco,2024-11-02 11:36:32+00:00,2024-11-03 09:49:59+00:00,merged,5,7,0,https://github.com/home-assistant/core/pull/129675,New feature (which adds functionality to an existing integration),113,2024-11-03T09:44:35Z,lamarzocco,zweckj,"---BEGIN THREAD---
Diff Hunk:
@@ -276,6 +276,18 @@
         ""hostname"": ""polisy*"",
         ""macaddress"": ""000DB9*"",
     },
+    {
+        ""domain"": ""lamarzocco"",
+        ""hostname"": ""gs[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]"",

(from reviewer) [2024-11-02T22:28:28Z] ```suggestion
        ""hostname"": ""gs[0-9]{6}"",
```
(from author) [2024-11-03T05:51:17Z] This are glob pattern not regexes, so the {6} doesn't work afaik. The [0-9] appears to be fine though. 
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -276,6 +276,18 @@
         ""hostname"": ""polisy*"",
         ""macaddress"": ""000DB9*"",
     },
+    {
+        ""domain"": ""lamarzocco"",
+        ""hostname"": ""gs[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]"",
+    },
+    {
+        ""domain"": ""lamarzocco"",
+        ""hostname"": ""lm[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]"",

(from reviewer) [2024-11-02T22:28:58Z] ```suggestion
        ""hostname"": ""lm[0-9]{6}"",
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -276,6 +276,18 @@
         ""hostname"": ""polisy*"",
         ""macaddress"": ""000DB9*"",
     },
+    {
+        ""domain"": ""lamarzocco"",
+        ""hostname"": ""gs[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]"",
+    },
+    {
+        ""domain"": ""lamarzocco"",
+        ""hostname"": ""lm[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]"",
+    },
+    {
+        ""domain"": ""lamarzocco"",
+        ""hostname"": ""mr[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]"",

(from reviewer) [2024-11-02T22:29:22Z] ```suggestion
        ""hostname"": ""mr[0-9]{6}"",
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -435,6 +441,46 @@ async def test_bluetooth_discovery_errors(
     }
 
 
+async def test_dhcp_discovery(
+    hass: HomeAssistant,
+    mock_lamarzocco: MagicMock,
+    mock_cloud_client: MagicMock,
+    mock_device_info: LaMarzoccoDeviceInfo,
+) -> None:
+    """"""Test dhcp discovery.""""""
+
+    result = await hass.config_entries.flow.async_init(
+        DOMAIN,
+        context={""source"": SOURCE_DHCP},
+        data=DhcpServiceInfo(
+            ip=""192.168.1.42"",
+            hostname=mock_lamarzocco.serial_number,

(from reviewer) [2024-11-02T22:31:31Z] May be parametrize some hostnames to make sure all regex expressions are tested.
(from author) [2024-11-03T05:55:26Z] I don't understand? I mean we are not evaluating the glob patterns here anyways, so we are just passing through the strings here. 
(from author) [2024-11-03T07:51:35Z] It's not a bad idea though (added it)
---END THREAD---

(from reviewer) [2024-11-03T09:30:30Z] Do we need a docs PR here?

(from author) [2024-11-03T09:42:22Z] > Do we need a docs PR here?

I added a note to docs.","Validation, Validation, Testing"
129587,Add go2rtc debug_ui yaml key to enable go2rtc ui,2024-10-31 16:15:17+00:00,2024-11-02 19:42:37+00:00,merged,5,14,0,https://github.com/home-assistant/core/pull/129587,New feature (which adds functionality to an existing integration),102,2024-10-31T19:56:53Z,go2rtc,edenhaus,"---BEGIN THREAD---
Diff Hunk:
@@ -72,9 +72,15 @@
     )
 )
 
-
 CONFIG_SCHEMA = vol.Schema(
-    {DOMAIN: vol.Schema({vol.Optional(CONF_URL): cv.url})},
+    {
+        DOMAIN: vol.Schema(
+            {
+                vol.Exclusive(CONF_URL, DOMAIN, EXCLUSE_ERROR_MESSAGE): cv.url,

(from reviewer) [2024-10-31T16:17:06Z] What's `EXCLUSE`? Do you mean `EXCLUDE`?
(from author) [2024-10-31T16:58:30Z] Typo it should be called exclusive
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -2,4 +2,5 @@
 
 DOMAIN = ""go2rtc""
 
-CONF_BINARY = ""binary""
+CONF_DEBUG_UI = ""debug_ui""
+EXCLUSE_ERROR_MESSAGE = ""Url and debug_ui cannot be set at the same time.""

(from reviewer) [2024-10-31T16:41:30Z] ```suggestion
DEBUG_UI_URL_MESSAGE = ""Url and debug_ui cannot be set at the same time.""
```
(from author) [2024-10-31T16:57:56Z] ```suggestion
EXCLUSIVE_CONFIG_ERROR_MESSAGE = ""Url and debug_ui cannot be set at the same time.""
```

This message will be shown when both are set, so in my opinion we should not call it something like debug ui
(from reviewer) [2024-10-31T17:31:16Z] It's the message for both parameters yes. That's why we include both in the constant name.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -37,7 +37,7 @@
 from homeassistant.util.hass_dict import HassKey
 from homeassistant.util.package import is_docker_env
 
-from .const import DOMAIN
+from .const import CONF_DEBUG_UI, DOMAIN, EXCLUSE_ERROR_MESSAGE

(from reviewer) [2024-10-31T16:41:58Z] ```suggestion
from .const import CONF_DEBUG_UI, DOMAIN, DEBUG_UI_URL_MESSAGE
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -72,9 +72,15 @@
     )
 )
 
-
 CONFIG_SCHEMA = vol.Schema(
-    {DOMAIN: vol.Schema({vol.Optional(CONF_URL): cv.url})},
+    {
+        DOMAIN: vol.Schema(
+            {
+                vol.Exclusive(CONF_URL, DOMAIN, EXCLUSE_ERROR_MESSAGE): cv.url,
+                vol.Exclusive(CONF_DEBUG_UI, DOMAIN, EXCLUSE_ERROR_MESSAGE): cv.boolean,

(from reviewer) [2024-10-31T16:42:08Z] ```suggestion
                vol.Exclusive(CONF_DEBUG_UI, DOMAIN, DEBUG_UI_URL_MESSAGE): cv.boolean,
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -72,9 +72,15 @@
     )
 )
 
-
 CONFIG_SCHEMA = vol.Schema(
-    {DOMAIN: vol.Schema({vol.Optional(CONF_URL): cv.url})},
+    {
+        DOMAIN: vol.Schema(
+            {
+                vol.Exclusive(CONF_URL, DOMAIN, EXCLUSE_ERROR_MESSAGE): cv.url,

(from reviewer) [2024-10-31T16:42:43Z] ```suggestion
                vol.Exclusive(CONF_URL, DOMAIN, DEBUG_UI_URL_MESSAGE): cv.url,
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -468,7 +481,9 @@ async def test_close_session(
 ERR_CONNECT_RETRY = (
     ""Could not connect to go2rtc instance on http://localhost:1984/; Retrying""
 )
-ERR_INVALID_URL = ""Invalid config for 'go2rtc': invalid url""
+_INVALID_CONFIG = ""Invalid config for 'go2rtc': ""
+ERR_INVALID_URL = _INVALID_CONFIG + ""invalid url""
+ERR_EXLUSIVE = _INVALID_CONFIG + EXCLUSE_ERROR_MESSAGE

(from reviewer) [2024-10-31T16:45:15Z] ```suggestion
ERR_EXCLUSIVE = _INVALID_CONFIG + DEBUG_UI_URL_MESSAGE
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -501,6 +516,12 @@ async def test_non_user_setup_with_error(
         ({DOMAIN: {}}, None, False, ERR_URL_REQUIRED),
         ({DOMAIN: {}}, None, True, ERR_BINARY_NOT_FOUND),
         ({DOMAIN: {CONF_URL: ""invalid""}}, None, True, ERR_INVALID_URL),
+        (
+            {DOMAIN: {CONF_URL: ""http://localhost:1984"", CONF_DEBUG_UI: True}},
+            None,
+            True,
+            ERR_EXLUSIVE,

(from reviewer) [2024-10-31T16:45:29Z] ```suggestion
            ERR_EXCLUSIVE,
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -31,7 +31,11 @@
 )
 from homeassistant.components.default_config import DOMAIN as DEFAULT_CONFIG_DOMAIN
 from homeassistant.components.go2rtc import WebRTCProvider
-from homeassistant.components.go2rtc.const import DOMAIN
+from homeassistant.components.go2rtc.const import (
+    CONF_DEBUG_UI,
+    DOMAIN,
+    EXCLUSE_ERROR_MESSAGE,

(from reviewer) [2024-10-31T16:48:03Z] ```suggestion
    DEBUG_UI_URL_MESSAGE,
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -37,7 +37,7 @@
 from homeassistant.util.hass_dict import HassKey
 from homeassistant.util.package import is_docker_env
 
-from .const import DOMAIN
+from .const import CONF_DEBUG_UI, DOMAIN, DEBUG_UI_URL_MESSAGE

(from reviewer) [2024-10-31T19:47:51Z] ```suggestion
from .const import CONF_DEBUG_UI, DEBUG_UI_URL_MESSAGE, DOMAIN
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -31,7 +31,11 @@
 )
 from homeassistant.components.default_config import DOMAIN as DEFAULT_CONFIG_DOMAIN
 from homeassistant.components.go2rtc import WebRTCProvider
-from homeassistant.components.go2rtc.const import DOMAIN
+from homeassistant.components.go2rtc.const import (
+    CONF_DEBUG_UI,
+    DOMAIN,

(from reviewer) [2024-10-31T19:48:19Z] ```suggestion
    DEBUG_UI_URL_MESSAGE,
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -31,7 +31,11 @@
 )
 from homeassistant.components.default_config import DOMAIN as DEFAULT_CONFIG_DOMAIN
 from homeassistant.components.go2rtc import WebRTCProvider
-from homeassistant.components.go2rtc.const import DOMAIN
+from homeassistant.components.go2rtc.const import (
+    CONF_DEBUG_UI,
+    DOMAIN,
+    DEBUG_UI_URL_MESSAGE,

(from reviewer) [2024-10-31T19:48:32Z] ```suggestion
    DOMAIN,
```
---END THREAD---","Functional defect, Alternate output"
129490,Reolink add TCP push event connection as primary method,2024-10-30 10:43:13+00:00,2024-10-31 15:01:58+00:00,merged,6,0,0,https://github.com/home-assistant/core/pull/129490,New feature (which adds functionality to an existing integration),266,2024-10-30T13:34:33Z,reolink,starkillerOG,,
129468,Add progress support to MQTT update platform,2024-10-29 22:10:00+00:00,2024-10-31 17:01:52+00:00,merged,3,0,0,https://github.com/home-assistant/core/pull/129468,New feature (which adds functionality to an existing integration),154,2024-10-30T16:22:56Z,mqtt,jbouwh,,
129466,Add boost switch to Smarty,2024-10-29 21:16:53+00:00,2024-11-02 15:01:47+00:00,merged,6,9,2,https://github.com/home-assistant/core/pull/129466,New feature (which adds functionality to an existing integration),204,2024-11-01T10:08:56Z,smarty,marcodutto,"---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,93 @@
+""""""Support for Salda Smarty XP/XV Ventilation Unit Sensors.""""""
+
+from __future__ import annotations
+
+from collections.abc import Callable
+from dataclasses import dataclass
+import logging
+from typing import Any
+
+from pysmarty2 import Smarty
+
+from homeassistant.components.switch import SwitchEntity, SwitchEntityDescription
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+
+from .coordinator import SmartyConfigEntry, SmartyCoordinator
+from .entity import SmartyEntity
+
+_LOGGER = logging.getLogger(__name__)
+
+
+@dataclass(frozen=True, kw_only=True)
+class SmartySwitchDescription(SwitchEntityDescription):
+    """"""Class describing Smarty switch.""""""
+
+    is_on_fn: Callable[[Smarty], bool]
+    turn_on_fn: Callable[[Smarty], bool | None]
+    turn_off_fn: Callable[[Smarty], bool | None]
+
+
+ENTITIES: tuple[SmartySwitchDescription, ...] = (
+    SmartySwitchDescription(
+        key=""boost"",
+        translation_key=""boost"",
+        is_on_fn=lambda smarty: bool(smarty.boost),
+        turn_on_fn=lambda smarty: smarty.enable_boost(),
+        turn_off_fn=lambda smarty: smarty.disable_boost(),
+    ),
+)
+
+
+async def async_setup_entry(
+    hass: HomeAssistant,
+    entry: SmartyConfigEntry,
+    async_add_entities: AddEntitiesCallback,
+) -> None:
+    """"""Set up the Smarty Switch Platform.""""""
+
+    coordinator = entry.runtime_data
+
+    async_add_entities(
+        SmartySwitch(coordinator, description) for description in ENTITIES
+    )
+
+
+class SmartySwitch(SmartyEntity, SwitchEntity):
+    """"""Representation of a Smarty Switch.""""""
+
+    entity_description: SmartySwitchDescription
+
+    def __init__(
+        self,
+        coordinator: SmartyCoordinator,
+        entity_description: SmartySwitchDescription,
+    ) -> None:
+        """"""Initialize the entity.""""""
+        super().__init__(coordinator)
+        self._is_on = False

(from reviewer) [2024-10-30T10:14:26Z] There is no use for `self._is_on` so it can be removed
(from author) [2024-11-01T09:26:14Z] Done
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,27 @@
+""""""Tests for the Smarty sensor platform.""""""

(from reviewer) [2024-10-30T10:14:49Z] ```suggestion
""""""Tests for the Smarty switch platform.""""""
```
(from author) [2024-10-30T10:58:13Z] Done. Waiting to push all changes together.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,93 @@
+""""""Support for Salda Smarty XP/XV Ventilation Unit Sensors.""""""
+
+from __future__ import annotations
+
+from collections.abc import Callable
+from dataclasses import dataclass
+import logging
+from typing import Any
+
+from pysmarty2 import Smarty
+
+from homeassistant.components.switch import SwitchEntity, SwitchEntityDescription
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+
+from .coordinator import SmartyConfigEntry, SmartyCoordinator
+from .entity import SmartyEntity
+
+_LOGGER = logging.getLogger(__name__)
+
+
+@dataclass(frozen=True, kw_only=True)
+class SmartySwitchDescription(SwitchEntityDescription):
+    """"""Class describing Smarty switch.""""""
+
+    is_on_fn: Callable[[Smarty], bool]
+    turn_on_fn: Callable[[Smarty], bool | None]
+    turn_off_fn: Callable[[Smarty], bool | None]
+
+
+ENTITIES: tuple[SmartySwitchDescription, ...] = (
+    SmartySwitchDescription(
+        key=""boost"",
+        translation_key=""boost"",
+        is_on_fn=lambda smarty: bool(smarty.boost),

(from reviewer) [2024-10-30T10:15:22Z] is the extra `bool()` needed?
(from author) [2024-10-30T10:58:58Z] Removed as smarty.boost is already bool.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,93 @@
+""""""Support for Salda Smarty XP/XV Ventilation Unit Sensors.""""""

(from reviewer) [2024-10-30T10:15:31Z] Stale docstring
(from author) [2024-10-30T10:49:26Z] I suppose it's better to replace it with """"""Platform to control a Salda Smarty XP/XV ventilation unit.""""""
Do you agree?
(from author) [2024-11-01T09:26:33Z] Replaced
---END THREAD---","Code organization, Documentation"
129439,Add sensors for energy trends for devices,2024-10-29 16:56:27+00:00,2024-10-30 20:02:11+00:00,merged,4,7,0,https://github.com/home-assistant/core/pull/129439,New feature (which adds functionality to an existing integration),1204,2024-10-29T19:02:08Z,sense,kbickar,"---BEGIN THREAD---
Diff Hunk:
@@ -79,10 +79,16 @@ async def async_setup_entry(
 
     sense_monitor_id = data.sense_monitor_id
 
-    entities: list[SensorEntity] = [
-        SenseDevicePowerSensor(device, sense_monitor_id, realtime_coordinator)
-        for device in config_entry.runtime_data.data.devices
-    ]
+    entities: list[SensorEntity] = []
+
+    for device in config_entry.runtime_data.data.devices:
+        entities.append(
+            SenseDevicePowerSensor(device, sense_monitor_id, realtime_coordinator)
+        )
+        entities += [
+            SenseDeviceEnergySensor(device, scale, trends_coordinator, sense_monitor_id)
+            for scale in Scale
+        ]

(from reviewer) [2024-10-29T17:02:54Z] please use .extend
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -242,3 +248,34 @@ def __init__(
     def native_value(self) -> float:
         """"""Return the state of the sensor.""""""
         return self._device.power_w
+
+
+class SenseDeviceEnergySensor(SenseDeviceEntity, SensorEntity):
+    """"""Implementation of a Sense device energy sensor.""""""
+
+    _attr_native_unit_of_measurement = UnitOfEnergy.KILO_WATT_HOUR
+    _attr_state_class = SensorStateClass.TOTAL_INCREASING
+    _attr_device_class = SensorDeviceClass.ENERGY
+
+    def __init__(
+        self,
+        device: SenseDevice,
+        scale: Scale,
+        coordinator: SenseTrendCoordinator,
+        sense_monitor_id: str,
+    ) -> None:
+        """"""Initialize the Sense device sensor.""""""
+        super().__init__(
+            device,
+            coordinator,
+            sense_monitor_id,
+            f""{device.id}-{TRENDS_SENSOR_TYPES[scale].lower()}-energy"",
+        )
+        self._attr_name = f""{TRENDS_SENSOR_TYPES[scale]} Energy""

(from reviewer) [2024-10-29T17:03:23Z] Let's use translation keys here instead
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -242,3 +248,34 @@ def __init__(
     def native_value(self) -> float:
         """"""Return the state of the sensor.""""""
         return self._device.power_w
+
+
+class SenseDeviceEnergySensor(SenseDeviceEntity, SensorEntity):
+    """"""Implementation of a Sense device energy sensor.""""""
+
+    _attr_native_unit_of_measurement = UnitOfEnergy.KILO_WATT_HOUR
+    _attr_state_class = SensorStateClass.TOTAL_INCREASING
+    _attr_device_class = SensorDeviceClass.ENERGY
+
+    def __init__(
+        self,
+        device: SenseDevice,
+        scale: Scale,
+        coordinator: SenseTrendCoordinator,
+        sense_monitor_id: str,
+    ) -> None:
+        """"""Initialize the Sense device sensor.""""""
+        super().__init__(
+            device,
+            coordinator,
+            sense_monitor_id,
+            f""{device.id}-{TRENDS_SENSOR_TYPES[scale].lower()}-energy"",
+        )
+        self._attr_name = f""{TRENDS_SENSOR_TYPES[scale]} Energy""
+        self._scale = scale
+        self._device = device
+
+    @property
+    def native_value(self) -> float:
+        """"""Return the state of the sensor.""""""
+        return round(self._device.energy_kwh[self._scale], 2)

(from reviewer) [2024-10-29T17:03:52Z] Let's not round them. Rather add suggested precision
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -242,3 +248,34 @@ def __init__(
     def native_value(self) -> float:
         """"""Return the state of the sensor.""""""
         return self._device.power_w
+
+
+class SenseDeviceEnergySensor(SenseDeviceEntity, SensorEntity):

(from reviewer) [2024-10-29T17:05:21Z] I think it would be nice to use entity descriptions here. The idea of them is that you create 1 (or more) generic base class, and use entity descriptions to change the way they appear. I think it would make sense to use for the device entities. Checkout `smarty` for a recent example
(from author) [2024-10-29T18:29:34Z] I think this would be a good change, but I'd like to implement that in a different PR along with the translation strings for other sensors
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -63,6 +70,44 @@ async def test_device_power_sensors(
     assert state.state == f""{DEVICE_2_POWER:.1f}""
 
 
+async def test_device_energy_sensors(
+    hass: HomeAssistant,
+    entity_registry: er.EntityRegistry,
+    mock_sense: MagicMock,
+    config_entry: MockConfigEntry,
+) -> None:
+    """"""Test the Sense device power sensors.""""""
+    await setup_platform(hass, config_entry, SENSOR_DOMAIN)
+    device_1, device_2 = mock_sense.devices
+
+    state = hass.states.get(f""sensor.{DEVICE_1_NAME.lower()}_daily_energy"")
+    assert state.state == f""{DEVICE_1_DAY_ENERGY:.0f}""
+
+    state = hass.states.get(f""sensor.{DEVICE_2_NAME.lower()}_daily_energy"")
+    assert state.state == f""{DEVICE_2_DAY_ENERGY:.0f}""
+
+    device_1.energy_kwh[Scale.DAY] = 0
+    device_2.energy_kwh[Scale.DAY] = 0
+    async_fire_time_changed(hass, utcnow() + timedelta(seconds=600))

(from reviewer) [2024-10-29T17:05:51Z] please use the freezer
```suggestion
    freezer.tick(timedelta(minutes=10))
    async_fire_time_changed(hass)
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -32,5 +32,24 @@
       ""already_configured"": ""[%key:common::config_flow::abort::already_configured_device%]"",
       ""reauth_successful"": ""[%key:common::config_flow::abort::reauth_successful%]""
     }
+  },
+  ""entity"": {
+    ""sensor"": {
+      ""daily_energy"": {
+        ""name"": ""Daily Energy""
+      },
+      ""weekly_energy"": {
+        ""name"": ""Weekly Energy""
+      },
+      ""monthly_energy"": {
+        ""name"": ""Monthly Energy""
+      },
+      ""yearly_energy"": {
+        ""name"": ""Yearly Energy""
+      },
+      ""bill_energy"": {
+        ""name"": ""Bill Energy""

(from reviewer) [2024-10-29T18:44:40Z] ```suggestion
        ""name"": ""Daily energy""
      },
      ""weekly_energy"": {
        ""name"": ""Weekly energy""
      },
      ""monthly_energy"": {
        ""name"": ""Monthly energy""
      },
      ""yearly_energy"": {
        ""name"": ""Yearly energy""
      },
      ""bill_energy"": {
        ""name"": ""Bill energy""
```
---END THREAD---","Solution approach, Code organization, Alternate output, Code organization, Testing, Visual representation"
129420,Add support for vacuum cleaners to the Matter integration,2024-10-29 14:06:07+00:00,2024-10-31 15:02:02+00:00,merged,9,6,0,https://github.com/home-assistant/core/pull/129420,New feature (which adds functionality to an existing integration),878,2024-10-29T15:17:40Z,matter,marcelveldt,"---BEGIN THREAD---
Diff Hunk:
@@ -252,6 +255,11 @@
         ""name"": ""Power""
       }
     },
+    ""vacuum"": {
+      ""vacuum"": {
+        ""name"": ""[%key:component::vacuum::title%]""
+      }
+    },

(from reviewer) [2024-10-29T14:11:45Z] I think the vacuum will always be the main feature of a vacuum, should we set the name to `None`?
(from author) [2024-10-29T14:21:12Z] Its future proofed. It will use None if a single vacuum is discovered but if multiple vacuums get discovered (e.g. in case of a bridge) it needs to fallback to this string
(from reviewer) [2024-10-29T14:23:06Z] But if its a bridge, will the bridge be the device? I would assume it would create a separate device for the physical device
(from author) [2024-10-29T14:42:33Z] Yeah, bridge was a bad example. A composed device with multiple vacuum endpoints.
Its a bit unlikely but never say never with Matter :-)

At least we have the same consistent pattern across platforms now. As you can see the name is by default set to None to use the device name and it will only fallback to the 'platform translation key' if there are multiple endpoints.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,228 @@
+""""""Matter vacuum platform.""""""
+
+from __future__ import annotations
+
+from enum import IntEnum
+from typing import TYPE_CHECKING, Any
+
+from chip.clusters import Objects as clusters
+from matter_server.client.models import device_types
+
+from homeassistant.components.vacuum import (
+    STATE_CLEANING,
+    STATE_DOCKED,
+    STATE_ERROR,
+    STATE_RETURNING,
+    StateVacuumEntity,
+    StateVacuumEntityDescription,
+    VacuumEntityFeature,
+)
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import STATE_IDLE, Platform
+from homeassistant.core import HomeAssistant, callback
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+
+from .entity import MatterEntity
+from .helpers import get_matter
+from .models import MatterDiscoverySchema
+
+
+class OperationalState(IntEnum):
+    """"""Operational State of the vacuum cleaner.
+
+    Combination of generic OperationalState and RvcOperationalState.
+    """"""
+
+    NO_ERROR = 0x00
+    UNABLE_TO_START_OR_RESUME = 0x01
+    UNABLE_TO_COMPLETE_OPERATION = 0x02
+    COMMAND_INVALID_IN_STATE = 0x03
+    SEEKING_CHARGER = 0x40
+    CHARGING = 0x41
+    DOCKED = 0x42
+
+
+class ModeTag(IntEnum):
+    """"""Enum with available ModeTag values.""""""
+
+    IDLE = 0x4000  # 16384 decimal
+    CLEANING = 0x4001  # 16385 decimal
+    MAPPING = 0x4002  # 16386 decimal
+
+
+async def async_setup_entry(
+    hass: HomeAssistant,
+    config_entry: ConfigEntry,
+    async_add_entities: AddEntitiesCallback,
+) -> None:
+    """"""Set up Matter vacuum platform from Config Entry.""""""
+    matter = get_matter(hass)
+    matter.register_platform_handler(Platform.VACUUM, async_add_entities)
+
+
+class MatterVacuum(MatterEntity, StateVacuumEntity):
+    """"""Representation of a Matter Vacuum cleaner entity.""""""
+
+    _last_accepted_commands: list[int] | None = None
+    _supported_run_modes: (
+        dict[int, clusters.RvcCleanMode.Structs.ModeOptionStruct] | None
+    ) = None
+    entity_description: StateVacuumEntityDescription
+    _platform_translation_key = ""vacuum""
+
+    async def async_stop(self, **kwargs: Any) -> None:
+        """"""Stop the vacuum cleaner.""""""
+        await self._send_device_command(clusters.OperationalState.Commands.Stop())
+
+    async def async_return_to_base(self, **kwargs: Any) -> None:
+        """"""Set the vacuum cleaner to return to the dock.""""""
+        await self._send_device_command(clusters.RvcOperationalState.Commands.GoHome())
+
+    async def async_locate(self, **kwargs: Any) -> None:
+        """"""Locate the vacuum cleaner.""""""
+        await self._send_device_command(clusters.Identify.Commands.Identify())
+
+    async def async_start(self) -> None:
+        """"""Start or resume the cleaning task.""""""
+        if TYPE_CHECKING:
+            assert self._last_accepted_commands is not None
+        if (
+            clusters.RvcOperationalState.Commands.Resume.command_id
+            in self._last_accepted_commands
+        ):
+            await self._send_device_command(
+                clusters.RvcOperationalState.Commands.Resume()
+            )
+        else:
+            await self._send_device_command(clusters.OperationalState.Commands.Start())
+
+    async def async_pause(self) -> None:
+        """"""Pause the cleaning task.""""""
+        await self._send_device_command(clusters.OperationalState.Commands.Pause())
+
+    async def _send_device_command(
+        self,
+        command: clusters.ClusterCommand,
+    ) -> None:
+        """"""Send a command to the device.""""""
+        await self.matter_client.send_device_command(
+            node_id=self._endpoint.node.node_id,
+            endpoint_id=self._endpoint.endpoint_id,
+            command=command,
+        )
+
+    @callback
+    def _update_from_device(self) -> None:
+        """"""Update from device.""""""
+        self._calculate_features()
+        # optional battery level
+        if VacuumEntityFeature.BATTERY & self._attr_supported_features:
+            self._attr_battery_level = self.get_matter_attribute_value(
+                clusters.PowerSource.Attributes.BatPercentRemaining
+            )
+        # derive state from the run mode + operational state
+        run_mode_raw: int = self.get_matter_attribute_value(
+            clusters.RvcRunMode.Attributes.CurrentMode
+        )
+        operational_state: int = self.get_matter_attribute_value(
+            clusters.RvcOperationalState.Attributes.OperationalState
+        )
+        state: str | None = None
+        if TYPE_CHECKING:
+            assert self._supported_run_modes is not None
+        if operational_state in (OperationalState.CHARGING, OperationalState.DOCKED):
+            state = STATE_DOCKED
+        elif operational_state == OperationalState.SEEKING_CHARGER:
+            state = STATE_RETURNING
+        elif operational_state in (
+            OperationalState.UNABLE_TO_COMPLETE_OPERATION,
+            OperationalState.UNABLE_TO_START_OR_RESUME,
+        ):
+            state = STATE_ERROR
+        elif (run_mode := self._supported_run_modes.get(run_mode_raw)) is not None:
+            tags = {x.value for x in run_mode.modeTags}
+            if ModeTag.CLEANING in tags:
+                state = STATE_CLEANING
+            elif ModeTag.IDLE in tags:
+                state = STATE_IDLE
+        self._attr_state = state
+
+    @callback
+    def _calculate_features(
+        self,
+    ) -> None:

(from reviewer) [2024-10-29T14:12:21Z] ```suggestion
    def _calculate_features(self) -> None:
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,226 @@
+""""""Matter vacuum platform.""""""
+
+from __future__ import annotations
+
+from enum import IntEnum
+from typing import TYPE_CHECKING, Any
+
+from chip.clusters import Objects as clusters
+from matter_server.client.models import device_types
+
+from homeassistant.components.vacuum import (
+    STATE_CLEANING,
+    STATE_DOCKED,
+    STATE_ERROR,
+    STATE_RETURNING,
+    StateVacuumEntity,
+    StateVacuumEntityDescription,
+    VacuumEntityFeature,
+)
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import STATE_IDLE, Platform
+from homeassistant.core import HomeAssistant, callback
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+
+from .entity import MatterEntity
+from .helpers import get_matter
+from .models import MatterDiscoverySchema
+
+
+class OperationalState(IntEnum):
+    """"""Operational State of the vacuum cleaner.
+
+    Combination of generic OperationalState and RvcOperationalState.
+    """"""
+
+    NO_ERROR = 0x00
+    UNABLE_TO_START_OR_RESUME = 0x01
+    UNABLE_TO_COMPLETE_OPERATION = 0x02
+    COMMAND_INVALID_IN_STATE = 0x03
+    SEEKING_CHARGER = 0x40
+    CHARGING = 0x41
+    DOCKED = 0x42
+
+
+class ModeTag(IntEnum):
+    """"""Enum with available ModeTag values.""""""
+
+    IDLE = 0x4000  # 16384 decimal
+    CLEANING = 0x4001  # 16385 decimal
+    MAPPING = 0x4002  # 16386 decimal
+
+
+async def async_setup_entry(
+    hass: HomeAssistant,
+    config_entry: ConfigEntry,
+    async_add_entities: AddEntitiesCallback,
+) -> None:
+    """"""Set up Matter vacuum platform from Config Entry.""""""
+    matter = get_matter(hass)
+    matter.register_platform_handler(Platform.VACUUM, async_add_entities)
+
+
+class MatterVacuum(MatterEntity, StateVacuumEntity):
+    """"""Representation of a Matter Vacuum cleaner entity.""""""
+
+    _last_accepted_commands: list[int] | None = None
+    _supported_run_modes: (
+        dict[int, clusters.RvcCleanMode.Structs.ModeOptionStruct] | None
+    ) = None
+    entity_description: StateVacuumEntityDescription
+    _platform_translation_key = ""vacuum""
+
+    async def async_stop(self, **kwargs: Any) -> None:
+        """"""Stop the vacuum cleaner.""""""
+        await self._send_device_command(clusters.OperationalState.Commands.Stop())
+
+    async def async_return_to_base(self, **kwargs: Any) -> None:
+        """"""Set the vacuum cleaner to return to the dock.""""""
+        await self._send_device_command(clusters.RvcOperationalState.Commands.GoHome())
+
+    async def async_locate(self, **kwargs: Any) -> None:
+        """"""Locate the vacuum cleaner.""""""
+        await self._send_device_command(clusters.Identify.Commands.Identify())

(from reviewer) [2024-10-30T13:06:46Z] We didn't test locate.
---END THREAD---","Design discussion, Visual representation, Testing"
129369,Update nest to use the async WebRTC APIs,2024-10-29 05:29:31+00:00,2024-10-30 06:42:01+00:00,merged,1,0,0,https://github.com/home-assistant/core/pull/129369,New feature (which adds functionality to an existing integration),23,2024-10-29T06:18:59Z,nest,allenporter,,
129366,Add audio output select to Cambridge Audio,2024-10-29 02:25:07+00:00,2024-10-31 15:01:54+00:00,merged,7,4,1,https://github.com/home-assistant/core/pull/129366,New feature (which adds functionality to an existing integration),138,2024-10-30T13:28:02Z,cambridge_audio,noahhusby,"---BEGIN THREAD---
Diff Hunk:
@@ -19,10 +19,34 @@
 class CambridgeAudioSelectEntityDescription(SelectEntityDescription):
     """"""Describes Cambridge Audio select entity.""""""
 
+    options_fn: Callable[[StreamMagicClient], list[str]] = field(default=lambda _: [])
+    load_fn: Callable[[StreamMagicClient], bool] = field(default=lambda _: True)
     value_fn: Callable[[StreamMagicClient], str | None]
     set_value_fn: Callable[[StreamMagicClient, str], Awaitable[None]]
 
 
+async def _audio_output_set_value_fn(client: StreamMagicClient, value: str) -> None:
+    """"""Set the audio output using the display name.""""""
+    audio_output_id = next(
+        (output.id for output in client.audio_output.outputs if value == output.name),
+        None,
+    )
+    if audio_output_id:
+        await client.set_audio_output(audio_output_id)

(from reviewer) [2024-10-29T10:25:08Z] If we didn't find it, should we raise?
(from author) [2024-10-29T20:08:10Z] @joostlek Not sure we need to? The audio output object is already validated on the library side to guarentee that the ID and name are both present, so I can't see a way this would need to be raised.

The check is in the code just for type safety, not expecting that to ever be None type.
(from reviewer) [2024-10-30T13:11:27Z] In that case we should use an assert
(from author) [2024-10-30T13:20:13Z] Updated.
---END THREAD---",
129333,Add smart standby functionality to lamarzocco,2024-10-28 13:57:15+00:00,2024-10-30 13:06:58+00:00,merged,11,2,0,https://github.com/home-assistant/core/pull/129333,New feature (which adds functionality to an existing integration),341,2024-10-29T12:22:37Z,lamarzocco,zweckj,"---BEGIN THREAD---
Diff Hunk:
@@ -43,6 +43,16 @@
     PrebrewMode.PREINFUSION: ""preinfusion"",
 }
 
+STANDBY_MODE_HA_TO_LM = {
+    ""poweron"": SmartStandbyMode.POWER_ON,
+    ""lastbrewing"": SmartStandbyMode.LAST_BREWING,
+}
+
+STANDBY_MODE_LM_TO_HA = {
+    SmartStandbyMode.POWER_ON: ""poweron"",
+    SmartStandbyMode.LAST_BREWING: ""lastbrewing"",
+}

(from reviewer) [2024-10-29T12:01:17Z] ```suggestion
STANDBY_MODE_LM_TO_HA = {
    value: key for key, value in STANDBY_MODE_HA_TO_LM.items()
}
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -83,6 +93,20 @@ class LaMarzoccoSelectEntityDescription(
             MachineModel.LINEA_MINI,
         ),
     ),
+    LaMarzoccoSelectEntityDescription(
+        key=""smart_standby_mode"",
+        translation_key=""smart_standby_mode"",
+        entity_category=EntityCategory.CONFIG,
+        options=[""poweron"", ""lastbrewing""],

(from reviewer) [2024-10-29T12:01:34Z] I think it would make sense to call them `power_on` and `last_brewing`
---END THREAD---",
129325,Add shuffle media controls to Bang & Olufsen,2024-10-28 12:33:07+00:00,2024-10-29 15:02:12+00:00,merged,2,0,0,https://github.com/home-assistant/core/pull/129325,New feature (which adds functionality to an existing integration),57,2024-10-28T12:39:50Z,bang_olufsen,mj23000,,
129299,Add LG ThinQ integration,2024-10-28 01:10:12+00:00,2024-10-29 23:01:54+00:00,merged,27,7,0,https://github.com/home-assistant/core/pull/129299,New integration (thank you!),4379,2024-10-28T16:22:25Z,lg_thinq,LG-ThinQ-Integration,"(from author) [2024-10-28T04:46:35Z] I made the single PR for the whole lg_thinq integration from lg_thinq branch without any modifications.
But I don't know why 'running tests Python 3.12' failed.
Based on the log, I guess it is not from our implementations .
Please let me know if I should do something more.

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,166 @@
+""""""Support for LG ThinQ Connect device.""""""
+
+from __future__ import annotations
+
+import asyncio
+from dataclasses import dataclass, field
+import logging
+
+from thinqconnect import ThinQApi, ThinQAPIException
+from thinqconnect.integration import async_get_ha_bridge_list
+
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import (
+    CONF_ACCESS_TOKEN,
+    CONF_COUNTRY,
+    EVENT_HOMEASSISTANT_STOP,
+    Platform,
+)
+from homeassistant.core import HomeAssistant, callback
+from homeassistant.exceptions import ConfigEntryNotReady
+from homeassistant.helpers import device_registry as dr
+from homeassistant.helpers.aiohttp_client import async_get_clientsession
+from homeassistant.helpers.event import async_track_time_interval
+
+from .const import CONF_CONNECT_CLIENT_ID, MQTT_SUBSCRIPTION_INTERVAL
+from .coordinator import DeviceDataUpdateCoordinator, async_setup_device_coordinator
+from .mqtt import ThinQMQTT
+
+
+@dataclass(kw_only=True)
+class ThinqData:
+    """"""A class that holds runtime data.""""""
+
+    coordinators: dict[str, DeviceDataUpdateCoordinator] = field(default_factory=dict)
+    mqtt_client: ThinQMQTT | None = None
+
+
+type ThinqConfigEntry = ConfigEntry[ThinqData]
+
+PLATFORMS = [
+    Platform.BINARY_SENSOR,
+    Platform.CLIMATE,
+    Platform.EVENT,
+    Platform.FAN,
+    Platform.NUMBER,
+    Platform.SELECT,
+    Platform.SENSOR,
+    Platform.SWITCH,
+    Platform.VACUUM,
+]

(from reviewer) [2024-10-28T14:44:43Z] Please reduce to one platform https://developers.home-assistant.io/docs/review-process/#home-assistant-core
(from reviewer) [2024-10-28T14:57:58Z] Everything has been merged to an intermediary branch and already has been reviewed thoroughly :)

https://github.com/home-assistant/core/issues?q=label%3A%22integration%3A+lg_thinq%22+is%3Aclosed
(from reviewer) [2024-10-28T15:02:02Z] Oh! Forget I said anything then :)
(from reviewer) [2024-10-28T15:05:25Z] Thanks for staying sharp ❤️ 
(from reviewer) [2024-10-28T16:00:05Z] Joost! Is this going in for this beta? I've a washer to test, in case! :)
(from reviewer) [2024-10-28T16:20:13Z] That is the plan yes :)
(from author) [2024-10-28T22:14:24Z] > Joost! Is this going in for this beta? I've a washer to test, in case! :)

Thank u for the washer.
I hope it works :)
---END THREAD---",Design discussion
129280,Add reconfigure flow to Sensibo,2024-10-27 19:39:54+00:00,2024-10-29 12:03:13+00:00,merged,3,0,0,https://github.com/home-assistant/core/pull/129280,New feature (which adds functionality to an existing integration),251,2024-10-28T11:29:06Z,sensibo,gjohansson-ST,,
129279,Add diagnostics platform to PEGELONLINE,2024-10-27 19:05:46+00:00,2024-10-29 02:25:30+00:00,merged,3,0,0,https://github.com/home-assistant/core/pull/129279,New feature (which adds functionality to an existing integration),104,2024-10-27T19:36:56Z,pegel_online,mib1185,,
129277,Add battery binary sensor to Yale Smart Alarm,2024-10-27 18:23:46+00:00,2024-10-28 20:01:59+00:00,merged,5,2,0,https://github.com/home-assistant/core/pull/129277,New feature (which adds functionality to an existing integration),187,2024-10-27T19:57:10Z,yale_smart_alarm,gjohansson-ST,"---BEGIN THREAD---
Diff Hunk:
@@ -70,6 +74,27 @@ def is_on(self) -> bool:
         return bool(self.coordinator.data[""sensor_map""][self._attr_unique_id] == ""open"")
 
 
+class YaleDoorBatterySensor(YaleEntity, BinarySensorEntity):
+    """"""Representation of a Yale door sensor battery status.""""""
+
+    _attr_device_class = BinarySensorDeviceClass.BATTERY
+
+    def __init__(
+        self,
+        coordinator: YaleDataUpdateCoordinator,
+        data: dict,
+    ) -> None:
+        """"""Initiate Yale Problem Sensor.""""""

(from reviewer) [2024-10-27T19:39:08Z] ```suggestion
        """"""Initiate Yale door battery sensor.""""""
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -70,6 +74,27 @@ def is_on(self) -> bool:
         return bool(self.coordinator.data[""sensor_map""][self._attr_unique_id] == ""open"")
 
 
+class YaleDoorBatterySensor(YaleEntity, BinarySensorEntity):
+    """"""Representation of a Yale door sensor battery status.""""""
+
+    _attr_device_class = BinarySensorDeviceClass.BATTERY
+
+    def __init__(
+        self,
+        coordinator: YaleDataUpdateCoordinator,
+        data: dict,
+    ) -> None:
+        """"""Initiate Yale Problem Sensor.""""""
+        super().__init__(coordinator, data)
+        self._attr_unique_id = f""{data[""address""]}-battery""
+
+    @property
+    def is_on(self) -> bool:
+        """"""Return true if the binary sensor is on.""""""

(from reviewer) [2024-10-27T19:41:35Z] ```suggestion
        """"""Return true if the battery is low.""""""
```
---END THREAD---","Documentation, Documentation"
129274,Add support for Lutron HWQS Proc discovery,2024-10-27 16:58:48+00:00,2024-10-30 15:05:55+00:00,merged,2,0,1,https://github.com/home-assistant/core/pull/129274,New feature (which adds functionality to an existing integration),12,2024-10-29T12:27:44Z,lutron_caseta,eclair4151,"(from author) [2024-10-27T16:59:55Z] Bonjour Browser entry for HWQSX Proc:
![HWQSX_bonjour](https://github.com/user-attachments/assets/b40de8ac-ac92-4a68-9850-5aaf5d9f291d)

Testing after implementing fix:
![discovery](https://github.com/user-attachments/assets/76c3129d-b813-4ec7-a91b-a2c69f7ceda9)
![success](https://github.com/user-attachments/assets/f6105367-f1bb-47fc-a1ce-b613ffdb5bea)
",
129246,Allow a fixed number of ffmpeg proxy conversions per device,2024-10-26 23:02:39+00:00,2024-10-29 21:01:59+00:00,merged,2,0,1,https://github.com/home-assistant/core/pull/129246,New feature (which adds functionality to an existing integration),107,2024-10-28T20:26:43Z,esphome,synesthesiam,,
129232,Add name to description placeholders automatically for reauth flows,2024-10-26 17:55:08+00:00,2024-10-31 17:01:50+00:00,merged,7,8,3,https://github.com/home-assistant/core/pull/129232,New feature (which adds functionality to an existing integration),196,2024-10-30T16:39:01Z,,gjohansson-ST,"(from author) [2024-10-27T13:37:11Z] There are quite a few tests which does a reauth flow without having an attached config entry hence the many test failures. I suppose doing reauth without a config entry isn't supported so I'll update the tests accordingly.

---BEGIN THREAD---
Diff Hunk:
@@ -84,13 +83,7 @@ async def async_step_init(
             ):
                 errors[""base""] = ""cloud_credentials_incomplete""
                 # trigger re-auth flow
-                self.hass.async_create_task(
-                    self.hass.config_entries.flow.async_init(
-                        DOMAIN,
-                        context={""source"": SOURCE_REAUTH},
-                        data=self.config_entry.data,
-                    )
-                )
+                self.config_entry.async_start_reauth(self.hass)

(from reviewer) [2024-10-27T19:22:23Z] I think a few of these are bugfixes that should probably be moved to separate prs
(from author) [2024-10-27T19:53:36Z] I have made prel PR's for the two cases.
I think the test fixes can be left in this PR.
---END THREAD---

(from reviewer) [2024-10-28T07:56:06Z] fixes https://github.com/home-assistant/core/issues/129098

(from reviewer) [2024-10-28T08:18:10Z] What about removing existing placeholder and use the fallback?

(from author) [2024-10-28T08:26:01Z] > What about removing existing placeholder and use the fallback?

What do you mean?
If there is no `name`, set it to the entry title. If there is a `name`, we use that.

(from reviewer) [2024-10-28T08:30:07Z] > > What about removing existing placeholder and use the fallback?
> 
> What do you mean? If there is no `name`, set it to the entry title. If there is a `name`, we use that.

When I worked on #129134 I noticed that some integration already set the name correctly: 

https://github.com/home-assistant/core/blob/72504d761907d855140a6bf22a7627e062a39772/homeassistant/components/husqvarna_automower/config_flow.py#L74-L78

Should this now be removed to reduce boilerplate code?

(from author) [2024-10-28T08:58:23Z] > When I worked on #129134 I noticed that some integration already set the name correctly:
> 
> https://github.com/home-assistant/core/blob/72504d761907d855140a6bf22a7627e062a39772/homeassistant/components/husqvarna_automower/config_flow.py#L74-L78
> 
> Should this now be removed to reduce boilerplate code?

In that case yes but in follow-up PR's once this PR has been approved and merged.

---BEGIN THREAD---
Diff Hunk:
@@ -1191,7 +1192,7 @@ async def test_reconfigure_update_credentials(hass: HomeAssistant) -> None:
 
     result = await hass.config_entries.flow.async_init(
         DOMAIN,
-        context={""source"": ""reauth""},
+        context={""source"": ""reauth"", ""entry_id"": config_entry.entry_id},

(from reviewer) [2024-10-28T09:00:48Z] This block should be replaced by `result = await config_entry.start_reauth_flow(hass)`
(preferably in a preliminary PR)
(from author) [2024-10-28T09:07:29Z] https://github.com/home-assistant/core/pull/129313
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -2814,6 +2820,36 @@ def async_update_reload_and_abort(
                 reason = ""reconfigure_successful""
         return self.async_abort(reason=reason)
 
+    @callback
+    def async_show_form(
+        self,
+        *,
+        step_id: str | None = None,
+        data_schema: vol.Schema | None = None,
+        errors: dict[str, str] | None = None,
+        description_placeholders: Mapping[str, str | None] | None = None,
+        last_step: bool | None = None,
+        preview: str | None = None,
+    ) -> ConfigFlowResult:
+        """"""Return the definition of a form to gather user input.
+
+        The step_id parameter is deprecated and will be removed in a future release.
+        """"""
+        if self.source == SOURCE_REAUTH:
+            # If the integration does not provide a name for the reauth title,
+            # we append it to the description placeholders.

(from reviewer) [2024-10-28T09:30:47Z] As we have seen in weird implementations, I think this might be a breaking change for reauth flows triggered without a config entry.

We may need to ensure that `entry_id` is available.
```suggestion
        if self.source == SOURCE_REAUTH and ""entry_id"" in self.context:
            # If the integration does not provide a name for the reauth title,
            # we append it to the description placeholders.
            # We also need to check entry_id as some integrations bypass the 
            # reauth helpers and create a flow without it
```
(from author) [2024-10-28T09:36:38Z] Fair point even though I think it should be mandatory to provide an `entry_id` for both `reauth` and `reconfigure` flows.
Anyhow maybe that check should go elsewhere and do some logging (deprecation) first.
(from reviewer) [2024-10-28T09:39:17Z] I agree - a deprecation is needed in the ""init"".

But I think the check is still needed here - at least until the deprecation ends.
(from author) [2024-10-28T09:41:01Z] Unfortunately yes, anyway will add it once I rebase over https://github.com/home-assistant/core/pull/129313 that's pending
---END THREAD---","Testing, Design discussion, Interface, Design discussion"
129221,Add and remove plants (i.e. devices) dynamically in fyta,2024-10-26 11:59:12+00:00,2024-10-27 17:01:45+00:00,merged,9,0,0,https://github.com/home-assistant/core/pull/129221,New feature (which adds functionality to an existing integration),146,2024-10-26T13:35:43Z,fyta,dontinelli,,
129215,Add more spotify sensors,2024-10-26 10:43:14+00:00,2024-10-27 13:05:09+00:00,merged,7,0,0,https://github.com/home-assistant/core/pull/129215,New feature (which adds functionality to an existing integration),719,2024-10-26T12:43:33Z,spotify,joostlek,,
129187,Add parsec and astronomical unit for distance,2024-10-25 20:37:19+00:00,2024-10-27 09:02:03+00:00,closed,4,0,0,https://github.com/home-assistant/core/pull/129187,New feature (which adds functionality to an existing integration),18,2024-10-25T21:22:28Z,,jschlyter,"(from reviewer) [2024-10-25T20:50:55Z] This PR is changing our entity model. Before we can review this PR there needs to be approval in a discussion in our architecture repository.

https://github.com/home-assistant/architecture/discussions

https://developers.home-assistant.io/docs/core/entity#changing-the-entity-model",Invalid contribution
129160,Add support for Xiaomi Miio Standing Fan 2 (dmaker.fan.p18),2024-10-25 14:21:41+00:00,2024-10-27 06:02:29+00:00,merged,5,0,0,https://github.com/home-assistant/core/pull/129160,New feature (which adds functionality to an existing integration),30,2024-10-25T23:52:18Z,xiaomi_miio,bieniu,,
129151,Hassio logs boots,2024-10-25 11:44:50+00:00,2024-10-29 16:05:08+00:00,merged,2,0,3,https://github.com/home-assistant/core/pull/129151,New feature (which adds functionality to an existing integration),122,2024-10-28T15:41:14Z,hassio,wendevlin,,
129145,Migrate Smarty to has entity name,2024-10-25 10:56:49+00:00,2024-10-27 06:02:32+00:00,merged,11,0,0,https://github.com/home-assistant/core/pull/129145,New feature (which adds functionality to an existing integration),210,2024-10-26T00:28:27Z,smarty,joostlek,,
129144,Include go2rtc in default_config,2024-10-25 10:51:41+00:00,2024-10-26 15:01:55+00:00,merged,4,2,0,https://github.com/home-assistant/core/pull/129144,New feature (which adds functionality to an existing integration),29,2024-10-25T14:10:15Z,default_config,emontnemery,"---BEGIN THREAD---
Diff Hunk:
@@ -62,11 +62,17 @@
 async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
     """"""Set up WebRTC.""""""
     url: str | None = None
-    if not (url := config[DOMAIN].get(CONF_URL)):
+    if not (configured_by_user := DOMAIN in config) or not (
+        url := config[DOMAIN].get(CONF_URL)
+    ):
         if not is_docker_env():
+            if not configured_by_user:
+                return True
             _LOGGER.warning(""Go2rtc URL required in non-docker installs"")
             return False
         if not (binary := await _get_binary(hass)):
+            if not configured_by_user:
+                return True

(from author) [2024-10-25T10:53:03Z] We may want to fail here, we expect `go2rtc` to be available in our docker images
(from reviewer) [2024-10-25T11:06:51Z] Yes
---END THREAD---",Design discussion
129107,Add entity picture for healing potion in Habitica,2024-10-24 19:32:52+00:00,2024-10-26 09:01:56+00:00,merged,1,0,0,https://github.com/home-assistant/core/pull/129107,New feature (which adds functionality to an existing integration),1,2024-10-25T08:59:38Z,habitica,tr4nt0r,,
129094,Add support for Faucet services in HomeKit Controller,2024-10-24 16:23:18+00:00,2024-10-26 15:01:53+00:00,merged,5,0,0,https://github.com/home-assistant/core/pull/129094,New feature (which adds functionality to an existing integration),856,2024-10-25T09:15:14Z,homekit_controller,feisley,,
129088,Add reconfigure step to Onkyo config flow,2024-10-24 14:06:41+00:00,2024-10-31 16:02:05+00:00,merged,4,15,5,https://github.com/home-assistant/core/pull/129088,New feature (which adds functionality to an existing integration),242,2024-10-30T13:31:43Z,onkyo,arturpragacz,"(from author) [2024-10-24T14:15:13Z] @epenet What's the advantage of `suggested_values` over `default`?

(from reviewer) [2024-10-25T08:14:43Z] > @epenet What's the advantage of `suggested_values` over `default`?

It's a lot cleaner and makes for leaner code

Defaults can cause unexpected issue with clearing fields.


(from author) [2024-10-25T19:09:49Z] >Defaults can cause unexpected issue with clearing fields.

What do you mean by that?

>It's a lot cleaner and makes for leaner code

That is a little subjective, but I see your point.

The issue with changing it now is that those steps are also used by config flow as well, so doing it would be a bigger change than needed. If we decide to do it, can we maybe address it in another PR?

(from reviewer) [2024-10-28T18:34:39Z] > > Defaults can cause unexpected issue with clearing fields.
> 
> What do you mean by that?

One example is that if the user erase the content in the field and press submit, the schema will attach the default automatically (and in this case save the entry). One would expect that it would just fail as the field is required.

I think @epenet makes a valid point here to either fix it in this PR or perhaps in a preliminary PR to not extend this one further.

---BEGIN THREAD---
Diff Hunk:
@@ -93,13 +93,15 @@ async def async_step_manual(
 
                     return await self.async_step_configure_receiver()
 
-        host_default = {}
+        schema = vol.Schema({vol.Required(CONF_HOST): str})

(from reviewer) [2024-10-29T14:44:59Z] This can now be moved to a constant at the top of the file.
(from author) [2024-10-29T14:46:59Z] This is used only in this one place. What is the reason to move it all the way up, where it's far away from where it is actually being used?
(from reviewer) [2024-10-29T14:52:21Z] It's a general recommendation - we try to keep schemas as constants
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -210,23 +212,12 @@ async def async_step_configure_receiver(
 
         _LOGGER.debug(""Configuring receiver, info: %s"", self._receiver_info)
 
-        volume_resolution_default = OPTION_VOLUME_RESOLUTION_DEFAULT
-        input_sources_default = []
-        if entry_options is not None:
-            volume_resolution_default = entry_options[OPTION_VOLUME_RESOLUTION]
-            input_sources_default = [
-                InputSource(input_source).value_meaning
-                for input_source in entry_options[OPTION_INPUT_SOURCES]
-            ]
-
         schema = vol.Schema(
             {

(from reviewer) [2024-10-29T14:45:39Z] Same here, this can be converted to a constant now.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -236,9 +227,27 @@ async def async_step_configure_receiver(
             }
         )
 
+        if user_input is None:
+            suggested_values: dict[str, Any] = {}
+            if entry_options is None:
+                suggested_values[OPTION_VOLUME_RESOLUTION] = (
+                    OPTION_VOLUME_RESOLUTION_DEFAULT
+                )
+                suggested_values[OPTION_INPUT_SOURCES] = []
+            else:
+                suggested_values[OPTION_VOLUME_RESOLUTION] = entry_options[
+                    OPTION_VOLUME_RESOLUTION
+                ]
+                suggested_values[OPTION_INPUT_SOURCES] = [
+                    InputSource(input_source).value_meaning
+                    for input_source in entry_options[OPTION_INPUT_SOURCES]
+                ]
+        else:
+            suggested_values = user_input

(from reviewer) [2024-10-29T14:46:33Z] ```suggestion
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -236,9 +227,27 @@ async def async_step_configure_receiver(
             }
         )
 
+        if user_input is None:
+            suggested_values: dict[str, Any] = {}

(from reviewer) [2024-10-29T14:47:26Z] ```suggestion
        suggested_values = user_input
        if suggested_values is None:
            suggested_values = {}
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -96,15 +99,28 @@ async def async_step_manual(
                     errors[""base""] = ""cannot_connect""
                 else:
                     self._receiver_info = info
+
                     await self.async_set_unique_id(
                         info.identifier, raise_on_progress=False
                     )
-                    self._abort_if_unique_id_configured(updates=user_input)
+                    if self.source == SOURCE_RECONFIGURE:
+                        self._abort_if_unique_id_mismatch()
+                    else:
+                        self._abort_if_unique_id_configured(updates=user_input)
+
                     return await self.async_step_configure_receiver()
 
+        suggested_values = user_input
+        if suggested_values is None:
+            suggested_values = {}
+            if entry_data is not None:
+                suggested_values[CONF_HOST] = entry_data[CONF_HOST]

(from reviewer) [2024-10-29T15:10:08Z] ```suggestion
        if suggested_values is None and entry_data is not None:
            suggested_values = {CONF_HOST: entry_data[CONF_HOST]}
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -96,15 +99,28 @@ async def async_step_manual(
                     errors[""base""] = ""cannot_connect""
                 else:
                     self._receiver_info = info
+
                     await self.async_set_unique_id(
                         info.identifier, raise_on_progress=False
                     )
-                    self._abort_if_unique_id_configured(updates=user_input)
+                    if self.source == SOURCE_RECONFIGURE:
+                        self._abort_if_unique_id_mismatch()
+                    else:
+                        self._abort_if_unique_id_configured(updates=user_input)

(from reviewer) [2024-10-29T15:12:05Z] Since you are now implementing reconfigure, does it make sense to still allow updating the previous entry outside of reconfigure?
---END THREAD---

(from author) [2024-10-29T15:53:26Z] ~~Cannot replicate the failing test locally, not quite sure yet, where the problem is.~~

All tests working.

(from author) [2024-10-30T12:04:43Z] The `codecov` failure is a false positive (it pulls some random files into its analysis).

---BEGIN THREAD---
Diff Hunk:
@@ -96,15 +99,26 @@ async def async_step_manual(
                     errors[""base""] = ""cannot_connect""
                 else:
                     self._receiver_info = info
+
                     await self.async_set_unique_id(
                         info.identifier, raise_on_progress=False
                     )
-                    self._abort_if_unique_id_configured(updates=user_input)
+                    if self.source == SOURCE_RECONFIGURE:
+                        self._abort_if_unique_id_mismatch()
+                    else:
+                        self._abort_if_unique_id_configured()
+
                     return await self.async_step_configure_receiver()
 
+        suggested_values = user_input
+        if suggested_values is None and entry_data is not None:
+            suggested_values = {CONF_HOST: entry_data[CONF_HOST]}

(from reviewer) [2024-10-30T13:04:42Z] ```suggestion
        if suggested_values is None and self.source == SOURCE_RECONFIGURE:
            suggested_values = {CONF_HOST: self._get_reconfigure_entry().data[CONF_HOST]}
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -83,6 +82,10 @@ async def async_step_manual(
         """"""Handle manual device entry.""""""
         errors = {}
 
+        entry_data = None
+        if self.source == SOURCE_RECONFIGURE:
+            entry_data = self._get_reconfigure_entry().data
+

(from reviewer) [2024-10-30T13:04:57Z] Single-use variable
```suggestion
```
---END THREAD---

(from reviewer) [2024-10-30T13:29:48Z] I don't believe this is critical for the November release.

---BEGIN THREAD---
Diff Hunk:
@@ -46,13 +47,11 @@
 INPUT_SOURCES_ALL_MEANINGS = [
     input_source.value_meaning for input_source in InputSource
 ]
+STEP_MANUAL_SCHEMA = vol.Schema({vol.Required(CONF_HOST): str})
 STEP_CONFIGURE_SCHEMA = vol.Schema(
     {
-        vol.Required(
-            OPTION_VOLUME_RESOLUTION,
-            default=OPTION_VOLUME_RESOLUTION_DEFAULT,
-        ): vol.In(VOLUME_RESOLUTION_ALLOWED),
-        vol.Required(OPTION_INPUT_SOURCES, default=[]): SelectSelector(
+        vol.Required(OPTION_VOLUME_RESOLUTION): vol.In(VOLUME_RESOLUTION_ALLOWED),
+        vol.Required(OPTION_INPUT_SOURCES): SelectSelector(

(from reviewer) [2024-10-30T14:01:20Z] Why do we have an option for input sources (besides there was this option in YAML)?
(from author) [2024-10-30T14:21:17Z] That was already here before this PR. It was added with the config flow. 

The reason we have it is so that users can select which input sources are present on their receiver.
(from reviewer) [2024-10-30T14:36:43Z] Doesn't the device tell us what are present?
(from author) [2024-10-30T14:41:25Z] No, it does not.

There is a discovery mechanism for that, but it is not implemented by older receivers, and even for newer ones it is still not supported by the library we are using.
(from reviewer) [2024-10-30T14:47:39Z] Ok.
---END THREAD---","Solution approach, Code organization, Code organization, Code organization, Question, Code organization, Question"
129078,Add unique id and tests for Smarty,2024-10-24 11:48:36+00:00,2024-10-25 13:06:32+00:00,merged,10,0,0,https://github.com/home-assistant/core/pull/129078,New feature (which adds functionality to an existing integration),632,2024-10-24T12:54:20Z,smarty,joostlek,,
129029,Allow to use go2rtc binary from config dir,2024-10-23 13:16:40+00:00,2024-10-24 19:01:58+00:00,closed,2,0,0,https://github.com/home-assistant/core/pull/129029,New feature (which adds functionality to an existing integration),86,2024-10-23T17:06:20Z,go2rtc,felipecrs,"(from author) [2024-10-23T13:17:40Z] I understand this PR conflicts with https://github.com/home-assistant/core/pull/129020. Once https://github.com/home-assistant/core/pull/129020 is merged, I should handle any needed changes.

(from reviewer) [2024-10-23T17:06:20Z] Hi there @felipecrs 👋 

> Allow to use a go2rtc binary from the config dir (`/config/go2rtc`) if there is one.

The configuration directory isn't meant to store binary executables, it is meant for storing configuration and data.

For that reason, I'll go ahead and friendly decline this PR.

../Frenck



(from author) [2024-10-23T17:48:52Z] @frenck, that makes sense. How about introducing a configuration like:

```yaml
# configuration.yaml

go2rtc:
  binary: /wherever/user/wants
```

(from reviewer) [2024-10-23T18:01:39Z] > @frenck, that makes sense. How about introducing a configuration like:
> 
> 
> 
> ```yaml
> 
> # configuration.yaml
> 
> 
> 
> go2rtc:
> 
>   binary: /wherever/user/wants
> 
> ```

Solutions for that are in progress. The team is currently hard at work to get all parts in place. It isn't complete yet.

Besides this, we are also considering distributing the binary as an Python package (like for example uv does) to bundle it that route.

../Frenck

(from author) [2024-10-23T18:15:13Z] Alright, let's keep it for a future iteration then. Thank you.",Invalid contribution
129020,Remove go2rtc config flow,2024-10-23 07:07:08+00:00,2024-10-28 02:20:41+00:00,merged,10,20,2,https://github.com/home-assistant/core/pull/129020,New feature (which adds functionality to an existing integration),531,2024-10-25T09:13:44Z,go2rtc,emontnemery,"---BEGIN THREAD---
Diff Hunk:
@@ -46,22 +53,47 @@
 )
 
 
-async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
-    """"""Set up WebRTC from a config entry.""""""
-    if binary := entry.data.get(CONF_BINARY):
+CONFIG_SCHEMA = vol.Schema({DOMAIN: {vol.Optional(CONF_URL): cv.url}})
+
+
+async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
+    """"""Set up WebRTC.""""""
+    url: str | None = None
+    if DOMAIN not in config or not (url := config[DOMAIN].get(CONF_URL)):
+        if not is_docker_env():
+            _LOGGER.warning(""Go2rtc URL required in non-docker installs"")
+            return False
+        if not (binary := await _get_binary(hass)):
+            _LOGGER.error(""Could not find go2rtc docker binary"")
+            return False
+
         # HA will manage the binary
         server = Server(hass, binary)
-
-        entry.async_on_unload(server.stop)

(from reviewer) [2024-10-23T07:25:35Z] We should stop the server when HA is shutting down
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -46,22 +53,47 @@
 )
 
 
-async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
-    """"""Set up WebRTC from a config entry.""""""
-    if binary := entry.data.get(CONF_BINARY):
+CONFIG_SCHEMA = vol.Schema({DOMAIN: {vol.Optional(CONF_URL): cv.url}})
+
+
+async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
+    """"""Set up WebRTC.""""""
+    url: str | None = None
+    if DOMAIN not in config or not (url := config[DOMAIN].get(CONF_URL)):
+        if not is_docker_env():
+            _LOGGER.warning(""Go2rtc URL required in non-docker installs"")
+            return False
+        if not (binary := await _get_binary(hass)):
+            _LOGGER.error(""Could not find go2rtc docker binary"")
+            return False
+
         # HA will manage the binary
         server = Server(hass, binary)
-
-        entry.async_on_unload(server.stop)
         await server.start()
 
-    client = Go2RtcClient(async_get_clientsession(hass), entry.data[CONF_URL])
+    if url is not None:
+        # Validate user provided URL
+        try:
+            client = Go2RtcClient(async_get_clientsession(hass), url)
+            await client.streams.list()
+        except Exception:  # noqa: BLE001
+            _LOGGER.warning(""Could not connect to go2rtc instance on %s"", url)
+            return False
+    else:
+        url = ""http://localhost:1984/""
+
+    client = Go2RtcClient(async_get_clientsession(hass), url)
 
     provider = WebRTCProvider(client)
-    entry.async_on_unload(async_register_webrtc_provider(hass, provider))
+    async_register_webrtc_provider(hass, provider)

(from reviewer) [2024-10-23T07:27:02Z] Should we also deregister on shutdown too?
(from author) [2024-10-23T11:08:22Z] That seems pointless?
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -2,10 +2,9 @@
   ""domain"": ""go2rtc"",
   ""name"": ""go2rtc"",
   ""codeowners"": [""@home-assistant/core""],
-  ""config_flow"": true,
+  ""config_flow"": false,
   ""dependencies"": [""camera""],
   ""documentation"": ""https://www.home-assistant.io/integrations/go2rtc"",
   ""iot_class"": ""local_polling"",

(from reviewer) [2024-10-23T07:29:10Z] ```suggestion
  ""integration_type"": ""system"",
  ""iot_class"": ""local_polling"",
  ""quality_scale"": ""internal"",
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -46,22 +53,47 @@
 )
 
 
-async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
-    """"""Set up WebRTC from a config entry.""""""
-    if binary := entry.data.get(CONF_BINARY):
+CONFIG_SCHEMA = vol.Schema({DOMAIN: {vol.Optional(CONF_URL): cv.url}})
+
+
+async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
+    """"""Set up WebRTC.""""""
+    url: str | None = None
+    if DOMAIN not in config or not (url := config[DOMAIN].get(CONF_URL)):

(from reviewer) [2024-10-23T08:40:53Z] How will the integration be setup without the domain in the config, if there's no config flow?
(from author) [2024-10-23T11:09:41Z] The idea was to add go2rtc to `default_config` in a follow-up. I'll remove the check for `DOMAIN` until then
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -46,22 +53,47 @@
 )
 
 
-async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
-    """"""Set up WebRTC from a config entry.""""""
-    if binary := entry.data.get(CONF_BINARY):
+CONFIG_SCHEMA = vol.Schema({DOMAIN: {vol.Optional(CONF_URL): cv.url}})
+
+
+async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
+    """"""Set up WebRTC.""""""
+    url: str | None = None
+    if DOMAIN not in config or not (url := config[DOMAIN].get(CONF_URL)):
+        if not is_docker_env():
+            _LOGGER.warning(""Go2rtc URL required in non-docker installs"")
+            return False
+        if not (binary := await _get_binary(hass)):
+            _LOGGER.error(""Could not find go2rtc docker binary"")
+            return False
+
         # HA will manage the binary
         server = Server(hass, binary)
-
-        entry.async_on_unload(server.stop)
         await server.start()
 
-    client = Go2RtcClient(async_get_clientsession(hass), entry.data[CONF_URL])
+    if url is not None:
+        # Validate user provided URL
+        try:
+            client = Go2RtcClient(async_get_clientsession(hass), url)
+            await client.streams.list()
+        except Exception:  # noqa: BLE001
+            _LOGGER.warning(""Could not connect to go2rtc instance on %s"", url)
+            return False
+    else:
+        url = ""http://localhost:1984/""
+
+    client = Go2RtcClient(async_get_clientsession(hass), url)

(from reviewer) [2024-10-23T08:42:23Z] Shouldn't we check the connection with the default url too?
(from author) [2024-10-23T11:11:00Z] If the user configures their own URL, I think it would be confusing and unwanted if we anyway start our own server and try to connect to it.
(from reviewer) [2024-10-23T11:47:56Z] After this one is merged, I will add a check to verify the go2rtc version is a supported one.
If we cannot connect or the version is not supported we will not setup the integration
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -46,22 +53,47 @@
 )
 
 
-async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
-    """"""Set up WebRTC from a config entry.""""""
-    if binary := entry.data.get(CONF_BINARY):
+CONFIG_SCHEMA = vol.Schema({DOMAIN: {vol.Optional(CONF_URL): cv.url}})
+
+
+async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
+    """"""Set up WebRTC.""""""
+    url: str | None = None
+    if DOMAIN not in config or not (url := config[DOMAIN].get(CONF_URL)):
+        if not is_docker_env():
+            _LOGGER.warning(""Go2rtc URL required in non-docker installs"")
+            return False
+        if not (binary := await _get_binary(hass)):
+            _LOGGER.error(""Could not find go2rtc docker binary"")
+            return False
+
         # HA will manage the binary
         server = Server(hass, binary)
-
-        entry.async_on_unload(server.stop)
         await server.start()
 
-    client = Go2RtcClient(async_get_clientsession(hass), entry.data[CONF_URL])
+    if url is not None:
+        # Validate user provided URL
+        try:
+            client = Go2RtcClient(async_get_clientsession(hass), url)
+            await client.streams.list()
+        except Exception:  # noqa: BLE001
+            _LOGGER.warning(""Could not connect to go2rtc instance on %s"", url)
+            return False
+    else:
+        url = ""http://localhost:1984/""
+
+    client = Go2RtcClient(async_get_clientsession(hass), url)
 
     provider = WebRTCProvider(client)
-    entry.async_on_unload(async_register_webrtc_provider(hass, provider))
+    async_register_webrtc_provider(hass, provider)
     return True
 
 
+async def _get_binary(hass: HomeAssistant) -> str | None:
+    """"""Return the binary path if found.""""""
+    return await hass.async_add_executor_job(shutil.which, DOMAIN)

(from reviewer) [2024-10-23T08:43:38Z] I'd not use the domain name constant for the binary name. They happen to be the same but they represent different things.
(from author) [2024-10-23T11:11:54Z] Yeah, agreed 👍 
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -46,22 +53,52 @@
 )
 
 
-async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
-    """"""Set up WebRTC from a config entry.""""""
-    if binary := entry.data.get(CONF_BINARY):
+CONFIG_SCHEMA = vol.Schema({DOMAIN: {vol.Optional(CONF_URL): cv.url}})
+
+
+async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
+    """"""Set up WebRTC.""""""
+    url: str | None = None
+    if not (url := config[DOMAIN].get(CONF_URL)):
+        if not is_docker_env():
+            _LOGGER.warning(""Go2rtc URL required in non-docker installs"")

(from reviewer) [2024-10-23T14:37:20Z] Would it make sense to add a repair issue in this case where we explain that without go2rtc you have a subpar experience and explain where to find documentation about it?
(from author) [2024-10-23T15:09:45Z] I don't think it's necessary. This is only an issue for core users, and we expect them to be very technical and manage the installation by themselves. I think they can connect the dots if they try to enable the go2rtc integration and see this error message.
(from reviewer) [2024-10-26T15:48:50Z] But the `go2rtc` integration will be enabled transparent and it's not easy for the user to identify if currently WebRTC or HLS is being used.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -46,22 +53,52 @@
 )
 
 
-async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
-    """"""Set up WebRTC from a config entry.""""""
-    if binary := entry.data.get(CONF_BINARY):
+CONFIG_SCHEMA = vol.Schema({DOMAIN: {vol.Optional(CONF_URL): cv.url}})
+
+
+async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
+    """"""Set up WebRTC.""""""
+    url: str | None = None
+    if not (url := config[DOMAIN].get(CONF_URL)):
+        if not is_docker_env():
+            _LOGGER.warning(""Go2rtc URL required in non-docker installs"")
+            return False
+        if not (binary := await _get_binary(hass)):
+            _LOGGER.error(""Could not find go2rtc docker binary"")
+            return False
+
         # HA will manage the binary
         server = Server(hass, binary)
-
-        entry.async_on_unload(server.stop)
         await server.start()
 
-    client = Go2RtcClient(async_get_clientsession(hass), entry.data[CONF_URL])
+        async def on_stop(event: Event) -> None:
+            await server.stop()
+
+        hass.bus.async_listen(EVENT_HOMEASSISTANT_STOP, on_stop)
+
+    if url is None:

(from reviewer) [2024-10-24T20:54:45Z] ```suggestion
```
(from author) [2024-10-25T06:44:21Z] We can't remove this check?
(from reviewer) [2024-10-25T07:00:05Z] There's already a falsy check above, on line 62.
(from author) [2024-10-25T07:07:23Z] Hm, right
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -46,22 +53,52 @@
 )
 
 
-async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
-    """"""Set up WebRTC from a config entry.""""""
-    if binary := entry.data.get(CONF_BINARY):
+CONFIG_SCHEMA = vol.Schema({DOMAIN: {vol.Optional(CONF_URL): cv.url}})
+
+
+async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
+    """"""Set up WebRTC.""""""
+    url: str | None = None
+    if not (url := config[DOMAIN].get(CONF_URL)):
+        if not is_docker_env():
+            _LOGGER.warning(""Go2rtc URL required in non-docker installs"")
+            return False
+        if not (binary := await _get_binary(hass)):
+            _LOGGER.error(""Could not find go2rtc docker binary"")
+            return False
+
         # HA will manage the binary
         server = Server(hass, binary)
-
-        entry.async_on_unload(server.stop)
         await server.start()
 
-    client = Go2RtcClient(async_get_clientsession(hass), entry.data[CONF_URL])
+        async def on_stop(event: Event) -> None:
+            await server.stop()
+
+        hass.bus.async_listen(EVENT_HOMEASSISTANT_STOP, on_stop)
+
+    if url is None:
+        url = ""http://localhost:1984/""
+
+    # Validate the server URL
+    try:
+        client = Go2RtcClient(async_get_clientsession(hass), url)
+        await client.streams.list()
+    except Exception:  # noqa: BLE001
+        _LOGGER.warning(""Could not connect to go2rtc instance on %s"", url)
+        return False
+
+    client = Go2RtcClient(async_get_clientsession(hass), url)

(from reviewer) [2024-10-24T20:55:22Z] ```suggestion
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -46,22 +53,52 @@
 )
 
 
-async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
-    """"""Set up WebRTC from a config entry.""""""
-    if binary := entry.data.get(CONF_BINARY):
+CONFIG_SCHEMA = vol.Schema({DOMAIN: {vol.Optional(CONF_URL): cv.url}})
+
+
+async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:
+    """"""Set up WebRTC.""""""
+    url: str | None = None
+    if not (url := config[DOMAIN].get(CONF_URL)):
+        if not is_docker_env():
+            _LOGGER.warning(""Go2rtc URL required in non-docker installs"")
+            return False
+        if not (binary := await _get_binary(hass)):
+            _LOGGER.error(""Could not find go2rtc docker binary"")
+            return False
+
         # HA will manage the binary
         server = Server(hass, binary)
-
-        entry.async_on_unload(server.stop)
         await server.start()
 
-    client = Go2RtcClient(async_get_clientsession(hass), entry.data[CONF_URL])
+        async def on_stop(event: Event) -> None:
+            await server.stop()
+
+        hass.bus.async_listen(EVENT_HOMEASSISTANT_STOP, on_stop)
+
+    if url is None:
+        url = ""http://localhost:1984/""
+
+    # Validate the server URL
+    try:
+        client = Go2RtcClient(async_get_clientsession(hass), url)
+        await client.streams.list()
+    except Exception:  # noqa: BLE001
+        _LOGGER.warning(""Could not connect to go2rtc instance on %s"", url)
+        return False
+
+    client = Go2RtcClient(async_get_clientsession(hass), url)
 

(from reviewer) [2024-10-24T20:55:30Z] ```suggestion
```
---END THREAD---","Functional defect, Design discussion, Documentation, Functional defect, Design discussion, Naming convention, Alternate output, Validation"
129006,Add units for energy consumed per distance,2024-10-22 20:50:56+00:00,2024-10-24 10:01:59+00:00,closed,10,3,0,https://github.com/home-assistant/core/pull/129006,New feature (which adds functionality to an existing integration),213,2024-10-23T09:14:15Z,sensor,jschlyter,"---BEGIN THREAD---
Diff Hunk:
@@ -165,6 +166,15 @@ class NumberDeviceClass(StrEnum):
     Unit of measurement: `Wh`, `kWh`, `MWh`, `MJ`, `GJ`
     """"""
 
+    ENERGY_DISTANCE = ""energy_distance""

(from reviewer) [2024-10-23T09:03:49Z] This PR is changing our entity model. Before we can review this PR there needs to be approval in a discussion in our architecture repository.

https://github.com/home-assistant/architecture/discussions

https://developers.home-assistant.io/docs/core/entity#changing-the-entity-model
(from author) [2024-10-23T09:12:53Z] Thank you, I've started a discussion at https://github.com/home-assistant/architecture/discussions/1163
(from reviewer) [2024-10-23T09:14:12Z] Awesome! While we await the result of that discussion, I'll go ahead and close up this PR for now.

We can re-open it when the proposal is accepted.

../Frenck
---END THREAD---",
129002,Add play media capability to Cambridge Audio,2024-10-22 19:14:01+00:00,2024-10-25 19:01:41+00:00,merged,6,7,1,https://github.com/home-assistant/core/pull/129002,New feature (which adds functionality to an existing integration),240,2024-10-24T18:33:54Z,cambridge_audio,noahhusby,"---BEGIN THREAD---
Diff Hunk:
@@ -285,3 +293,35 @@ async def async_set_repeat(self, repeat: RepeatMode) -> None:
         if repeat in {RepeatMode.ALL, RepeatMode.ONE}:
             repeat_mode = CambridgeRepeatMode.ALL
         await self.client.set_repeat(repeat_mode)
+
+    @command
+    async def async_play_media(
+        self, media_type: MediaType | str, media_id: str, **kwargs: Any
+    ) -> None:
+        """"""Play media on the Cambridge Audio device.""""""
+
+        if media_type not in {
+            CAMBRIDGE_MEDIA_TYPE_PRESET,
+            CAMBRIDGE_MEDIA_TYPE_AIRABLE,
+            CAMBRIDGE_MEDIA_TYPE_INTERNET_RADIO,
+        }:
+            raise HomeAssistantError(
+                f""Unsupported media type for Cambridge Audio device: {media_type}""
+            )
+
+        if media_type == CAMBRIDGE_MEDIA_TYPE_PRESET:
+            preset_id = int(media_id)
+            preset = None
+            for _preset in self.client.preset_list.presets:
+                if _preset.preset_id == preset_id:
+                    preset = _preset
+            if not preset:
+                raise ValueError(f""Missing preset for media_id: {media_id}"")

(from reviewer) [2024-10-24T17:56:38Z] Is this an user error or can this happen? Ideally we raise `HomeAssistantError` or `ServiceValidationError`
(from author) [2024-10-24T18:00:51Z] @joostlek This is a user error. ServiceValidationError would be appropriate here.
(from author) [2024-10-24T18:01:21Z] Besides this error (and the fact it needs to be translated), and coverage anything else that's not explicitly platinum compliant?
(from reviewer) [2024-10-24T18:23:01Z] The errors could use translations
(from author) [2024-10-24T18:24:25Z] Updated 👍
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -302,3 +306,121 @@ async def test_media_seek(
     )
 
     mock_stream_magic_client.media_seek.assert_called_once_with(100)
+
+
+async def test_play_media_preset_item_id(
+    hass: HomeAssistant,
+    mock_config_entry: MockConfigEntry,
+    mock_stream_magic_client: AsyncMock,
+) -> None:
+    """"""Test playing media with a preset item id.""""""
+    await setup_integration(hass, mock_config_entry)
+
+    await hass.services.async_call(
+        MP_DOMAIN,
+        SERVICE_PLAY_MEDIA,
+        {
+            ATTR_ENTITY_ID: ENTITY_ID,
+            ATTR_MEDIA_CONTENT_TYPE: ""preset"",
+            ATTR_MEDIA_CONTENT_ID: ""1"",
+        },
+        blocking=True,
+    )
+    assert mock_stream_magic_client.recall_preset.call_count == 1
+    assert mock_stream_magic_client.recall_preset.call_args_list[0].args[0] == 1
+
+    with pytest.raises(ServiceValidationError) as sve:
+        await hass.services.async_call(
+            MP_DOMAIN,
+            SERVICE_PLAY_MEDIA,
+            {
+                ATTR_ENTITY_ID: ENTITY_ID,
+                ATTR_MEDIA_CONTENT_TYPE: ""preset"",
+                ATTR_MEDIA_CONTENT_ID: ""10"",
+            },
+            blocking=True,
+        )
+    assert ""10"" in str(sve.value)
+
+    with pytest.raises(ServiceValidationError) as sve:
+        await hass.services.async_call(
+            MP_DOMAIN,
+            SERVICE_PLAY_MEDIA,
+            {
+                ATTR_ENTITY_ID: ENTITY_ID,
+                ATTR_MEDIA_CONTENT_TYPE: ""preset"",
+                ATTR_MEDIA_CONTENT_ID: ""UNKNOWN_PRESET"",
+            },
+            blocking=True,
+        )
+    assert ""UNKNOWN_PRESET"" in str(sve.value)
+
+
+async def test_play_media_airable_radio_id(
+    hass: HomeAssistant,
+    mock_config_entry: MockConfigEntry,
+    mock_stream_magic_client: AsyncMock,
+) -> None:
+    """"""Test playing media with an airable radio id.""""""
+    await setup_integration(hass, mock_config_entry)
+
+    await hass.services.async_call(
+        MP_DOMAIN,
+        SERVICE_PLAY_MEDIA,
+        {
+            ATTR_ENTITY_ID: ENTITY_ID,
+            ATTR_MEDIA_CONTENT_TYPE: ""airable"",
+            ATTR_MEDIA_CONTENT_ID: ""12345678"",
+        },
+        blocking=True,
+    )
+    assert mock_stream_magic_client.play_radio_airable.call_count == 1
+    call_args = mock_stream_magic_client.play_radio_airable.call_args_list[0].args
+    assert call_args[0] == ""Radio""
+    assert call_args[1] == 12345678
+
+
+async def test_play_media_internet_radio(
+    hass: HomeAssistant,
+    mock_config_entry: MockConfigEntry,
+    mock_stream_magic_client: AsyncMock,
+) -> None:
+    """"""Test playing media with a url.""""""
+    await setup_integration(hass, mock_config_entry)
+
+    await hass.services.async_call(
+        MP_DOMAIN,
+        SERVICE_PLAY_MEDIA,
+        {
+            ATTR_ENTITY_ID: ENTITY_ID,
+            ATTR_MEDIA_CONTENT_TYPE: ""internet_radio"",
+            ATTR_MEDIA_CONTENT_ID: ""https://example.com"",
+        },
+        blocking=True,
+    )
+    assert mock_stream_magic_client.play_radio_url.call_count == 1
+    call_args = mock_stream_magic_client.play_radio_url.call_args_list[0].args
+    assert call_args[0] == ""Radio""
+    assert call_args[1] == ""https://example.com""
+
+
+async def test_play_media_unknown_type(
+    hass: HomeAssistant,
+    mock_config_entry: MockConfigEntry,
+    mock_stream_magic_client: AsyncMock,
+) -> None:
+    """"""Test playing media with an unsupported content type.""""""
+    await setup_integration(hass, mock_config_entry)
+
+    with pytest.raises(HomeAssistantError) as err:
+        await hass.services.async_call(
+            MP_DOMAIN,
+            SERVICE_PLAY_MEDIA,
+            {
+                ATTR_ENTITY_ID: ENTITY_ID,
+                ATTR_MEDIA_CONTENT_TYPE: ""unsupported_content_type"",
+                ATTR_MEDIA_CONTENT_ID: ""1"",
+            },
+            blocking=True,
+        )
+    assert ""Unsupported media type"" in str(err.value)

(from reviewer) [2024-10-24T18:26:25Z] ```suggestion
    with pytest.raises(HomeAssistantError, match=""Unsupported media type""):
        await hass.services.async_call(
            MP_DOMAIN,
            SERVICE_PLAY_MEDIA,
            {
                ATTR_ENTITY_ID: ENTITY_ID,
                ATTR_MEDIA_CONTENT_TYPE: ""unsupported_content_type"",
                ATTR_MEDIA_CONTENT_ID: ""1"",
            },
            blocking=True,
        )
```
(from author) [2024-10-24T18:27:20Z] Ah cool, I'll update.
---END THREAD---",
129001,Add media browsing / playback to Cambridge Audio,2024-10-22 19:04:31+00:00,2024-10-23 20:02:02+00:00,closed,8,0,0,https://github.com/home-assistant/core/pull/129001,New feature (which adds functionality to an existing integration),446,2024-10-22T19:14:21Z,cambridge_audio,noahhusby,,
128991,Add Meter Pro support to SwitchBot,2024-10-22 17:21:01+00:00,2024-10-25 18:02:32+00:00,merged,5,0,1,https://github.com/home-assistant/core/pull/128991,New feature (which adds functionality to an existing integration),84,2024-10-24T15:49:40Z,switchbot,bdraco,(from author) [2024-10-24T17:26:00Z] Thanks ,
128984,Allow configuring WebRTC stun and turn servers,2024-10-22 15:14:37+00:00,2024-10-24 13:06:57+00:00,merged,8,6,0,https://github.com/home-assistant/core/pull/128984,New feature (which adds functionality to an existing integration),317,2024-10-23T12:41:46Z,camera,emontnemery,"---BEGIN THREAD---
Diff Hunk:
@@ -402,6 +401,8 @@ def unsub_track_time_interval(_event: Event) -> None:
     )
 
     async def get_ice_server() -> RTCIceServer:

(from author) [2024-10-22T15:15:19Z] Can we let this function return a list instead of a single item?
(from reviewer) [2024-10-23T07:47:35Z] Yes, we can. You can change it in this PR
(from author) [2024-10-23T10:08:22Z] Done in PR https://github.com/home-assistant/core/pull/129024
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -361,6 +378,24 @@ def _validate_currency(data: Any) -> Any:
             vol.Optional(CONF_COUNTRY): cv.country,
             vol.Optional(CONF_LANGUAGE): cv.language,
             vol.Optional(CONF_DEBUG): cv.boolean,
+            vol.Optional(CONF_WEBRTC): vol.Schema(
+                {
+                    vol.Required(CONF_ICE_SERVERS): vol.All(
+                        cv.ensure_list,
+                        [
+                            vol.Schema(
+                                {
+                                    vol.Required(CONF_URL): vol.All(
+                                        cv.ensure_list, [stun_or_turn_url]
+                                    ),
+                                    vol.Optional(CONF_USERNAME): cv.string,
+                                    vol.Optional(CONF_CREDENTIAL): cv.string,
+                                }
+                            )
+                        ],
+                    )
+                }
+            ),

(from author) [2024-10-22T15:16:23Z] It seems a bit unwanted to add the WebRTC specific validation here and a WebRTC specific object to hass.config.
Maybe a webrtc integration, which just holds the configuration, would be more appropriate?
(from author) [2024-10-23T10:08:43Z] Discussed offline, with the conclusion it's OK to add this to the core config
---END THREAD---

(from author) [2024-10-22T15:17:18Z] I'll add more tests once I get some feedback on the solution, in particular if WebRTC ICE-server configuration belongs under the `homeassistant`-key, or if a better match would be in a `webrtc` integration.

Discussed offline, with the conclusion the solution is OK. I've added tests.

(from author) [2024-10-23T10:10:24Z] User documentation is needed

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,76 @@
+""""""WebRTC container classes.""""""
+
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Any
+
+
+@dataclass
+class RTCIceServer:
+    """"""RTC Ice Server.
+
+    See https://www.w3.org/TR/webrtc/#rtciceserver-dictionary
+    """"""
+
+    urls: list[str] | str
+    username: str | None = None
+    credential: str | None = None
+
+    def to_frontend_dict(self) -> dict[str, Any]:
+        """"""Return a dict that can be used by the frontend.""""""
+
+        data = {
+            ""urls"": self.urls,
+        }
+        if self.username is not None:
+            data[""username""] = self.username
+        if self.credential is not None:
+            data[""credential""] = self.credential
+        return data
+
+
+@dataclass
+class RTCConfiguration:
+    """"""RTC Configuration.
+
+    See https://www.w3.org/TR/webrtc/#rtcconfiguration-dictionary
+    """"""
+
+    ice_servers: list[RTCIceServer] = field(default_factory=list)
+
+    def to_frontend_dict(self) -> dict[str, Any]:
+        """"""Return a dict that can be used by the frontend.""""""
+        if not self.ice_servers:
+            return {}
+
+        return {
+            ""iceServers"": [server.to_frontend_dict() for server in self.ice_servers]
+        }
+
+
+@dataclass(kw_only=True)
+class WebRTCClientConfiguration:
+    """"""WebRTC configuration for the client.
+
+    Not part of the spec, but required to configure client.
+    """"""
+
+    configuration: RTCConfiguration = field(default_factory=RTCConfiguration)
+    data_channel: str | None = None
+
+    def to_frontend_dict(self) -> dict[str, Any]:
+        """"""Return a dict that can be used by the frontend.""""""
+        data: dict[str, Any] = {
+            ""configuration"": self.configuration.to_frontend_dict(),
+        }
+        if self.data_channel is not None:
+            data[""dataChannel""] = self.data_channel
+        return data
+
+
+@dataclass
+class WebRTCCoreConfiguration:

(from reviewer) [2024-10-23T10:20:52Z] This class is the same as `RTCConfiguration`. We could use that one instead
---END THREAD---",
128947,Add mapping for switchbot meter pro,2024-10-21 22:19:00+00:00,2024-10-23 20:02:03+00:00,closed,1,2,0,https://github.com/home-assistant/core/pull/128947,New feature (which adds functionality to an existing integration),2,2024-10-22T19:07:17Z,switchbot,bdraco,"(from author) [2024-10-22T04:29:42Z] drafting for one more lib bump since the CO2 model can be added now even though we don't know how to decode the CO2 value yet .. it will still get temp and humid support

https://github.com/home-assistant/core/pull/128953

---BEGIN THREAD---
Diff Hunk:
@@ -48,6 +48,7 @@ class SupportedModels(StrEnum):
 NON_CONNECTABLE_SUPPORTED_MODEL_TYPES = {
     SwitchbotModel.METER: SupportedModels.HYGROMETER,
     SwitchbotModel.IO_METER: SupportedModels.HYGROMETER,
+    SwitchbotModel.METER_PRO: SupportedModels.HYGROMETER,

(from author) [2024-10-22T15:57:28Z] ```suggestion
    SwitchbotModel.METER_PRO: SupportedModels.HYGROMETER,
    SwitchbotModel.METER_PRO_C: SupportedModels.HYGROMETER,    
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -48,6 +48,8 @@ class SupportedModels(StrEnum):
 NON_CONNECTABLE_SUPPORTED_MODEL_TYPES = {
     SwitchbotModel.METER: SupportedModels.HYGROMETER,
     SwitchbotModel.IO_METER: SupportedModels.HYGROMETER,
+    SwitchbotModel.METER_PRO: SupportedModels.HYGROMETER,
+    SwitchbotModel.METER_PRO_C: SupportedModels.HYGROMETER,    

(from author) [2024-10-22T16:01:35Z] ```suggestion
    SwitchbotModel.METER_PRO_C: SupportedModels.HYGROMETER,
```
---END THREAD---

(from author) [2024-10-22T19:06:16Z] closing in favor of https://github.com/home-assistant/core/pull/128991",
128942,Add cloud ICE server registration,2024-10-21 20:51:50+00:00,2024-10-30 20:02:04+00:00,merged,9,14,7,https://github.com/home-assistant/core/pull/128942,New feature (which adds functionality to an existing integration),152,2024-10-29T19:35:52Z,cloud,klejejs,"---BEGIN THREAD---
Diff Hunk:
@@ -9,9 +9,11 @@
 from typing import cast
 
 from hass_nabucasa import Cloud
+from hass_nabucasa.ice_servers import IceServer
 import voluptuous as vol
 
 from homeassistant.components import alexa, google_assistant
+from homeassistant.components.camera.webrtc import RTCIceServer, register_ice_server

(from reviewer) [2024-10-22T06:29:17Z] We normally only want to import from the integration package module and not from submodules.
(from author) [2024-10-25T12:05:25Z] Should I change the export of the camera package? Should it be done within this PR?
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -11,12 +12,17 @@
 
 import aiohttp
 from hass_nabucasa.client import CloudClient as Interface, RemoteActivationNotAllowed
+from webrtc_models import RTCIceServer
 
 from homeassistant.components import google_assistant, persistent_notification, webhook
 from homeassistant.components.alexa import (
     errors as alexa_errors,
     smart_home as alexa_smart_home,
 )
+from homeassistant.components.camera.webrtc import (
+    RTCIceServer as RTCIceServerOld,

(from author) [2024-10-24T13:38:42Z] This import will be removed once #129032 is merged
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -183,6 +184,44 @@ async def test_handler_google_actions_disabled(
     assert resp[""payload""] == response_payload
 
 
+async def test_handler_ice_servers(
+    hass: HomeAssistant, mock_cloud_fixture: CloudPreferences

(from reviewer) [2024-10-25T11:16:05Z] This fixture is legacy. The new way is to use the `cloud` fixture and `set_cloud_prefs` fixture.
(from author) [2024-10-25T12:32:18Z] Did I do it in a way you meant now?
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -183,6 +184,44 @@ async def test_handler_google_actions_disabled(
     assert resp[""payload""] == response_payload
 
 
+async def test_handler_ice_servers(
+    hass: HomeAssistant, mock_cloud_fixture: CloudPreferences
+) -> None:
+    """"""Test handler ICE servers.""""""
+    mock_cloud_fixture._prefs[PREF_ENABLE_ALEXA] = False
+    mock_cloud_fixture._prefs[PREF_ENABLE_GOOGLE] = False
+    mock_cloud_fixture.async_set_username = AsyncMock(return_value=None)
+    mock_cloud_fixture._prefs[PREF_ENABLE_CLOUD_ICE_SERVERS] = True
+
+    client = CloudClient(hass, mock_cloud_fixture, None, {}, {})
+    client.cloud = Mock(is_logged_in=True, subscription_expired=False)
+    client.cloud.ice_servers = Mock(

(from reviewer) [2024-10-25T11:17:11Z] Update the `cloud` fixture instead.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -60,6 +63,7 @@ def __init__(
         self._alexa_config_init_lock = asyncio.Lock()
         self._google_config_init_lock = asyncio.Lock()
         self._relayer_region: str | None = None
+        self._cloud_ice_servers_listener: Callable | None = None

(from reviewer) [2024-10-25T11:20:54Z] ```suggestion
        self._cloud_ice_servers_listener: Callable[[], None] | None = None
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -184,38 +183,46 @@ async def test_handler_google_actions_disabled(
     assert resp[""payload""] == response_payload
 
 
-async def test_handler_ice_servers(
-    hass: HomeAssistant, mock_cloud_fixture: CloudPreferences
-) -> None:
+async def test_handler_ice_servers(hass: HomeAssistant) -> None:
     """"""Test handler ICE servers.""""""
-    mock_cloud_fixture._prefs[PREF_ENABLE_ALEXA] = False
-    mock_cloud_fixture._prefs[PREF_ENABLE_GOOGLE] = False
-    mock_cloud_fixture.async_set_username = AsyncMock(return_value=None)
-    mock_cloud_fixture._prefs[PREF_ENABLE_CLOUD_ICE_SERVERS] = True
-
-    client = CloudClient(hass, mock_cloud_fixture, None, {}, {})
-    client.cloud = Mock(is_logged_in=True, subscription_expired=False)
-    client.cloud.ice_servers = Mock(
-        async_register_ice_servers_listener=AsyncMock(return_value=""mock-unregister"")
+    prefs = MagicMock(
+        alexa_enabled=False,
+        google_enabled=False,
+        async_set_username=AsyncMock(return_value=None),
+        cloud_ice_servers_enabled=True,
+    )
+    client = CloudClient(hass, prefs, None, {}, {})
+    client.cloud = Mock(
+        is_logged_in=True,
+        subscription_expired=False,
+        ice_servers=Mock(
+            async_register_ice_servers_listener=AsyncMock(
+                return_value=""mock-unregister""
+            )
+        ),
     )
 
     await client.cloud_connected()
     assert client._cloud_ice_servers_listener == ""mock-unregister""
 
 
-async def test_handler_ice_servers_disabled(
-    hass: HomeAssistant, mock_cloud_fixture: CloudPreferences
-) -> None:
+async def test_handler_ice_servers_disabled(hass: HomeAssistant) -> None:
     """"""Test handler ICE servers when user has disabled it.""""""
-    mock_cloud_fixture._prefs[PREF_ENABLE_ALEXA] = False
-    mock_cloud_fixture._prefs[PREF_ENABLE_GOOGLE] = False
-    mock_cloud_fixture.async_set_username = AsyncMock(return_value=None)
-    mock_cloud_fixture._prefs[PREF_ENABLE_CLOUD_ICE_SERVERS] = False
-
-    client = CloudClient(hass, mock_cloud_fixture, None, {}, {})
-    client.cloud = Mock(is_logged_in=True, subscription_expired=False)
-    client.cloud.ice_servers = Mock(
-        async_register_ice_servers_listener=AsyncMock(return_value=""mock-unregister"")
+    prefs = MagicMock(
+        alexa_enabled=False,
+        google_enabled=False,
+        async_set_username=AsyncMock(return_value=None),
+        cloud_ice_servers_enabled=False,
+    )
+    client = CloudClient(hass, prefs, None, {}, {})

(from reviewer) [2024-10-25T20:14:41Z] We shouldn't create the cloud client in the test. That will happen when we set up the cloud integration. Set up the integration either in the test or in a fixture.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -184,38 +183,46 @@ async def test_handler_google_actions_disabled(
     assert resp[""payload""] == response_payload
 
 
-async def test_handler_ice_servers(
-    hass: HomeAssistant, mock_cloud_fixture: CloudPreferences
-) -> None:
+async def test_handler_ice_servers(hass: HomeAssistant) -> None:
     """"""Test handler ICE servers.""""""
-    mock_cloud_fixture._prefs[PREF_ENABLE_ALEXA] = False
-    mock_cloud_fixture._prefs[PREF_ENABLE_GOOGLE] = False
-    mock_cloud_fixture.async_set_username = AsyncMock(return_value=None)
-    mock_cloud_fixture._prefs[PREF_ENABLE_CLOUD_ICE_SERVERS] = True
-
-    client = CloudClient(hass, mock_cloud_fixture, None, {}, {})
-    client.cloud = Mock(is_logged_in=True, subscription_expired=False)
-    client.cloud.ice_servers = Mock(
-        async_register_ice_servers_listener=AsyncMock(return_value=""mock-unregister"")
+    prefs = MagicMock(
+        alexa_enabled=False,
+        google_enabled=False,
+        async_set_username=AsyncMock(return_value=None),
+        cloud_ice_servers_enabled=True,
+    )
+    client = CloudClient(hass, prefs, None, {}, {})
+    client.cloud = Mock(
+        is_logged_in=True,
+        subscription_expired=False,
+        ice_servers=Mock(
+            async_register_ice_servers_listener=AsyncMock(
+                return_value=""mock-unregister""
+            )
+        ),
     )
 
     await client.cloud_connected()
     assert client._cloud_ice_servers_listener == ""mock-unregister""
 
 
-async def test_handler_ice_servers_disabled(
-    hass: HomeAssistant, mock_cloud_fixture: CloudPreferences
-) -> None:
+async def test_handler_ice_servers_disabled(hass: HomeAssistant) -> None:
     """"""Test handler ICE servers when user has disabled it.""""""
-    mock_cloud_fixture._prefs[PREF_ENABLE_ALEXA] = False
-    mock_cloud_fixture._prefs[PREF_ENABLE_GOOGLE] = False
-    mock_cloud_fixture.async_set_username = AsyncMock(return_value=None)
-    mock_cloud_fixture._prefs[PREF_ENABLE_CLOUD_ICE_SERVERS] = False
-
-    client = CloudClient(hass, mock_cloud_fixture, None, {}, {})
-    client.cloud = Mock(is_logged_in=True, subscription_expired=False)
-    client.cloud.ice_servers = Mock(
-        async_register_ice_servers_listener=AsyncMock(return_value=""mock-unregister"")
+    prefs = MagicMock(
+        alexa_enabled=False,
+        google_enabled=False,
+        async_set_username=AsyncMock(return_value=None),
+        cloud_ice_servers_enabled=False,
+    )
+    client = CloudClient(hass, prefs, None, {}, {})
+    client.cloud = Mock(

(from reviewer) [2024-10-25T20:15:19Z] The mock cloud will be set on the client by the integration when it's setup.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -184,38 +183,46 @@ async def test_handler_google_actions_disabled(
     assert resp[""payload""] == response_payload
 
 
-async def test_handler_ice_servers(
-    hass: HomeAssistant, mock_cloud_fixture: CloudPreferences
-) -> None:
+async def test_handler_ice_servers(hass: HomeAssistant) -> None:
     """"""Test handler ICE servers.""""""
-    mock_cloud_fixture._prefs[PREF_ENABLE_ALEXA] = False
-    mock_cloud_fixture._prefs[PREF_ENABLE_GOOGLE] = False
-    mock_cloud_fixture.async_set_username = AsyncMock(return_value=None)
-    mock_cloud_fixture._prefs[PREF_ENABLE_CLOUD_ICE_SERVERS] = True
-
-    client = CloudClient(hass, mock_cloud_fixture, None, {}, {})
-    client.cloud = Mock(is_logged_in=True, subscription_expired=False)
-    client.cloud.ice_servers = Mock(
-        async_register_ice_servers_listener=AsyncMock(return_value=""mock-unregister"")
+    prefs = MagicMock(
+        alexa_enabled=False,
+        google_enabled=False,
+        async_set_username=AsyncMock(return_value=None),
+        cloud_ice_servers_enabled=True,
+    )
+    client = CloudClient(hass, prefs, None, {}, {})
+    client.cloud = Mock(
+        is_logged_in=True,
+        subscription_expired=False,
+        ice_servers=Mock(
+            async_register_ice_servers_listener=AsyncMock(
+                return_value=""mock-unregister""
+            )
+        ),
     )
 
     await client.cloud_connected()
     assert client._cloud_ice_servers_listener == ""mock-unregister""
 
 
-async def test_handler_ice_servers_disabled(
-    hass: HomeAssistant, mock_cloud_fixture: CloudPreferences
-) -> None:
+async def test_handler_ice_servers_disabled(hass: HomeAssistant) -> None:
     """"""Test handler ICE servers when user has disabled it.""""""
-    mock_cloud_fixture._prefs[PREF_ENABLE_ALEXA] = False
-    mock_cloud_fixture._prefs[PREF_ENABLE_GOOGLE] = False
-    mock_cloud_fixture.async_set_username = AsyncMock(return_value=None)
-    mock_cloud_fixture._prefs[PREF_ENABLE_CLOUD_ICE_SERVERS] = False
-
-    client = CloudClient(hass, mock_cloud_fixture, None, {}, {})
-    client.cloud = Mock(is_logged_in=True, subscription_expired=False)
-    client.cloud.ice_servers = Mock(
-        async_register_ice_servers_listener=AsyncMock(return_value=""mock-unregister"")
+    prefs = MagicMock(
+        alexa_enabled=False,
+        google_enabled=False,
+        async_set_username=AsyncMock(return_value=None),
+        cloud_ice_servers_enabled=False,
+    )
+    client = CloudClient(hass, prefs, None, {}, {})
+    client.cloud = Mock(
+        is_logged_in=True,
+        subscription_expired=False,
+        ice_servers=Mock(

(from reviewer) [2024-10-25T20:16:15Z] Add the `ice_servers` mock to the cloud fixture mock in `conftest.py`.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -184,38 +183,46 @@ async def test_handler_google_actions_disabled(
     assert resp[""payload""] == response_payload
 
 
-async def test_handler_ice_servers(
-    hass: HomeAssistant, mock_cloud_fixture: CloudPreferences
-) -> None:
+async def test_handler_ice_servers(hass: HomeAssistant) -> None:
     """"""Test handler ICE servers.""""""
-    mock_cloud_fixture._prefs[PREF_ENABLE_ALEXA] = False
-    mock_cloud_fixture._prefs[PREF_ENABLE_GOOGLE] = False
-    mock_cloud_fixture.async_set_username = AsyncMock(return_value=None)
-    mock_cloud_fixture._prefs[PREF_ENABLE_CLOUD_ICE_SERVERS] = True
-
-    client = CloudClient(hass, mock_cloud_fixture, None, {}, {})
-    client.cloud = Mock(is_logged_in=True, subscription_expired=False)
-    client.cloud.ice_servers = Mock(
-        async_register_ice_servers_listener=AsyncMock(return_value=""mock-unregister"")
+    prefs = MagicMock(
+        alexa_enabled=False,
+        google_enabled=False,
+        async_set_username=AsyncMock(return_value=None),
+        cloud_ice_servers_enabled=True,
+    )
+    client = CloudClient(hass, prefs, None, {}, {})
+    client.cloud = Mock(
+        is_logged_in=True,
+        subscription_expired=False,
+        ice_servers=Mock(
+            async_register_ice_servers_listener=AsyncMock(
+                return_value=""mock-unregister""
+            )
+        ),
     )
 
     await client.cloud_connected()
     assert client._cloud_ice_servers_listener == ""mock-unregister""
 
 
-async def test_handler_ice_servers_disabled(
-    hass: HomeAssistant, mock_cloud_fixture: CloudPreferences
-) -> None:
+async def test_handler_ice_servers_disabled(hass: HomeAssistant) -> None:

(from reviewer) [2024-10-25T20:17:43Z] ```suggestion
async def test_handler_ice_servers_disabled(hass: Homeassistant, cloud: MagicMock) -> None:
```

If we need to set preferences we can use the `set_cloud_prefs` fixture. See other tests that use these fixtures for examples.
(from author) [2024-10-28T14:39:37Z] I couldn't use `set_cloud_prefs` as I wanted because it did not get executed in the proper order, so I modified the test flow a bit and also defined Alexa and Google configs as they were needed because I could not set prefs before initialization.
---END THREAD---

(from reviewer) [2024-10-28T16:59:45Z] Your force push overwrote my commit.

(from author) [2024-10-28T17:01:06Z] > Your force push overwrote my commit.

Sorry, I did not notice it 😬 

---BEGIN THREAD---
Diff Hunk:
@@ -65,7 +65,7 @@ uv==0.4.22
 voluptuous-openapi==0.0.5
 voluptuous-serialize==2.6.0
 voluptuous==0.15.2
-webrtc-models==0.0.0b2
+webrtc-models==0.1.0

(from reviewer) [2024-10-28T17:07:02Z] This should be a separate PR.
(from author) [2024-10-28T17:09:03Z] Yep, it's for testing now. I was hoping someone will do it before me; if not, I will do it myself. I will also create a separate PR for `hass-nabucasa`.
---END THREAD---",
128930,Allow update entities to report progress as a float,2024-10-21 18:20:21+00:00,2024-10-25 20:02:04+00:00,merged,16,1,3,https://github.com/home-assistant/core/pull/128930,New feature (which adds functionality to an existing integration),127,2024-10-24T19:20:19Z,update,emontnemery,"---BEGIN THREAD---
Diff Hunk:
@@ -258,6 +263,15 @@ def device_class(self) -> UpdateDeviceClass | None:
             return self.entity_description.device_class
         return None
 
+    @cached_property
+    def display_precision(self) -> int:
+        """"""Return number of decimal digits for display of update progress.""""""
+        if hasattr(self, ""_attr_display_precision""):
+            return self._attr_display_precision

(from reviewer) [2024-10-24T09:39:17Z] Can we cover this line too?
---END THREAD---",
128928,Allow Random title to be translated,2024-10-21 18:11:49+00:00,2024-10-22 19:02:00+00:00,merged,2,0,0,https://github.com/home-assistant/core/pull/128928,New feature (which adds functionality to an existing integration),3,2024-10-21T18:19:44Z,random,gjohansson-ST,,
128927,Allow Timer title to be translated,2024-10-21 18:09:11+00:00,2024-10-22 19:01:54+00:00,merged,2,0,0,https://github.com/home-assistant/core/pull/128927,New feature (which adds functionality to an existing integration),3,2024-10-21T18:42:19Z,timer,gjohansson-ST,,
128926,Allow Trend title to be translated,2024-10-21 18:07:14+00:00,2024-10-22 19:02:02+00:00,merged,2,0,0,https://github.com/home-assistant/core/pull/128926,New feature (which adds functionality to an existing integration),3,2024-10-21T18:10:59Z,trend,gjohansson-ST,,
128923,Add diagnostics to Vodafone Station,2024-10-21 17:38:04+00:00,2024-10-25 18:22:54+00:00,merged,4,0,0,https://github.com/home-assistant/core/pull/128923,New feature (which adds functionality to an existing integration),238,2024-10-21T17:47:13Z,vodafone_station,chemelli74,,
128919,Add musicassistant integration,2024-10-21 17:03:11+00:00,2024-10-31 18:02:28+00:00,merged,19,167,8,https://github.com/home-assistant/core/pull/128919,New integration (thank you!),1319,2024-10-30T13:57:01Z,music_assistant,jozefKruszynski,"---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,22 @@
+""""""Constants for Music Assistant Component.""""""
+
+import logging
+
+DOMAIN = ""mass""

(from reviewer) [2024-10-21T17:16:36Z] let's make the domain `music_assistant`
(from reviewer) [2024-10-21T17:22:48Z] Hah, I already discussed this with both Marcel and Jozef :P
(from author) [2024-10-21T17:25:56Z] Working on it as we speak

---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,58 @@
+{
+  ""issues"": {
+    ""invalid_server_version"": {
+      ""title"": ""The Music Assistant server is not the correct version"",
+      ""description"": ""Check if there are updates available for the Music Assistant Server and/or integration.""
+    }
+  },
+  ""config"": {
+    ""flow_title"": ""{name}"",

(from reviewer) [2024-10-21T17:17:06Z] Not needed, it's just the name in the manifest.
```suggestion
```
(from author) [2024-10-21T19:11:58Z] removed in latest commit
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,164 @@
+""""""Music Assistant (music-assistant.io) integration.""""""
+
+from __future__ import annotations
+
+import asyncio
+from typing import TYPE_CHECKING
+
+from music_assistant.client import MusicAssistantClient
+from music_assistant.client.exceptions import CannotConnect, InvalidServerVersion
+from music_assistant.common.models.enums import EventType
+from music_assistant.common.models.errors import MusicAssistantError
+
+from homeassistant.config_entries import ConfigEntry, ConfigEntryState
+from homeassistant.const import CONF_URL, EVENT_HOMEASSISTANT_STOP
+from homeassistant.core import Event, HomeAssistant
+from homeassistant.exceptions import ConfigEntryNotReady
+from homeassistant.helpers import device_registry as dr
+from homeassistant.helpers.aiohttp_client import async_get_clientsession
+from homeassistant.helpers.issue_registry import (
+    IssueSeverity,
+    async_create_issue,
+    async_delete_issue,
+)
+
+from .const import DOMAIN, LOGGER
+from .helpers import MassEntryData
+
+if TYPE_CHECKING:
+    from music_assistant.common.models.event import MassEvent
+
+PLATFORMS = (""media_player"",)

(from reviewer) [2024-10-21T19:12:27Z] ```suggestion
PLATFORMS = [Platform.MEDIA_PLAYER]
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,164 @@
+""""""Music Assistant (music-assistant.io) integration.""""""
+
+from __future__ import annotations
+
+import asyncio
+from typing import TYPE_CHECKING
+
+from music_assistant.client import MusicAssistantClient
+from music_assistant.client.exceptions import CannotConnect, InvalidServerVersion
+from music_assistant.common.models.enums import EventType
+from music_assistant.common.models.errors import MusicAssistantError
+
+from homeassistant.config_entries import ConfigEntry, ConfigEntryState
+from homeassistant.const import CONF_URL, EVENT_HOMEASSISTANT_STOP
+from homeassistant.core import Event, HomeAssistant
+from homeassistant.exceptions import ConfigEntryNotReady
+from homeassistant.helpers import device_registry as dr
+from homeassistant.helpers.aiohttp_client import async_get_clientsession
+from homeassistant.helpers.issue_registry import (
+    IssueSeverity,
+    async_create_issue,
+    async_delete_issue,
+)
+
+from .const import DOMAIN, LOGGER
+from .helpers import MassEntryData
+
+if TYPE_CHECKING:
+    from music_assistant.common.models.event import MassEvent
+
+PLATFORMS = (""media_player"",)
+
+CONNECT_TIMEOUT = 10
+LISTEN_READY_TIMEOUT = 30
+
+
+async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
+    """"""Set up from a config entry.""""""
+    # ruff: noqa: PLR0915

(from reviewer) [2024-10-21T19:12:32Z] ```suggestion
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,164 @@
+""""""Music Assistant (music-assistant.io) integration.""""""
+
+from __future__ import annotations
+
+import asyncio
+from typing import TYPE_CHECKING
+
+from music_assistant.client import MusicAssistantClient
+from music_assistant.client.exceptions import CannotConnect, InvalidServerVersion
+from music_assistant.common.models.enums import EventType
+from music_assistant.common.models.errors import MusicAssistantError
+
+from homeassistant.config_entries import ConfigEntry, ConfigEntryState
+from homeassistant.const import CONF_URL, EVENT_HOMEASSISTANT_STOP
+from homeassistant.core import Event, HomeAssistant
+from homeassistant.exceptions import ConfigEntryNotReady
+from homeassistant.helpers import device_registry as dr
+from homeassistant.helpers.aiohttp_client import async_get_clientsession
+from homeassistant.helpers.issue_registry import (
+    IssueSeverity,
+    async_create_issue,
+    async_delete_issue,
+)
+
+from .const import DOMAIN, LOGGER
+from .helpers import MassEntryData
+
+if TYPE_CHECKING:
+    from music_assistant.common.models.event import MassEvent
+
+PLATFORMS = (""media_player"",)
+
+CONNECT_TIMEOUT = 10
+LISTEN_READY_TIMEOUT = 30
+
+
+async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
+    """"""Set up from a config entry.""""""
+    # ruff: noqa: PLR0915
+    http_session = async_get_clientsession(hass, verify_ssl=False)
+    mass_url = entry.data[CONF_URL]
+    mass = MusicAssistantClient(mass_url, http_session)
+
+    try:
+        async with asyncio.timeout(CONNECT_TIMEOUT):
+            await mass.connect()
+    except (TimeoutError, CannotConnect) as err:
+        raise ConfigEntryNotReady(
+            f""Failed to connect to music assistant server {mass_url}""
+        ) from err
+    except InvalidServerVersion as err:
+        async_create_issue(
+            hass,
+            DOMAIN,
+            ""invalid_server_version"",
+            is_fixable=False,
+            severity=IssueSeverity.ERROR,
+            translation_key=""invalid_server_version"",
+        )
+        raise ConfigEntryNotReady(f""Invalid server version: {err}"") from err
+    except Exception as err:
+        LOGGER.exception(""Failed to connect to music assistant server"", exc_info=err)
+        raise ConfigEntryNotReady(
+            f""Unknown error connecting to the Music Assistant server {mass_url}""
+        ) from err

(from reviewer) [2024-10-21T19:12:58Z] We only allow catching bare exceptions in the config flow, we should be more specific here
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,164 @@
+""""""Music Assistant (music-assistant.io) integration.""""""
+
+from __future__ import annotations
+
+import asyncio
+from typing import TYPE_CHECKING
+
+from music_assistant.client import MusicAssistantClient
+from music_assistant.client.exceptions import CannotConnect, InvalidServerVersion
+from music_assistant.common.models.enums import EventType
+from music_assistant.common.models.errors import MusicAssistantError
+
+from homeassistant.config_entries import ConfigEntry, ConfigEntryState
+from homeassistant.const import CONF_URL, EVENT_HOMEASSISTANT_STOP
+from homeassistant.core import Event, HomeAssistant
+from homeassistant.exceptions import ConfigEntryNotReady
+from homeassistant.helpers import device_registry as dr
+from homeassistant.helpers.aiohttp_client import async_get_clientsession
+from homeassistant.helpers.issue_registry import (
+    IssueSeverity,
+    async_create_issue,
+    async_delete_issue,
+)
+
+from .const import DOMAIN, LOGGER
+from .helpers import MassEntryData
+
+if TYPE_CHECKING:
+    from music_assistant.common.models.event import MassEvent
+
+PLATFORMS = (""media_player"",)
+
+CONNECT_TIMEOUT = 10
+LISTEN_READY_TIMEOUT = 30
+
+
+async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
+    """"""Set up from a config entry.""""""
+    # ruff: noqa: PLR0915
+    http_session = async_get_clientsession(hass, verify_ssl=False)
+    mass_url = entry.data[CONF_URL]
+    mass = MusicAssistantClient(mass_url, http_session)
+
+    try:
+        async with asyncio.timeout(CONNECT_TIMEOUT):
+            await mass.connect()
+    except (TimeoutError, CannotConnect) as err:
+        raise ConfigEntryNotReady(
+            f""Failed to connect to music assistant server {mass_url}""
+        ) from err
+    except InvalidServerVersion as err:
+        async_create_issue(
+            hass,
+            DOMAIN,
+            ""invalid_server_version"",
+            is_fixable=False,
+            severity=IssueSeverity.ERROR,
+            translation_key=""invalid_server_version"",
+        )
+        raise ConfigEntryNotReady(f""Invalid server version: {err}"") from err
+    except Exception as err:
+        LOGGER.exception(""Failed to connect to music assistant server"", exc_info=err)
+        raise ConfigEntryNotReady(
+            f""Unknown error connecting to the Music Assistant server {mass_url}""
+        ) from err
+
+    async_delete_issue(hass, DOMAIN, ""invalid_server_version"")
+
+    async def on_hass_stop(event: Event) -> None:
+        """"""Handle incoming stop event from Home Assistant.""""""
+        await mass.disconnect()
+
+    entry.async_on_unload(
+        hass.bus.async_listen_once(EVENT_HOMEASSISTANT_STOP, on_hass_stop)
+    )
+
+    # launch the music assistant client listen task in the background
+    # use the init_ready event to wait until initialization is done
+    init_ready = asyncio.Event()
+    listen_task = asyncio.create_task(_client_listen(hass, entry, mass, init_ready))
+
+    try:
+        async with asyncio.timeout(LISTEN_READY_TIMEOUT):
+            await init_ready.wait()
+    except TimeoutError as err:
+        listen_task.cancel()
+        raise ConfigEntryNotReady(""Music Assistant client not ready"") from err
+
+    if DOMAIN not in hass.data:
+        hass.data[DOMAIN] = {}

(from reviewer) [2024-10-21T19:13:19Z] Please use entry.runtime_data to store runtimedata
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,164 @@
+""""""Music Assistant (music-assistant.io) integration.""""""
+
+from __future__ import annotations
+
+import asyncio
+from typing import TYPE_CHECKING
+
+from music_assistant.client import MusicAssistantClient
+from music_assistant.client.exceptions import CannotConnect, InvalidServerVersion
+from music_assistant.common.models.enums import EventType
+from music_assistant.common.models.errors import MusicAssistantError
+
+from homeassistant.config_entries import ConfigEntry, ConfigEntryState
+from homeassistant.const import CONF_URL, EVENT_HOMEASSISTANT_STOP
+from homeassistant.core import Event, HomeAssistant
+from homeassistant.exceptions import ConfigEntryNotReady
+from homeassistant.helpers import device_registry as dr
+from homeassistant.helpers.aiohttp_client import async_get_clientsession
+from homeassistant.helpers.issue_registry import (
+    IssueSeverity,
+    async_create_issue,
+    async_delete_issue,
+)
+
+from .const import DOMAIN, LOGGER
+from .helpers import MassEntryData
+
+if TYPE_CHECKING:
+    from music_assistant.common.models.event import MassEvent
+
+PLATFORMS = (""media_player"",)
+
+CONNECT_TIMEOUT = 10
+LISTEN_READY_TIMEOUT = 30
+
+
+async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
+    """"""Set up from a config entry.""""""
+    # ruff: noqa: PLR0915
+    http_session = async_get_clientsession(hass, verify_ssl=False)
+    mass_url = entry.data[CONF_URL]
+    mass = MusicAssistantClient(mass_url, http_session)
+
+    try:
+        async with asyncio.timeout(CONNECT_TIMEOUT):
+            await mass.connect()
+    except (TimeoutError, CannotConnect) as err:
+        raise ConfigEntryNotReady(
+            f""Failed to connect to music assistant server {mass_url}""
+        ) from err
+    except InvalidServerVersion as err:
+        async_create_issue(
+            hass,
+            DOMAIN,
+            ""invalid_server_version"",
+            is_fixable=False,
+            severity=IssueSeverity.ERROR,
+            translation_key=""invalid_server_version"",
+        )
+        raise ConfigEntryNotReady(f""Invalid server version: {err}"") from err
+    except Exception as err:
+        LOGGER.exception(""Failed to connect to music assistant server"", exc_info=err)
+        raise ConfigEntryNotReady(
+            f""Unknown error connecting to the Music Assistant server {mass_url}""
+        ) from err
+
+    async_delete_issue(hass, DOMAIN, ""invalid_server_version"")
+
+    async def on_hass_stop(event: Event) -> None:
+        """"""Handle incoming stop event from Home Assistant.""""""
+        await mass.disconnect()
+
+    entry.async_on_unload(
+        hass.bus.async_listen_once(EVENT_HOMEASSISTANT_STOP, on_hass_stop)
+    )
+
+    # launch the music assistant client listen task in the background
+    # use the init_ready event to wait until initialization is done
+    init_ready = asyncio.Event()
+    listen_task = asyncio.create_task(_client_listen(hass, entry, mass, init_ready))
+
+    try:
+        async with asyncio.timeout(LISTEN_READY_TIMEOUT):
+            await init_ready.wait()
+    except TimeoutError as err:
+        listen_task.cancel()
+        raise ConfigEntryNotReady(""Music Assistant client not ready"") from err
+
+    if DOMAIN not in hass.data:
+        hass.data[DOMAIN] = {}
+
+    hass.data[DOMAIN][entry.entry_id] = MassEntryData(mass, listen_task)
+
+    # initialize platforms
+    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)
+
+    # If the listen task is already failed, we need to raise ConfigEntryNotReady
+    if listen_task.done() and (listen_error := listen_task.exception()) is not None:
+        await hass.config_entries.async_unload_platforms(entry, PLATFORMS)
+        hass.data[DOMAIN].pop(entry.entry_id)
+        try:
+            await mass.disconnect()
+        finally:
+            raise ConfigEntryNotReady(listen_error) from listen_error

(from reviewer) [2024-10-21T19:13:50Z] Why don't we do this before forwarding the setups?
(from author) [2024-10-21T19:39:42Z] ~~You mean move the entry.runtime_data call from above to after this block?~~
Scratch that, I see what you mean

---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,164 @@
+""""""Music Assistant (music-assistant.io) integration.""""""
+
+from __future__ import annotations
+
+import asyncio
+from typing import TYPE_CHECKING
+
+from music_assistant.client import MusicAssistantClient
+from music_assistant.client.exceptions import CannotConnect, InvalidServerVersion
+from music_assistant.common.models.enums import EventType
+from music_assistant.common.models.errors import MusicAssistantError
+
+from homeassistant.config_entries import ConfigEntry, ConfigEntryState
+from homeassistant.const import CONF_URL, EVENT_HOMEASSISTANT_STOP
+from homeassistant.core import Event, HomeAssistant
+from homeassistant.exceptions import ConfigEntryNotReady
+from homeassistant.helpers import device_registry as dr
+from homeassistant.helpers.aiohttp_client import async_get_clientsession
+from homeassistant.helpers.issue_registry import (
+    IssueSeverity,
+    async_create_issue,
+    async_delete_issue,
+)
+
+from .const import DOMAIN, LOGGER
+from .helpers import MassEntryData
+
+if TYPE_CHECKING:
+    from music_assistant.common.models.event import MassEvent
+
+PLATFORMS = (""media_player"",)
+
+CONNECT_TIMEOUT = 10
+LISTEN_READY_TIMEOUT = 30
+
+
+async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
+    """"""Set up from a config entry.""""""
+    # ruff: noqa: PLR0915
+    http_session = async_get_clientsession(hass, verify_ssl=False)
+    mass_url = entry.data[CONF_URL]
+    mass = MusicAssistantClient(mass_url, http_session)
+
+    try:
+        async with asyncio.timeout(CONNECT_TIMEOUT):
+            await mass.connect()
+    except (TimeoutError, CannotConnect) as err:
+        raise ConfigEntryNotReady(
+            f""Failed to connect to music assistant server {mass_url}""
+        ) from err
+    except InvalidServerVersion as err:
+        async_create_issue(
+            hass,
+            DOMAIN,
+            ""invalid_server_version"",
+            is_fixable=False,
+            severity=IssueSeverity.ERROR,
+            translation_key=""invalid_server_version"",
+        )
+        raise ConfigEntryNotReady(f""Invalid server version: {err}"") from err
+    except Exception as err:
+        LOGGER.exception(""Failed to connect to music assistant server"", exc_info=err)
+        raise ConfigEntryNotReady(
+            f""Unknown error connecting to the Music Assistant server {mass_url}""
+        ) from err
+
+    async_delete_issue(hass, DOMAIN, ""invalid_server_version"")
+
+    async def on_hass_stop(event: Event) -> None:
+        """"""Handle incoming stop event from Home Assistant.""""""
+        await mass.disconnect()
+
+    entry.async_on_unload(
+        hass.bus.async_listen_once(EVENT_HOMEASSISTANT_STOP, on_hass_stop)
+    )
+
+    # launch the music assistant client listen task in the background
+    # use the init_ready event to wait until initialization is done
+    init_ready = asyncio.Event()
+    listen_task = asyncio.create_task(_client_listen(hass, entry, mass, init_ready))
+
+    try:
+        async with asyncio.timeout(LISTEN_READY_TIMEOUT):
+            await init_ready.wait()
+    except TimeoutError as err:
+        listen_task.cancel()
+        raise ConfigEntryNotReady(""Music Assistant client not ready"") from err
+
+    if DOMAIN not in hass.data:
+        hass.data[DOMAIN] = {}
+
+    hass.data[DOMAIN][entry.entry_id] = MassEntryData(mass, listen_task)
+
+    # initialize platforms
+    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)
+
+    # If the listen task is already failed, we need to raise ConfigEntryNotReady
+    if listen_task.done() and (listen_error := listen_task.exception()) is not None:
+        await hass.config_entries.async_unload_platforms(entry, PLATFORMS)
+        hass.data[DOMAIN].pop(entry.entry_id)
+        try:
+            await mass.disconnect()
+        finally:
+            raise ConfigEntryNotReady(listen_error) from listen_error
+
+    # register listener for removed players
+    async def handle_player_removed(event: MassEvent) -> None:
+        """"""Handle Mass Player Removed event.""""""
+        dev_reg = dr.async_get(hass)
+        if TYPE_CHECKING:
+            assert event.object_id is not None
+        if hass_device := dev_reg.async_get_device({(DOMAIN, event.object_id)}):
+            dev_reg.async_remove_device(hass_device.id)
+
+    entry.async_on_unload(
+        mass.subscribe(handle_player_removed, EventType.PLAYER_REMOVED)
+    )
+
+    return True
+
+
+async def _client_listen(
+    hass: HomeAssistant,
+    entry: ConfigEntry,
+    mass: MusicAssistantClient,
+    init_ready: asyncio.Event,
+) -> None:
+    """"""Listen with the client.""""""
+    try:
+        await mass.start_listening(init_ready)
+    except MusicAssistantError as err:
+        if entry.state != ConfigEntryState.LOADED:
+            raise
+        LOGGER.error(""Failed to listen: %s"", err)
+    except Exception as err:  # pylint: disable=broad-except
+        # We need to guard against unknown exceptions to not crash this task.
+        LOGGER.exception(""Unexpected exception: %s"", err)
+        if entry.state != ConfigEntryState.LOADED:
+            raise
+
+    if not hass.is_stopping:
+        LOGGER.debug(""Disconnected from server. Reloading integration"")
+        hass.async_create_task(hass.config_entries.async_reload(entry.entry_id))
+
+
+async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
+    """"""Unload a config entry.""""""
+    unload_ok = await hass.config_entries.async_unload_platforms(entry, PLATFORMS)
+
+    if unload_ok:
+        mass_entry_data: MassEntryData = hass.data[DOMAIN].pop(entry.entry_id)
+        mass_entry_data.listen_task.cancel()
+        await mass_entry_data.mass.disconnect()
+
+    return unload_ok
+
+
+async def async_remove_config_entry_device(
+    hass: HomeAssistant,
+    config_entry: ConfigEntry,
+    device_entry: dr.DeviceEntry,
+) -> bool:
+    """"""Remove a config entry from a device.""""""
+    return True

(from reviewer) [2024-10-21T19:14:24Z] Let's not do this yet
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,193 @@
+""""""Config flow for MusicAssistant integration.""""""
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Any
+
+from music_assistant.client import MusicAssistantClient
+from music_assistant.client.exceptions import (
+    CannotConnect,
+    InvalidServerVersion,
+    MusicAssistantClientException,
+)
+from music_assistant.common.models.api import ServerInfoMessage
+import voluptuous as vol
+
+from homeassistant import config_entries
+from homeassistant.components import zeroconf
+from homeassistant.config_entries import ConfigFlowResult
+from homeassistant.const import CONF_URL
+from homeassistant.core import HomeAssistant
+from homeassistant.data_entry_flow import AbortFlow
+from homeassistant.exceptions import HomeAssistantError
+from homeassistant.helpers import aiohttp_client
+
+from .const import DOMAIN, LOGGER
+
+DEFAULT_URL = ""http://mass.local:8095""
+DEFAULT_TITLE = ""Music Assistant""
+
+
+def get_manual_schema(user_input: dict[str, Any]) -> vol.Schema:
+    """"""Return a schema for the manual step.""""""
+    default_url = user_input.get(CONF_URL, DEFAULT_URL)
+    return vol.Schema(
+        {
+            vol.Required(CONF_URL, default=default_url): str,
+        }
+    )
+
+
+async def get_server_info(hass: HomeAssistant, url: str) -> ServerInfoMessage:
+    """"""Validate the user input allows us to connect.""""""
+    async with MusicAssistantClient(
+        url, aiohttp_client.async_get_clientsession(hass)
+    ) as client:
+        if TYPE_CHECKING:
+            assert client.server_info is not None
+        return client.server_info
+
+
+# ruff: noqa: ARG002
+
+
+class ConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
+    """"""Handle a config flow for MusicAssistant.""""""
+
+    VERSION = 1
+
+    def __init__(self) -> None:
+        """"""Set up flow instance.""""""
+        self.server_info: ServerInfoMessage | None = None
+
+    async def async_step_user(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""Handle the initial step.""""""
+        return await self.async_step_manual()
+
+    async def async_step_manual(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""Handle a manual configuration.""""""
+        if user_input is None:
+            return self.async_show_form(  # type: ignore[no-any-return]
+                step_id=""manual"", data_schema=get_manual_schema({})
+            )
+
+        errors = {}
+        try:
+            self.server_info = await get_server_info(self.hass, user_input[CONF_URL])
+            await self.async_set_unique_id(self.server_info.server_id)
+        except CannotConnect:
+            errors[""base""] = ""cannot_connect""
+        except InvalidServerVersion:
+            errors[""base""] = ""invalid_server_version""
+        except MusicAssistantClientException:  # pylint: disable=broad-except
+            LOGGER.exception(""Unexpected exception"")
+            errors[""base""] = ""unknown""
+        else:
+            return await self._async_create_entry_or_abort()
+
+        return self.async_show_form(  # type: ignore[no-any-return]
+            step_id=""manual"", data_schema=get_manual_schema(user_input), errors=errors
+        )
+
+    async def async_step_zeroconf(
+        self, discovery_info: zeroconf.ZeroconfServiceInfo
+    ) -> ConfigFlowResult:
+        """"""Handle a discovered Mass server.
+
+        This flow is triggered by the Zeroconf component. It will check if the
+        host is already configured and delegate to the import step if not.
+        """"""
+        # abort if discovery info is not what we expect
+        if ""server_id"" not in discovery_info.properties:
+            return self.async_abort(reason=""missing_server_id"")  # type: ignore[no-any-return]
+        # abort if we already have exactly this server_id
+        # reload the integration if the host got updated
+        server_id = discovery_info.properties[""server_id""]
+        base_url = discovery_info.properties[""base_url""]
+        await self.async_set_unique_id(server_id)
+        self._abort_if_unique_id_configured(
+            updates={CONF_URL: base_url},
+            reload_on_update=True,
+        )
+        self.server_info = ServerInfoMessage.from_dict(discovery_info.properties)
+        return await self.async_step_discovery_confirm()
+
+    async def async_step_discovery_confirm(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""Handle user-confirmation of discovered server.""""""
+        if TYPE_CHECKING:
+            assert self.server_info is not None
+        if user_input is not None:
+            # Check that we can connect to the address.
+            try:
+                await get_server_info(self.hass, self.server_info.base_url)
+            except CannotConnect:
+                return self.async_abort(reason=""cannot_connect"")  # type: ignore[no-any-return]
+            return await self._async_create_entry_or_abort()
+        return self.async_show_form(  # type: ignore[no-any-return]
+            step_id=""discovery_confirm"",
+            description_placeholders={""url"": self.server_info.base_url},
+        )
+
+    async def _async_create_entry_or_abort(self) -> ConfigFlowResult:
+        """"""Return a config entry for the flow or abort if already configured.""""""
+        assert self.server_info is not None
+
+        for config_entry in self._async_current_entries():
+            if config_entry.unique_id != self.server_info.server_id:
+                continue
+            self.hass.config_entries.async_update_entry(
+                config_entry,
+                data={
+                    **config_entry.data,
+                    CONF_URL: self.server_info.base_url,
+                },
+                title=DEFAULT_TITLE,
+            )
+            await self.hass.config_entries.async_reload(config_entry.entry_id)
+            raise AbortFlow(""reconfiguration_successful"")
+
+        # Abort any other flows that may be in progress
+        for progress in self._async_in_progress():
+            self.hass.config_entries.flow.async_abort(progress[""flow_id""])
+
+        return self.async_create_entry(  # type: ignore[no-any-return]
+            title=DEFAULT_TITLE,
+            data={
+                CONF_URL: self.server_info.base_url,
+            },
+        )
+
+    async def async_step_reconfigure(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""Handle reconfiguration of an existing entry.""""""
+        reconfigure_entry = self._get_reconfigure_entry()
+        if user_input is not None:
+            return self.async_update_reload_and_abort(  # type: ignore[no-any-return]
+                reconfigure_entry,
+                data={
+                    CONF_URL: user_input[CONF_URL],
+                },
+            )
+
+        return self.async_show_form(  # type: ignore[no-any-return]
+            step_id=""reconfigure"",
+            data_schema=vol.Schema(
+                {
+                    vol.Required(
+                        CONF_URL,
+                        default=reconfigure_entry.data.get(CONF_URL),
+                    ): str,
+                }
+            ),
+        )

(from reviewer) [2024-10-21T19:14:51Z] Let's move reconfigure for a followup
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,168 @@
+""""""Config flow for MusicAssistant integration.""""""
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Any
+
+from music_assistant.client import MusicAssistantClient
+from music_assistant.client.exceptions import (
+    CannotConnect,
+    InvalidServerVersion,
+    MusicAssistantClientException,
+)
+from music_assistant.common.models.api import ServerInfoMessage
+import voluptuous as vol
+
+from homeassistant import config_entries
+from homeassistant.components import zeroconf
+from homeassistant.config_entries import ConfigFlowResult
+from homeassistant.const import CONF_URL
+from homeassistant.core import HomeAssistant
+from homeassistant.data_entry_flow import AbortFlow
+from homeassistant.exceptions import HomeAssistantError
+from homeassistant.helpers import aiohttp_client
+
+from .const import DOMAIN, LOGGER
+
+DEFAULT_URL = ""http://mass.local:8095""
+DEFAULT_TITLE = ""Music Assistant""
+
+
+def get_manual_schema(user_input: dict[str, Any]) -> vol.Schema:
+    """"""Return a schema for the manual step.""""""
+    default_url = user_input.get(CONF_URL, DEFAULT_URL)
+    return vol.Schema(
+        {
+            vol.Required(CONF_URL, default=default_url): str,
+        }
+    )
+
+
+async def get_server_info(hass: HomeAssistant, url: str) -> ServerInfoMessage:
+    """"""Validate the user input allows us to connect.""""""
+    async with MusicAssistantClient(
+        url, aiohttp_client.async_get_clientsession(hass)
+    ) as client:
+        if TYPE_CHECKING:
+            assert client.server_info is not None
+        return client.server_info
+
+
+# ruff: noqa: ARG002

(from reviewer) [2024-10-22T09:32:38Z] ```suggestion
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,168 @@
+""""""Config flow for MusicAssistant integration.""""""
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Any
+
+from music_assistant.client import MusicAssistantClient
+from music_assistant.client.exceptions import (
+    CannotConnect,
+    InvalidServerVersion,
+    MusicAssistantClientException,
+)
+from music_assistant.common.models.api import ServerInfoMessage
+import voluptuous as vol
+
+from homeassistant import config_entries
+from homeassistant.components import zeroconf
+from homeassistant.config_entries import ConfigFlowResult
+from homeassistant.const import CONF_URL
+from homeassistant.core import HomeAssistant
+from homeassistant.data_entry_flow import AbortFlow
+from homeassistant.exceptions import HomeAssistantError
+from homeassistant.helpers import aiohttp_client
+
+from .const import DOMAIN, LOGGER
+
+DEFAULT_URL = ""http://mass.local:8095""
+DEFAULT_TITLE = ""Music Assistant""
+
+
+def get_manual_schema(user_input: dict[str, Any]) -> vol.Schema:
+    """"""Return a schema for the manual step.""""""
+    default_url = user_input.get(CONF_URL, DEFAULT_URL)
+    return vol.Schema(
+        {
+            vol.Required(CONF_URL, default=default_url): str,
+        }
+    )
+
+
+async def get_server_info(hass: HomeAssistant, url: str) -> ServerInfoMessage:
+    """"""Validate the user input allows us to connect.""""""
+    async with MusicAssistantClient(
+        url, aiohttp_client.async_get_clientsession(hass)
+    ) as client:
+        if TYPE_CHECKING:
+            assert client.server_info is not None
+        return client.server_info
+
+
+# ruff: noqa: ARG002
+
+
+class ConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):

(from reviewer) [2024-10-22T09:32:50Z] ```suggestion
class MusicAssistantConfigFlow(ConfigFlow, domain=DOMAIN):
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,168 @@
+""""""Config flow for MusicAssistant integration.""""""
+
+from __future__ import annotations
+
+from typing import TYPE_CHECKING, Any
+
+from music_assistant.client import MusicAssistantClient
+from music_assistant.client.exceptions import (
+    CannotConnect,
+    InvalidServerVersion,
+    MusicAssistantClientException,
+)
+from music_assistant.common.models.api import ServerInfoMessage
+import voluptuous as vol
+
+from homeassistant import config_entries
+from homeassistant.components import zeroconf
+from homeassistant.config_entries import ConfigFlowResult
+from homeassistant.const import CONF_URL
+from homeassistant.core import HomeAssistant
+from homeassistant.data_entry_flow import AbortFlow
+from homeassistant.exceptions import HomeAssistantError
+from homeassistant.helpers import aiohttp_client
+
+from .const import DOMAIN, LOGGER
+
+DEFAULT_URL = ""http://mass.local:8095""
+DEFAULT_TITLE = ""Music Assistant""
+
+
+def get_manual_schema(user_input: dict[str, Any]) -> vol.Schema:
+    """"""Return a schema for the manual step.""""""
+    default_url = user_input.get(CONF_URL, DEFAULT_URL)
+    return vol.Schema(
+        {
+            vol.Required(CONF_URL, default=default_url): str,
+        }
+    )
+
+
+async def get_server_info(hass: HomeAssistant, url: str) -> ServerInfoMessage:
+    """"""Validate the user input allows us to connect.""""""
+    async with MusicAssistantClient(
+        url, aiohttp_client.async_get_clientsession(hass)
+    ) as client:
+        if TYPE_CHECKING:
+            assert client.server_info is not None
+        return client.server_info
+
+
+# ruff: noqa: ARG002
+
+
+class ConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
+    """"""Handle a config flow for MusicAssistant.""""""
+
+    VERSION = 1
",
,,,,,,,,,,,,,,,
+    def __init__(self) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Set up flow instance.""""""""""""",,,,,,,,,,,,,,,
+        self.server_info: ServerInfoMessage | None = None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_user(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle the initial step.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:33:03Z] Not sure why we have this extra step, can be combined,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,168 @@,,,,,,,,,,,,,
"+""""""""""""Config flow for MusicAssistant integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?, Any,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from music_assistant.client.exceptions import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN, LOGGER,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+DEFAULT_URL = """"http://mass.local:8095""""",,,,,,,,,,,,,,,
"+DEFAULT_TITLE = """"Music Assistant""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+def get_manual_schema(user_input: dict[str, Any]) -> vol.Schema:,,,,,,,,,,,,,,
"+    """"""""""""Return a schema for the manual step.""""""""""""",,,,,,,,,,,,,,,
+    default_url = user_input.get(CONF_URL, DEFAULT_URL),,,,,,,,,,,,,,
+    return vol.Schema(,,,,,,,,,,,,,,,
+        {,,,,,,,,,,,,,,,
+            vol.Required(CONF_URL, default=default_url): str,,,,,,,,,,,,,,
+        },,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+async def get_server_info(hass: HomeAssistant, url: str) -> ServerInfoMessage:,,,,,,,,,,,,,,
"+    """"""""""""Validate the user input allows us to connect.""""""""""""",,,,,,,,,,,,,,,
+    async with MusicAssistantClient(,,,,,,,,,,,,,,,
#NAME?, aiohttp_client.async_get_clientsession(hass),,,,,,,,,,,,,,
+    ) as client:,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+# ruff: noqa: ARG002,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class ConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):,,,,,,,,,,,,,,
"+    """"""""""""Handle a config flow for MusicAssistant.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(self) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Set up flow instance.""""""""""""",,,,,,,,,,,,,,,
+        self.server_info: ServerInfoMessage | None = None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_user(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle the initial step.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_manual(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle a manual configuration.""""""""""""",,,,,,,,,,,,,,,
+        if user_input is None:,,,,,,,,,,,,,,,
+            return self.async_show_form(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:33:15Z] ```suggestion,,,,,,,,,,,,,,,
            return self.async_show_form(,,,,,,,,,,,,,,,
```,,,,,,,,,,,,,,,
This should not be the case,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,168 @@,,,,,,,,,,,,,
"+""""""""""""Config flow for MusicAssistant integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?, Any,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from music_assistant.client.exceptions import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN, LOGGER,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+DEFAULT_URL = """"http://mass.local:8095""""",,,,,,,,,,,,,,,
"+DEFAULT_TITLE = """"Music Assistant""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+def get_manual_schema(user_input: dict[str, Any]) -> vol.Schema:,,,,,,,,,,,,,,
"+    """"""""""""Return a schema for the manual step.""""""""""""",,,,,,,,,,,,,,,
+    default_url = user_input.get(CONF_URL, DEFAULT_URL),,,,,,,,,,,,,,
+    return vol.Schema(,,,,,,,,,,,,,,,
+        {,,,,,,,,,,,,,,,
+            vol.Required(CONF_URL, default=default_url): str,,,,,,,,,,,,,,
+        },,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+async def get_server_info(hass: HomeAssistant, url: str) -> ServerInfoMessage:,,,,,,,,,,,,,,
"+    """"""""""""Validate the user input allows us to connect.""""""""""""",,,,,,,,,,,,,,,
+    async with MusicAssistantClient(,,,,,,,,,,,,,,,
#NAME?, aiohttp_client.async_get_clientsession(hass),,,,,,,,,,,,,,
+    ) as client:,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+# ruff: noqa: ARG002,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class ConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):,,,,,,,,,,,,,,
"+    """"""""""""Handle a config flow for MusicAssistant.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(self) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Set up flow instance.""""""""""""",,,,,,,,,,,,,,,
+        self.server_info: ServerInfoMessage | None = None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_user(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle the initial step.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_manual(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle a manual configuration.""""""""""""",,,,,,,,,,,,,,,
+        if user_input is None:,,,,,,,,,,,,,,,
+            return self.async_show_form(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
"+                step_id=""""manual""""", data_schema=get_manual_schema({}),,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        errors = {},,,,,,,,,,,,,,,
+        try:,,,,,,,,,,,,,,,
+            self.server_info = await get_server_info(self.hass, user_input[CONF_URL]),,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        except CannotConnect:,,,,,,,,,,,,,,,
"+            errors[""""base""""] = """"cannot_connect""""",,,,,,,,,,,,,,,
+        except InvalidServerVersion:,,,,,,,,,,,,,,,
"+            errors[""""base""""] = """"invalid_server_version""""",,,,,,,,,,,,,,,
+        except MusicAssistantClientException:  # pylint: disable=broad-except,,,,,,,,,,,,,,,
"+            LOGGER.exception(""""Unexpected exception"""")",,,,,,,,,,,,,,,
"+            errors[""""base""""] = """"unknown""""",,,,,,,,,,,,,,,
+        else:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return self.async_show_form(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
"+            step_id=""""manual""""", data_schema=get_manual_schema(user_input), errors=errors,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:33:51Z] I personally like to inverse the if statement, to make it `if user_input is not None` and then just have one call to `async_show_form`,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,168 @@,,,,,,,,,,,,,
"+""""""""""""Config flow for MusicAssistant integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?, Any,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from music_assistant.client.exceptions import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN, LOGGER,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+DEFAULT_URL = """"http://mass.local:8095""""",,,,,,,,,,,,,,,
"+DEFAULT_TITLE = """"Music Assistant""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+def get_manual_schema(user_input: dict[str, Any]) -> vol.Schema:,,,,,,,,,,,,,,
"+    """"""""""""Return a schema for the manual step.""""""""""""",,,,,,,,,,,,,,,
+    default_url = user_input.get(CONF_URL, DEFAULT_URL),,,,,,,,,,,,,,
+    return vol.Schema(,,,,,,,,,,,,,,,
+        {,,,,,,,,,,,,,,,
+            vol.Required(CONF_URL, default=default_url): str,,,,,,,,,,,,,,
+        },,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+async def get_server_info(hass: HomeAssistant, url: str) -> ServerInfoMessage:,,,,,,,,,,,,,,
"+    """"""""""""Validate the user input allows us to connect.""""""""""""",,,,,,,,,,,,,,,
+    async with MusicAssistantClient(,,,,,,,,,,,,,,,
#NAME?, aiohttp_client.async_get_clientsession(hass),,,,,,,,,,,,,,
+    ) as client:,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+# ruff: noqa: ARG002,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class ConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):,,,,,,,,,,,,,,
"+    """"""""""""Handle a config flow for MusicAssistant.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(self) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Set up flow instance.""""""""""""",,,,,,,,,,,,,,,
+        self.server_info: ServerInfoMessage | None = None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_user(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle the initial step.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_manual(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle a manual configuration.""""""""""""",,,,,,,,,,,,,,,
+        if user_input is None:,,,,,,,,,,,,,,,
+            return self.async_show_form(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
"+                step_id=""""manual""""", data_schema=get_manual_schema({}),,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        errors = {},,,,,,,,,,,,,,,
+        try:,,,,,,,,,,,,,,,
+            self.server_info = await get_server_info(self.hass, user_input[CONF_URL]),,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:34:10Z] Only have stuff in the try block that can raise,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,168 @@,,,,,,,,,,,,,
"+""""""""""""Config flow for MusicAssistant integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?, Any,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from music_assistant.client.exceptions import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN, LOGGER,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+DEFAULT_URL = """"http://mass.local:8095""""",,,,,,,,,,,,,,,
"+DEFAULT_TITLE = """"Music Assistant""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+def get_manual_schema(user_input: dict[str, Any]) -> vol.Schema:,,,,,,,,,,,,,,
"+    """"""""""""Return a schema for the manual step.""""""""""""",,,,,,,,,,,,,,,
+    default_url = user_input.get(CONF_URL, DEFAULT_URL),,,,,,,,,,,,,,
+    return vol.Schema(,,,,,,,,,,,,,,,
+        {,,,,,,,,,,,,,,,
+            vol.Required(CONF_URL, default=default_url): str,,,,,,,,,,,,,,
+        },,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+async def get_server_info(hass: HomeAssistant, url: str) -> ServerInfoMessage:,,,,,,,,,,,,,,
"+    """"""""""""Validate the user input allows us to connect.""""""""""""",,,,,,,,,,,,,,,
+    async with MusicAssistantClient(,,,,,,,,,,,,,,,
#NAME?, aiohttp_client.async_get_clientsession(hass),,,,,,,,,,,,,,
+    ) as client:,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+# ruff: noqa: ARG002,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class ConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):,,,,,,,,,,,,,,
"+    """"""""""""Handle a config flow for MusicAssistant.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(self) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Set up flow instance.""""""""""""",,,,,,,,,,,,,,,
+        self.server_info: ServerInfoMessage | None = None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_user(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle the initial step.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_manual(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle a manual configuration.""""""""""""",,,,,,,,,,,,,,,
+        if user_input is None:,,,,,,,,,,,,,,,
+            return self.async_show_form(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
"+                step_id=""""manual""""", data_schema=get_manual_schema({}),,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        errors = {},,,,,,,,,,,,,,,
+        try:,,,,,,,,,,,,,,,
+            self.server_info = await get_server_info(self.hass, user_input[CONF_URL]),,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        except CannotConnect:,,,,,,,,,,,,,,,
"+            errors[""""base""""] = """"cannot_connect""""",,,,,,,,,,,,,,,
+        except InvalidServerVersion:,,,,,,,,,,,,,,,
"+            errors[""""base""""] = """"invalid_server_version""""",,,,,,,,,,,,,,,
+        except MusicAssistantClientException:  # pylint: disable=broad-except,,,,,,,,,,,,,,,
"+            LOGGER.exception(""""Unexpected exception"""")",,,,,,,,,,,,,,,
"+            errors[""""base""""] = """"unknown""""",,,,,,,,,,,,,,,
+        else:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return self.async_show_form(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
"+            step_id=""""manual""""", data_schema=get_manual_schema(user_input), errors=errors,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_zeroconf(,,,,,,,,,,,,,,,
#NAME?, discovery_info: zeroconf.ZeroconfServiceInfo,,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle a discovered Mass server.",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"""""",,,,,,,,,,,,,,,
+        # abort if discovery info is not what we expect,,,,,,,,,,,,,,,
"+        if """"server_id"""" not in discovery_info.properties:",,,,,,,,,,,,,,,
"+            return self.async_abort(reason=""""missing_server_id"""")  # type: ignore[no-any-return]",,,,,,,,,,,,,,,
+        # abort if we already have exactly this server_id,,,,,,,,,,,,,,,
+        # reload the integration if the host got updated,,,,,,,,,,,,,,,
"+        server_id = discovery_info.properties[""""server_id""""]",,,,,,,,,,,,,,,
"+        base_url = discovery_info.properties[""""base_url""""]",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        self._abort_if_unique_id_configured(,,,,,,,,,,,,,,,
+            updates={CONF_URL: base_url},,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_discovery_confirm(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle user-confirmation of discovered server.""""""""""""",,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        if user_input is not None:,,,,,,,,,,,,,,,
+            # Check that we can connect to the address.,,,,,,,,,,,,,,,
+            try:,,,,,,,,,,,,,,,
+                await get_server_info(self.hass, self.server_info.base_url),,,,,,,,,,,,,,
+            except CannotConnect:,,,,,,,,,,,,,,,
"+                return self.async_abort(reason=""""cannot_connect"""")  # type: ignore[no-any-return]",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        return self.async_show_form(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
"+            step_id=""""discovery_confirm""""",,,,,,,,,,,,,,,
"+            description_placeholders={""""url"""": self.server_info.base_url}",,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def _async_create_entry_or_abort(self) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Return a config entry for the flow or abort if already configured.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        for config_entry in self._async_current_entries():,,,,,,,,,,,,,,,
+            if config_entry.unique_id != self.server_info.server_id:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            self.hass.config_entries.async_update_entry(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+                data={,,,,,,,,,,,,,,,
+                    **config_entry.data,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+                },,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            raise AbortFlow(""""reconfiguration_successful"""")",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        # Abort any other flows that may be in progress,,,,,,,,,,,,,,,
+        for progress in self._async_in_progress():,,,,,,,,,,,,,,,
"+            self.hass.config_entries.flow.async_abort(progress[""""flow_id""""])",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return self.async_create_entry(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            data={,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            },,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class FailedConnect(HomeAssistantError):,,,,,,,,,,,,,,,
"+    """"""""""""Failed to connect to the MusicAssistant Server.""""""""""""",,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:34:41Z] unused,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,168 @@,,,,,,,,,,,,,
"+""""""""""""Config flow for MusicAssistant integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?, Any,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from music_assistant.client.exceptions import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN, LOGGER,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+DEFAULT_URL = """"http://mass.local:8095""""",,,,,,,,,,,,,,,
"+DEFAULT_TITLE = """"Music Assistant""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+def get_manual_schema(user_input: dict[str, Any]) -> vol.Schema:,,,,,,,,,,,,,,
"+    """"""""""""Return a schema for the manual step.""""""""""""",,,,,,,,,,,,,,,
+    default_url = user_input.get(CONF_URL, DEFAULT_URL),,,,,,,,,,,,,,
+    return vol.Schema(,,,,,,,,,,,,,,,
+        {,,,,,,,,,,,,,,,
+            vol.Required(CONF_URL, default=default_url): str,,,,,,,,,,,,,,
+        },,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+async def get_server_info(hass: HomeAssistant, url: str) -> ServerInfoMessage:,,,,,,,,,,,,,,
"+    """"""""""""Validate the user input allows us to connect.""""""""""""",,,,,,,,,,,,,,,
+    async with MusicAssistantClient(,,,,,,,,,,,,,,,
#NAME?, aiohttp_client.async_get_clientsession(hass),,,,,,,,,,,,,,
+    ) as client:,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+# ruff: noqa: ARG002,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class ConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):,,,,,,,,,,,,,,
"+    """"""""""""Handle a config flow for MusicAssistant.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(self) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Set up flow instance.""""""""""""",,,,,,,,,,,,,,,
+        self.server_info: ServerInfoMessage | None = None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_user(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle the initial step.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_manual(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle a manual configuration.""""""""""""",,,,,,,,,,,,,,,
+        if user_input is None:,,,,,,,,,,,,,,,
+            return self.async_show_form(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
"+                step_id=""""manual""""", data_schema=get_manual_schema({}),,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        errors = {},,,,,,,,,,,,,,,
+        try:,,,,,,,,,,,,,,,
+            self.server_info = await get_server_info(self.hass, user_input[CONF_URL]),,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        except CannotConnect:,,,,,,,,,,,,,,,
"+            errors[""""base""""] = """"cannot_connect""""",,,,,,,,,,,,,,,
+        except InvalidServerVersion:,,,,,,,,,,,,,,,
"+            errors[""""base""""] = """"invalid_server_version""""",,,,,,,,,,,,,,,
+        except MusicAssistantClientException:  # pylint: disable=broad-except,,,,,,,,,,,,,,,
"+            LOGGER.exception(""""Unexpected exception"""")",,,,,,,,,,,,,,,
"+            errors[""""base""""] = """"unknown""""",,,,,,,,,,,,,,,
+        else:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return self.async_show_form(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
"+            step_id=""""manual""""", data_schema=get_manual_schema(user_input), errors=errors,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_zeroconf(,,,,,,,,,,,,,,,
#NAME?, discovery_info: zeroconf.ZeroconfServiceInfo,,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle a discovered Mass server.",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"""""",,,,,,,,,,,,,,,
+        # abort if discovery info is not what we expect,,,,,,,,,,,,,,,
"+        if """"server_id"""" not in discovery_info.properties:",,,,,,,,,,,,,,,
"+            return self.async_abort(reason=""""missing_server_id"""")  # type: ignore[no-any-return]",,,,,,,,,,,,,,,
+        # abort if we already have exactly this server_id,,,,,,,,,,,,,,,
+        # reload the integration if the host got updated,,,,,,,,,,,,,,,
"+        server_id = discovery_info.properties[""""server_id""""]",,,,,,,,,,,,,,,
"+        base_url = discovery_info.properties[""""base_url""""]",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        self._abort_if_unique_id_configured(,,,,,,,,,,,,,,,
+            updates={CONF_URL: base_url},,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_step_discovery_confirm(,,,,,,,,,,,,,,,
#NAME?, user_input: dict[str, Any] | None = None,,,,,,,,,,,,,
+    ) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Handle user-confirmation of discovered server.""""""""""""",,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        if user_input is not None:,,,,,,,,,,,,,,,
+            # Check that we can connect to the address.,,,,,,,,,,,,,,,
+            try:,,,,,,,,,,,,,,,
+                await get_server_info(self.hass, self.server_info.base_url),,,,,,,,,,,,,,
+            except CannotConnect:,,,,,,,,,,,,,,,
"+                return self.async_abort(reason=""""cannot_connect"""")  # type: ignore[no-any-return]",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        return self.async_show_form(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
"+            step_id=""""discovery_confirm""""",,,,,,,,,,,,,,,
"+            description_placeholders={""""url"""": self.server_info.base_url}",,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def _async_create_entry_or_abort(self) -> ConfigFlowResult:,,,,,,,,,,,,,,,
"+        """"""""""""Return a config entry for the flow or abort if already configured.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        for config_entry in self._async_current_entries():,,,,,,,,,,,,,,,
+            if config_entry.unique_id != self.server_info.server_id:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            self.hass.config_entries.async_update_entry(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+                data={,,,,,,,,,,,,,,,
+                    **config_entry.data,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+                },,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            raise AbortFlow(""""reconfiguration_successful"""")",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        # Abort any other flows that may be in progress,,,,,,,,,,,,,,,
+        for progress in self._async_in_progress():,,,,,,,,,,,,,,,
"+            self.hass.config_entries.flow.async_abort(progress[""""flow_id""""])",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return self.async_create_entry(  # type: ignore[no-any-return],,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            data={,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            },,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:35:14Z] Looks like this is also doing reconfigure? Let's split this logic back into the user and zeroconf step,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,91 @@,,,,,,,,,,,,,
"+""""""""""""Base entity model.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class MassBaseEntity(Entity):,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:35:27Z] ```suggestion,,,,,,,,,,,,,,,
class MusicAssistantEntity(Entity):,,,,,,,,,,,,,,,
```,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,91 @@,,,,,,,,,,,,,
"+""""""""""""Base entity model.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class MassBaseEntity(Entity):,,,,,,,,,,,,,,,
"+    """"""""""""Base Entity from Music Assistant Player.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(self, mass: MusicAssistantClient, player_id: str) -> None:,,,,,,,,,,,,,
"+        """"""""""""Initialize MediaPlayer entity.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:35:38Z] Can be set outside of the constructor,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,91 @@,,,,,,,,,,,,,
"+""""""""""""Base entity model.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class MassBaseEntity(Entity):,,,,,,,,,,,,,,,
"+    """"""""""""Base Entity from Music Assistant Player.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(self, mass: MusicAssistantClient, player_id: str) -> None:,,,,,,,,,,,,,
"+        """"""""""""Initialize MediaPlayer entity.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        self._attr_device_info = DeviceInfo(,,,,,,,,,,,,,,,
+            identifiers={(DOMAIN, player_id)},,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            configuration_url=f""""{mass.server_url}/#/settings/editplayer/{player_id}""""",,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_added_to_hass(self) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Register callbacks.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        self.async_on_remove(,,,,,,,,,,,,,,,
+            self.mass.subscribe(,,,,,,,,,,,,,,,
#NAME?, EventType.PLAYER_UPDATED, self.player_id,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+        self.async_on_remove(,,,,,,,,,,,,,,,
+            self.mass.subscribe(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def player(self) -> Player:,,,,,,,,,,,,,,,
"+        """"""""""""Return the Mass Player attached to this HA entity.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:36:10Z] ```suggestion,,,,,,,,,,,,,,,
    def player(self) -> Player:,,,,,,,,,,,,,,,
"        """"""""""""Return the Mass Player attached to this HA entity.""""""""""""",,,,,,,,,,,,,,,
        return self.mass.players[self.player_id],,,,,,,,,,,,,,,
```,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,91 @@,,,,,,,,,,,,,
"+""""""""""""Base entity model.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class MassBaseEntity(Entity):,,,,,,,,,,,,,,,
"+    """"""""""""Base Entity from Music Assistant Player.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(self, mass: MusicAssistantClient, player_id: str) -> None:,,,,,,,,,,,,,
"+        """"""""""""Initialize MediaPlayer entity.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        self._attr_device_info = DeviceInfo(,,,,,,,,,,,,,,,
+            identifiers={(DOMAIN, player_id)},,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            configuration_url=f""""{mass.server_url}/#/settings/editplayer/{player_id}""""",,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_added_to_hass(self) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Register callbacks.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        self.async_on_remove(,,,,,,,,,,,,,,,
+            self.mass.subscribe(,,,,,,,,,,,,,,,
#NAME?, EventType.PLAYER_UPDATED, self.player_id,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+        self.async_on_remove(,,,,,,,,,,,,,,,
+            self.mass.subscribe(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def player(self) -> Player:,,,,,,,,,,,,,,,
"+        """"""""""""Return the Mass Player attached to this HA entity.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def unique_id(self) -> str | None:,,,,,,,,,,,,,,,
"+        """"""""""""Return unique id for entity.""""""""""""",,,,,,,,,,,,,,,
"+        _base = f""""mass_{self.player_id}""""",,,,,,,,,,,,,,,
+        if hasattr(self," """"entity_description""""):",,,,,,,,,,,,,,
"+            return f""""{_base}_{self.entity_description.key}""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def available(self) -> bool:,,,,,,,,,,,,,,,
"+        """"""""""""Return availability of entity.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:36:28Z] ```suggestion,,,,,,,,,,,,,,,
        return self.player.available and self.mass.connection.connected and self.player_id in self.mass.players,,,,,,,,,,,,,,,
```,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,91 @@,,,,,,,,,,,,,
"+""""""""""""Base entity model.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class MassBaseEntity(Entity):,,,,,,,,,,,,,,,
"+    """"""""""""Base Entity from Music Assistant Player.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(self, mass: MusicAssistantClient, player_id: str) -> None:,,,,,,,,,,,,,
"+        """"""""""""Initialize MediaPlayer entity.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        self._attr_device_info = DeviceInfo(,,,,,,,,,,,,,,,
+            identifiers={(DOMAIN, player_id)},,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            configuration_url=f""""{mass.server_url}/#/settings/editplayer/{player_id}""""",,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_added_to_hass(self) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Register callbacks.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        self.async_on_remove(,,,,,,,,,,,,,,,
+            self.mass.subscribe(,,,,,,,,,,,,,,,
#NAME?, EventType.PLAYER_UPDATED, self.player_id,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+        self.async_on_remove(,,,,,,,,,,,,,,,
+            self.mass.subscribe(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def player(self) -> Player:,,,,,,,,,,,,,,,
"+        """"""""""""Return the Mass Player attached to this HA entity.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def unique_id(self) -> str | None:,,,,,,,,,,,,,,,
"+        """"""""""""Return unique id for entity.""""""""""""",,,,,,,,,,,,,,,
"+        _base = f""""mass_{self.player_id}""""",,,,,,,,,,,,,,,
+        if hasattr(self," """"entity_description""""):",,,,,,,,,,,,,,
"+            return f""""{_base}_{self.entity_description.key}""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:36:54Z] I personally always prefer to have this logic in the platforms instead,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,91 @@,,,,,,,,,,,,,
"+""""""""""""Base entity model.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import DOMAIN,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class MassBaseEntity(Entity):,,,,,,,,,,,,,,,
"+    """"""""""""Base Entity from Music Assistant Player.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(self, mass: MusicAssistantClient, player_id: str) -> None:,,,,,,,,,,,,,
"+        """"""""""""Initialize MediaPlayer entity.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:37:29Z] you can use the `self.player` property here,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,751 @@,,,,,,,,,,,,,
"+""""""""""""MediaPlayer platform for Music Assistant integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?, Callable, Coroutine, Mapping, Sequence,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?, Any, Concatenate, ParamSpec, TypeVar,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from music_assistant.common.models.enums import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?, MusicAssistantError,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?, Track,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from homeassistant.components.media_player import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?, ConfigEntryState,,,,,,,,,,,,,,
#NAME?, STATE_OFF, STATE_PAUSED, STATE_PLAYING,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
+from .entity import MassBaseEntity,,,,,,,,,,,,,,,
+from .helpers import get_mass,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+SUPPORTED_FEATURES = (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.VOLUME_SET,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.STOP,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.PREVIOUS_TRACK,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.NEXT_TRACK,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.SHUFFLE_SET,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.REPEAT_SET,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.TURN_ON,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.TURN_OFF,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.PLAY,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.PLAY_MEDIA,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.VOLUME_STEP,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.CLEAR_PLAYLIST,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.BROWSE_MEDIA,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.MEDIA_ENQUEUE,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.MEDIA_ANNOUNCE,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.SEEK,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+STATE_MAPPING = {,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+},,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+QUEUE_OPTION_MAP = {,,,,,,,,,,,,,,,
+    # map from HA enqueue options to MA enqueue options,,,,,,,,,,,,,,,
+    # which are the same but just in case,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+},,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+ATTR_RADIO_MODE = """"radio_mode""""",,,,,,,,,,,,,,,
"+ATTR_MEDIA_ID = """"media_id""""",,,,,,,,,,,,,,,
"+ATTR_MEDIA_TYPE = """"media_type""""",,,,,,,,,,,,,,,
"+ATTR_ARTIST = """"artist""""",,,,,,,,,,,,,,,
"+ATTR_ALBUM = """"album""""",,,,,,,,,,,,,,,
"+ATTR_URL = """"url""""",,,,,,,,,,,,,,,
"+ATTR_USE_PRE_ANNOUNCE = """"use_pre_announce""""",,,,,,,,,,,,,,,
"+ATTR_ANNOUNCE_VOLUME = """"announce_volume""""",,,,,,,,,,,,,,,
"+ATTR_SOURCE_PLAYER = """"source_player""""",,,,,,,,,,,,,,,
"+ATTR_AUTO_PLAY = """"auto_play""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+# pylint: disable=too-many-public-methods,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:37:58Z] ```suggestion,,,,,,,,,,,,,,,
```,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,751 @@,,,,,,,,,,,,,
"+""""""""""""MediaPlayer platform for Music Assistant integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?, Callable, Coroutine, Mapping, Sequence,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?, Any, Concatenate, ParamSpec, TypeVar,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from music_assistant.common.models.enums import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?, MusicAssistantError,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?, Track,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from homeassistant.components.media_player import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?, ConfigEntryState,,,,,,,,,,,,,,
#NAME?, STATE_OFF, STATE_PAUSED, STATE_PLAYING,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
+from .entity import MassBaseEntity,,,,,,,,,,,,,,,
+from .helpers import get_mass,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+SUPPORTED_FEATURES = (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.VOLUME_SET,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.STOP,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.PREVIOUS_TRACK,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.NEXT_TRACK,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.SHUFFLE_SET,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.REPEAT_SET,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.TURN_ON,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.TURN_OFF,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.PLAY,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.PLAY_MEDIA,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.VOLUME_STEP,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.CLEAR_PLAYLIST,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.BROWSE_MEDIA,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.MEDIA_ENQUEUE,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.MEDIA_ANNOUNCE,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.SEEK,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+STATE_MAPPING = {,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+},,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+QUEUE_OPTION_MAP = {,,,,,,,,,,,,,,,
+    # map from HA enqueue options to MA enqueue options,,,,,,,,,,,,,,,
+    # which are the same but just in case,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+},,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+ATTR_RADIO_MODE = """"radio_mode""""",,,,,,,,,,,,,,,
"+ATTR_MEDIA_ID = """"media_id""""",,,,,,,,,,,,,,,
"+ATTR_MEDIA_TYPE = """"media_type""""",,,,,,,,,,,,,,,
"+ATTR_ARTIST = """"artist""""",,,,,,,,,,,,,,,
"+ATTR_ALBUM = """"album""""",,,,,,,,,,,,,,,
"+ATTR_URL = """"url""""",,,,,,,,,,,,,,,
"+ATTR_USE_PRE_ANNOUNCE = """"use_pre_announce""""",,,,,,,,,,,,,,,
"+ATTR_ANNOUNCE_VOLUME = """"announce_volume""""",,,,,,,,,,,,,,,
"+ATTR_SOURCE_PLAYER = """"source_player""""",,,,,,,,,,,,,,,
"+ATTR_AUTO_PLAY = """"auto_play""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+# pylint: disable=too-many-public-methods,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+_MassPlayerT = TypeVar(""""_MassPlayerT"""""," bound=""""MassPlayer"""")",,,,,,,,,,,,,,
"+_R = TypeVar(""""_R"""")",,,,,,,,,,,,,,,
"+_P = ParamSpec(""""_P"""")",,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:38:11Z] We can use the new notation for this,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,751 @@,,,,,,,,,,,,,
"+""""""""""""MediaPlayer platform for Music Assistant integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?, Callable, Coroutine, Mapping, Sequence,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?, Any, Concatenate, ParamSpec, TypeVar,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from music_assistant.common.models.enums import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?, MusicAssistantError,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?, Track,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+from homeassistant.components.media_player import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?, ConfigEntryState,,,,,,,,,,,,,,
#NAME?, STATE_OFF, STATE_PAUSED, STATE_PLAYING,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from .const import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
+from .entity import MassBaseEntity,,,,,,,,,,,,,,,
+from .helpers import get_mass,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+if TYPE_CHECKING:,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+SUPPORTED_FEATURES = (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.VOLUME_SET,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.STOP,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.PREVIOUS_TRACK,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.NEXT_TRACK,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.SHUFFLE_SET,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.REPEAT_SET,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.TURN_ON,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.TURN_OFF,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.PLAY,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.PLAY_MEDIA,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.VOLUME_STEP,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.CLEAR_PLAYLIST,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.BROWSE_MEDIA,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.MEDIA_ENQUEUE,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.MEDIA_ANNOUNCE,,,,,,,,,,,,,,,
+    | MediaPlayerEntityFeature.SEEK,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+STATE_MAPPING = {,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+},,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+QUEUE_OPTION_MAP = {,,,,,,,,,,,,,,,
+    # map from HA enqueue options to MA enqueue options,,,,,,,,,,,,,,,
+    # which are the same but just in case,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+},,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+ATTR_RADIO_MODE = """"radio_mode""""",,,,,,,,,,,,,,,
"+ATTR_MEDIA_ID = """"media_id""""",,,,,,,,,,,,,,,
"+ATTR_MEDIA_TYPE = """"media_type""""",,,,,,,,,,,,,,,
"+ATTR_ARTIST = """"artist""""",,,,,,,,,,,,,,,
"+ATTR_ALBUM = """"album""""",,,,,,,,,,,,,,,
"+ATTR_URL = """"url""""",,,,,,,,,,,,,,,
"+ATTR_USE_PRE_ANNOUNCE = """"use_pre_announce""""",,,,,,,,,,,,,,,
"+ATTR_ANNOUNCE_VOLUME = """"announce_volume""""",,,,,,,,,,,,,,,
"+ATTR_SOURCE_PLAYER = """"source_player""""",,,,,,,,,,,,,,,
"+ATTR_AUTO_PLAY = """"auto_play""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+# pylint: disable=too-many-public-methods,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+_MassPlayerT = TypeVar(""""_MassPlayerT"""""," bound=""""MassPlayer"""")",,,,,,,,,,,,,,
"+_R = TypeVar(""""_R"""")",,,,,,,,,,,,,,,
"+_P = ParamSpec(""""_P"""")",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+def catch_musicassistant_error(,,,,,,,,,,,,,,,
+    func: Callable[Concatenate[_MassPlayerT, _P], Awaitable[_R]],,,,,,,,,,,,,
+) -> Callable[Concatenate[_MassPlayerT, _P], Coroutine[Any, Any, _R | None]]:,,,,,,,,,,,
"+    """"""""""""Check and log commands to players.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    async def wrapper(,,,,,,,,,,,,,,,
#NAME?, *args: _P.args, **kwargs: _P.kwargs,,,,,,,,,,,,,
+    ) -> _R | None:,,,,,,,,,,,,,,,
"+        """"""""""""Catch Music Assistant errors and convert to Home Assistant error.""""""""""""",,,,,,,,,,,,,,,
+        try:,,,,,,,,,,,,,,,
+            return await func(self, *args, **kwargs),,,,,,,,,,,,,
+        except MusicAssistantError as err:,,,,,,,,,,,,,,,
"+            raise HomeAssistantError(f""""{err.__class__.__name__}: {err!s}"""") from err",,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-22T09:39:10Z] Instead of showing the user an error a dev can understand," I would rather see user facing errors like """"Could not add to queue"""" or something along those lines (they can even be translated)",,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-30T14:26:09Z] Small note: the coverage for config_flow.py doesn't appear to be at 100%,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-30T14:36:47Z] Which one are we missing?,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-30T14:39:41Z] https://app.codecov.io/gh/home-assistant/core/pull/128919/blob/homeassistant/components/music_assistant/config_flow.py,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
`get_server_info` function is uncovered,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-30T14:40:49Z] Oh that's a good catch. I will update,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from author) [2024-10-30T14:48:48Z] Ah yes, I have mocked that the whole time due to `socket.socket` issues,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-30T14:50:47Z] > Ah yes, I have mocked that the whole time due to `socket.socket` issues,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
You should be able to mock the client creation and set the property on the mocked client, instead of patching the function,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-30T14:51:29Z] Thanks for staying sharp @epenet!,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from author) [2024-10-30T14:54:39Z] > > Ah yes, I have mocked that the whole time due to `socket.socket` issues,,,,,,,,,,,,,,
> ,,,,,,,,,,,,,,,
> You should be able to mock the client creation and set the property on the mocked client, instead of patching the function,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Sounds far more sensible,,,,,,,,,,,,,,,
",
128918,Add musicassistant integration,2024-10-21 16:47:24+00:00,2024-10-22 17:01:47+00:00,closed,142,0,0,https://github.com/home-assistant/core/pull/128918,New integration (thank you!),5265,2024-10-21T16:50:34Z,,jozefKruszynski,(from reviewer) [2024-10-21T16:50:29Z] You probably rebased onto dev", you should not do that, only rebase onto the separate branch,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-21T16:52:17Z] I just got the `add-music-assistant` branch up to date with dev," please rebase your branch on that branch and try again""",,,,,,,,,,,,,,
128909,Update Nest configuration flow to handle upcoming changes to Pub/Sub provisioning,2024-10-21 14:09:32+00:00,2024-10-30 12:03:51+00:00,merged,7,12,7,https://github.com/home-assistant/core/pull/128909,New feature (which adds functionality to an existing integration),801,2024-10-29T11:58:37Z,nest,allenporter,"---BEGIN THREAD---
Diff Hunk:
@@ -111,29 +114,52 @@ async def new_subscriber(
         implementation, config_entry_oauth2_flow.LocalOAuth2Implementation
     ):
         raise TypeError(f""Unexpected auth implementation {implementation}"")
-    if not (subscriber_id := entry.data.get(CONF_SUBSCRIBER_ID)):
-        raise ValueError(""Configuration option 'subscriber_id' missing"")
+    if not (
+        subscription_name := entry.data.get(
+            CONF_SUBSCRIPTION_NAME, entry.data.get(CONF_SUBSCRIBER_ID)
+        )
+    ):
+        raise ValueError(
+            ""Configuration option 'subscription_name' or 'subscriber_id' missing""
+        )

(from reviewer) [2024-10-25T11:53:35Z] Are both of these exceptions realistic? When should they occur in real life? (Maybe I will be seeing why when I am scrolling down here)
(from author) [2024-10-25T13:54:28Z] The first one is for typing:
```
homeassistant/components/nest/api.py:119: error: ""AbstractOAuth2Implementation"" has no attribute ""client_id""  [attr-defined]
homeassistant/components/nest/api.py:120: error: ""AbstractOAuth2Implementation"" has no attribute ""client_secret""  [attr-defined]
```
so we could cast instead, but that's why its here.

The second one also shouldn't happen. I think a couple years ago there were a large number of possible states for nest configurations to be in (yaml, multiple auth types, imported subscriptions, manually created subscriptions, etc) that I was probably being paranoid and wanting a clear error message. I've updated this to assume the key exists.
(from author) [2024-11-07T15:46:06Z] Ah by changing this i introduced a `KeyError` since the code will run anyway to check the old format. Sending a PR to fix.
(from author) [2024-11-07T15:49:52Z] Sent https://github.com/home-assistant/core/pull/130057 and added a test case that was missing from this PR to exercise the bug.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -238,40 +243,120 @@ async def async_step_device_project(
     async def async_step_pubsub(
         self, user_input: dict[str, Any] | None = None
     ) -> ConfigFlowResult:
-        """"""Configure and create Pub/Sub subscriber.""""""
+        """"""Configure and the pre-requisites to configure Pub/Sub topics and subscriptions.""""""
         data = {
             **self._data,
             **(user_input if user_input is not None else {}),
         }
         cloud_project_id = data.get(CONF_CLOUD_PROJECT_ID, """").strip()
-        config = self.hass.data.get(DOMAIN, {}).get(DATA_NEST_CONFIG, {})
-        project_id = data.get(CONF_PROJECT_ID, config.get(CONF_PROJECT_ID))
+        device_access_project_id = data[CONF_PROJECT_ID]
 
         errors: dict[str, str] = {}
         if cloud_project_id:
-            # Create the subscriber id and/or verify it already exists. Note that
-            # the existing id is used, and create call below is idempotent
-            if not (subscriber_id := data.get(CONF_SUBSCRIBER_ID, """")):
-                subscriber_id = _generate_subscription_id(cloud_project_id)
-            _LOGGER.debug(""Creating subscriber id '%s'"", subscriber_id)
-            subscriber = api.new_subscriber_with_token(
-                self.hass,
-                self._data[""token""][""access_token""],
-                project_id,
-                subscriber_id,
+            access_token = self._data[""token""][""access_token""]
+            self._admin_client = api.new_pubsub_admin_client(
+                self.hass, access_token=access_token, cloud_project_id=cloud_project_id
             )
             try:
-                await subscriber.create_subscription()
-            except AuthException as err:
-                _LOGGER.error(""Subscriber authentication error: %s"", err)
-                return self.async_abort(reason=""invalid_access_token"")
-            except ConfigurationException as err:
-                _LOGGER.error(""Configuration error creating subscription: %s"", err)
-                errors[CONF_CLOUD_PROJECT_ID] = ""bad_project_id""
-            except SubscriberException as err:
-                _LOGGER.error(""Error creating subscription: %s"", err)
-                errors[CONF_CLOUD_PROJECT_ID] = ""subscriber_error""
+                eligible_topics = await self._admin_client.list_eligible_topics(
+                    device_access_project_id=device_access_project_id
+                )
+            except ApiException as err:
+                _LOGGER.error(""Error listing eligible Pub/Sub topics: %s"", err)
+                errors[""base""] = ""pubsub_api_error""
+            else:
+                if not eligible_topics.topic_names:
+                    errors[""base""] = ""no_pubsub_topics""
+            if not errors:
+                self._data.update(
+                    {
+                        CONF_CLOUD_PROJECT_ID: cloud_project_id,
+                    }
+                )

(from reviewer) [2024-10-25T11:55:02Z] ```suggestion
                self._data[CONF_CLOUD_PROJECT_ID] = cloud_project_id
```
I don't believe there is a difference
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -238,40 +243,120 @@ async def async_step_device_project(
     async def async_step_pubsub(
         self, user_input: dict[str, Any] | None = None
     ) -> ConfigFlowResult:
-        """"""Configure and create Pub/Sub subscriber.""""""
+        """"""Configure and the pre-requisites to configure Pub/Sub topics and subscriptions.""""""
         data = {
             **self._data,
             **(user_input if user_input is not None else {}),
         }
         cloud_project_id = data.get(CONF_CLOUD_PROJECT_ID, """").strip()
-        config = self.hass.data.get(DOMAIN, {}).get(DATA_NEST_CONFIG, {})
-        project_id = data.get(CONF_PROJECT_ID, config.get(CONF_PROJECT_ID))
+        device_access_project_id = data[CONF_PROJECT_ID]
 
         errors: dict[str, str] = {}
         if cloud_project_id:
-            # Create the subscriber id and/or verify it already exists. Note that
-            # the existing id is used, and create call below is idempotent
-            if not (subscriber_id := data.get(CONF_SUBSCRIBER_ID, """")):
-                subscriber_id = _generate_subscription_id(cloud_project_id)
-            _LOGGER.debug(""Creating subscriber id '%s'"", subscriber_id)
-            subscriber = api.new_subscriber_with_token(
-                self.hass,
-                self._data[""token""][""access_token""],
-                project_id,
-                subscriber_id,
+            access_token = self._data[""token""][""access_token""]
+            self._admin_client = api.new_pubsub_admin_client(
+                self.hass, access_token=access_token, cloud_project_id=cloud_project_id
             )
             try:
-                await subscriber.create_subscription()
-            except AuthException as err:
-                _LOGGER.error(""Subscriber authentication error: %s"", err)
-                return self.async_abort(reason=""invalid_access_token"")
-            except ConfigurationException as err:
-                _LOGGER.error(""Configuration error creating subscription: %s"", err)
-                errors[CONF_CLOUD_PROJECT_ID] = ""bad_project_id""
-            except SubscriberException as err:
-                _LOGGER.error(""Error creating subscription: %s"", err)
-                errors[CONF_CLOUD_PROJECT_ID] = ""subscriber_error""
+                eligible_topics = await self._admin_client.list_eligible_topics(
+                    device_access_project_id=device_access_project_id
+                )
+            except ApiException as err:
+                _LOGGER.error(""Error listing eligible Pub/Sub topics: %s"", err)
+                errors[""base""] = ""pubsub_api_error""
+            else:
+                if not eligible_topics.topic_names:
+                    errors[""base""] = ""no_pubsub_topics""
+            if not errors:
+                self._data.update(
+                    {
+                        CONF_CLOUD_PROJECT_ID: cloud_project_id,
+                    }
+                )
+                self._eligible_topics = eligible_topics
+                return await self.async_step_pubsub_topic()
+
+        return self.async_show_form(
+            step_id=""pubsub"",
+            data_schema=vol.Schema(
+                {
+                    vol.Required(CONF_CLOUD_PROJECT_ID, default=cloud_project_id): str,
+                }
+            ),
+            description_placeholders={
+                ""url"": CLOUD_CONSOLE_URL,
+                ""device_access_console_url"": DEVICE_ACCESS_CONSOLE_URL,
+                ""more_info_url"": MORE_INFO_URL,
+            },
+            errors=errors,
+        )
+
+    async def async_step_pubsub_topic(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""Configure and create Pub/Sub topic.""""""
+        if TYPE_CHECKING:
+            assert self._eligible_topics
+        if user_input is not None:
+            self._data.update(user_input)
+            return await self.async_step_pubsub_subscription()
+        topics = list(self._eligible_topics.topic_names)
+        return self.async_show_form(
+            step_id=""pubsub_topic"",
+            data_schema=vol.Schema(
+                {
+                    vol.Optional(CONF_TOPIC_NAME, default=topics[0]): vol.In(topics),
+                }
+            ),
+            description_placeholders={
+                ""device_access_console_url"": DEVICE_ACCESS_CONSOLE_URL,
+                ""more_info_url"": MORE_INFO_URL,
+            },
+            errors={},

(from reviewer) [2024-10-25T11:55:36Z] ```suggestion
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -238,40 +243,120 @@ async def async_step_device_project(
     async def async_step_pubsub(
         self, user_input: dict[str, Any] | None = None
     ) -> ConfigFlowResult:
-        """"""Configure and create Pub/Sub subscriber.""""""
+        """"""Configure and the pre-requisites to configure Pub/Sub topics and subscriptions.""""""
         data = {
             **self._data,
             **(user_input if user_input is not None else {}),
         }
         cloud_project_id = data.get(CONF_CLOUD_PROJECT_ID, """").strip()
-        config = self.hass.data.get(DOMAIN, {}).get(DATA_NEST_CONFIG, {})
-        project_id = data.get(CONF_PROJECT_ID, config.get(CONF_PROJECT_ID))
+        device_access_project_id = data[CONF_PROJECT_ID]
 
         errors: dict[str, str] = {}
         if cloud_project_id:
-            # Create the subscriber id and/or verify it already exists. Note that
-            # the existing id is used, and create call below is idempotent
-            if not (subscriber_id := data.get(CONF_SUBSCRIBER_ID, """")):
-                subscriber_id = _generate_subscription_id(cloud_project_id)
-            _LOGGER.debug(""Creating subscriber id '%s'"", subscriber_id)
-            subscriber = api.new_subscriber_with_token(
-                self.hass,
-                self._data[""token""][""access_token""],
-                project_id,
-                subscriber_id,
+            access_token = self._data[""token""][""access_token""]
+            self._admin_client = api.new_pubsub_admin_client(
+                self.hass, access_token=access_token, cloud_project_id=cloud_project_id
             )
             try:
-                await subscriber.create_subscription()
-            except AuthException as err:
-                _LOGGER.error(""Subscriber authentication error: %s"", err)
-                return self.async_abort(reason=""invalid_access_token"")
-            except ConfigurationException as err:
-                _LOGGER.error(""Configuration error creating subscription: %s"", err)
-                errors[CONF_CLOUD_PROJECT_ID] = ""bad_project_id""
-            except SubscriberException as err:
-                _LOGGER.error(""Error creating subscription: %s"", err)
-                errors[CONF_CLOUD_PROJECT_ID] = ""subscriber_error""
+                eligible_topics = await self._admin_client.list_eligible_topics(
+                    device_access_project_id=device_access_project_id
+                )
+            except ApiException as err:
+                _LOGGER.error(""Error listing eligible Pub/Sub topics: %s"", err)
+                errors[""base""] = ""pubsub_api_error""
+            else:
+                if not eligible_topics.topic_names:
+                    errors[""base""] = ""no_pubsub_topics""
+            if not errors:
+                self._data.update(
+                    {
+                        CONF_CLOUD_PROJECT_ID: cloud_project_id,
+                    }
+                )
+                self._eligible_topics = eligible_topics
+                return await self.async_step_pubsub_topic()
+
+        return self.async_show_form(
+            step_id=""pubsub"",
+            data_schema=vol.Schema(
+                {
+                    vol.Required(CONF_CLOUD_PROJECT_ID, default=cloud_project_id): str,
+                }
+            ),
+            description_placeholders={
+                ""url"": CLOUD_CONSOLE_URL,
+                ""device_access_console_url"": DEVICE_ACCESS_CONSOLE_URL,
+                ""more_info_url"": MORE_INFO_URL,
+            },
+            errors=errors,
+        )
+
+    async def async_step_pubsub_topic(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""Configure and create Pub/Sub topic.""""""
+        if TYPE_CHECKING:
+            assert self._eligible_topics
+        if user_input is not None:
+            self._data.update(user_input)
+            return await self.async_step_pubsub_subscription()
+        topics = list(self._eligible_topics.topic_names)
+        return self.async_show_form(
+            step_id=""pubsub_topic"",
+            data_schema=vol.Schema(
+                {
+                    vol.Optional(CONF_TOPIC_NAME, default=topics[0]): vol.In(topics),
+                }
+            ),
+            description_placeholders={
+                ""device_access_console_url"": DEVICE_ACCESS_CONSOLE_URL,
+                ""more_info_url"": MORE_INFO_URL,
+            },
+            errors={},
+        )
+
+    async def async_step_pubsub_subscription(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""Configure and create Pub/Sub subscription.""""""
+        if TYPE_CHECKING:
+            assert self._admin_client
+        errors = {}
+        if user_input is not None:
+            subscription_name = user_input[CONF_SUBSCRIPTION_NAME]
+            if subscription_name == CREATE_NEW_SUBSCRIPTION_KEY:
+                topic_name = self._data[CONF_TOPIC_NAME]
+                subscription_name = _generate_subscription_id(
+                    self._data[CONF_CLOUD_PROJECT_ID]
+                )
+                _LOGGER.debug(
+                    ""Creating subscription %s on topic %s"",
+                    subscription_name,
+                    topic_name,
+                )
+                try:
+                    await self._admin_client.create_subscription(
+                        topic_name,
+                        subscription_name,
+                    )
+                    _LOGGER.debug(""Created?"")

(from reviewer) [2024-10-25T11:56:02Z] Only have stuff in the try block that can raise
(from author) [2024-10-25T13:55:09Z] Removing this instead, didn't meant to include this in the PR.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -281,23 +366,39 @@ async def async_step_pubsub(
                     self._structure_config_title = generate_config_title(
                         device_manager.structures.values()
                     )
-
-                self._data.update(
-                    {
-                        CONF_SUBSCRIBER_ID: subscriber_id,
-                        CONF_CLOUD_PROJECT_ID: cloud_project_id,
-                    }
-                )
                 return await self._async_finish()
 
+        subscriptions = {}
+        try:
+            eligible_subscriptions = (
+                await self._admin_client.list_eligible_subscriptions(
+                    expected_topic_name=self._data[CONF_TOPIC_NAME],
+                )
+            )
+        except ApiException as err:
+            _LOGGER.error(
+                ""Error talking to API to list eligible Pub/Sub subscriptions: %s"", err
+            )
+            errors[""base""] = ""pubsub_api_error""
+        else:
+            subscriptions.update(
+                {name: name for name in eligible_subscriptions.subscription_names}
+            )
+        subscriptions[CREATE_NEW_SUBSCRIPTION_KEY] = ""Create New""
         return self.async_show_form(
-            step_id=""pubsub"",
+            step_id=""pubsub_subscription"",
             data_schema=vol.Schema(
                 {
-                    vol.Required(CONF_CLOUD_PROJECT_ID, default=cloud_project_id): str,
+                    vol.Optional(
+                        CONF_SUBSCRIPTION_NAME,
+                        default=next(iter(subscriptions)),
+                    ): vol.In(subscriptions),
                 }
             ),

(from reviewer) [2024-10-25T12:00:32Z] I am not 100% sure on this, but you can pass a translation key to a selectselector. maybe we can use that to translate the create_new. But I am not sure if all keys that are in the options need to be in string.json, because ideally it shows the raw strings if its not found.

Not a blocker, just curious
(from author) [2024-10-25T13:57:55Z] Yeah, I was thinking the same thing that it would be ideal to translate create new, but then still have it work for th other options.

```
Please select a topic:
- ( ) Use A
- ( ) Use B
- ( ) Use C
- ( ) Create a new topic
```

My assumption was that given some of the work to enforce translation keys existing, that we wouldn't want to do this. I will follow up and get a definitive answer though.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -26,12 +26,26 @@
         ""title"": ""[%key:common::config_flow::title::oauth2_pick_implementation%]""
       },
       ""pubsub"": {
-        ""title"": ""Configure Google Cloud"",
-        ""description"": ""Visit the [Cloud Console]({url}) to find your Google Cloud Project ID."",
+        ""title"": ""Configure Google Cloud Pub/Sub"",
+        ""description"": ""Home Assistant uses Cloud Pub/Sub receive realtime Nest device updates. Nest servers publish updates to a Pub/Sub Topic and Home Assistat receives the updates through a Pub/Sub Subscription.\n\n1. Visit the [Device Access Console]({device_access_console_url}) and ensure a Pub/Sub topic is configured.\n2. Visit the [Cloud Console]({url}) to find your Google Cloud Project ID and confirm it is correct below.\n3. The next step will attempt to audo-discover Pub/Sub topics and subscriptions.\n\nSee the integration documentation for [more info]({more_info_url})."",
         ""data"": {
           ""cloud_project_id"": ""[%key:component::nest::config::step::cloud_project::data::cloud_project_id%]""
         }
       },
+      ""pubsub_topic"": {
+        ""title"": ""Configure Cloud Pub/Sub Topic"",
+        ""description"": ""Nest devices publish updates on a Cloud Pub/Sub Topic. Select the Pub/Sub topic below that is the same as the [Device Access Console]({device_access_console_url}). See the integration documentation for [more info]({more_info_url})."",
+        ""data"": {
+          ""topic_name"": ""Pub/Sub Topic Name""

(from reviewer) [2024-10-25T12:01:19Z] is `Topic` a brand name or is it just a normal word, otherwise we should lowercase that word
(from author) [2024-10-25T13:58:48Z] Lowercasing.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -26,12 +26,26 @@
         ""title"": ""[%key:common::config_flow::title::oauth2_pick_implementation%]""
       },
       ""pubsub"": {
-        ""title"": ""Configure Google Cloud"",
-        ""description"": ""Visit the [Cloud Console]({url}) to find your Google Cloud Project ID."",
+        ""title"": ""Configure Google Cloud Pub/Sub"",
+        ""description"": ""Home Assistant uses Cloud Pub/Sub receive realtime Nest device updates. Nest servers publish updates to a Pub/Sub Topic and Home Assistat receives the updates through a Pub/Sub Subscription.\n\n1. Visit the [Device Access Console]({device_access_console_url}) and ensure a Pub/Sub topic is configured.\n2. Visit the [Cloud Console]({url}) to find your Google Cloud Project ID and confirm it is correct below.\n3. The next step will attempt to audo-discover Pub/Sub topics and subscriptions.\n\nSee the integration documentation for [more info]({more_info_url})."",
         ""data"": {
           ""cloud_project_id"": ""[%key:component::nest::config::step::cloud_project::data::cloud_project_id%]""
         }
       },
+      ""pubsub_topic"": {
+        ""title"": ""Configure Cloud Pub/Sub Topic"",
+        ""description"": ""Nest devices publish updates on a Cloud Pub/Sub Topic. Select the Pub/Sub topic below that is the same as the [Device Access Console]({device_access_console_url}). See the integration documentation for [more info]({more_info_url})."",
+        ""data"": {
+          ""topic_name"": ""Pub/Sub Topic Name""
+        }
+      },
+      ""pubsub_subscription"": {
+        ""title"": ""Configure Cloud Pub/Sub Subscription"",
+        ""description"": ""Home Assistant receives realtime Nest device updates with a Cloud Pub/Sub Subscription for topic `{topic}`.\n\nSelect an existing subscription below if one already exists, or the next step will create a new one for you. See the integration documentation for [more info]({more_info_url})."",
+        ""data"": {
+          ""subscription_name"": ""Pub/Sub Subscription Name""
+        }

(from reviewer) [2024-10-25T12:01:33Z] idem for subscription name
(from author) [2024-10-25T13:58:51Z] Lowercasing.
---END THREAD---

(from author) [2024-10-25T14:05:59Z] > Also, I am now wondering, does `nest` support multiple config entries and could they collide when you for some reason select the same pubsub? (Just a random though)

Yes, nest does support multiple config entries. The main thing that users may mess up here is picking a pubsub topic that is not configured with the nest device access project.  That is, the main steps need to be:
- Create a topic
- Create a subscription for that topic
- Ensure Nest Device Access console the name of the topic
- Ensure Home Assistant has the name of the subscription

(Aside: Home Assistant asks for a topic name and a subscription in the config flow steps to help create them and to help the user know they need to do (3) and manually verify the device access console is set up correctly.)

So the main thing that can get messed up is that the nest device access console is configured with the wrong topic, then no events will be received. It's not just that you configure two with the same subscription, its that it implies one is wrong.  So we could ensure that the user doesn't configure the same subscription twice since it indicates something else is wrong?

(from author) [2024-10-29T05:16:27Z] I fixed the failing test that was covering the missing field case I removed. This is now ready for review, and i'd love to get into Nov release for Nest team's migration.",
128908,Add update_percentage property to update entity,2024-10-21 13:38:43+00:00,2024-10-22 18:02:26+00:00,merged,3,0,0,https://github.com/home-assistant/core/pull/128908,New feature (which adds functionality to an existing integration),33,2024-10-21T17:49:50Z,update,emontnemery,,
128896,Include Z-Wave JS lowSecurityReason in node added websocket message,2024-10-21 12:15:39+00:00,2024-10-22 13:06:54+00:00,merged,2,0,0,https://github.com/home-assistant/core/pull/128896,New feature (which adds functionality to an existing integration),2,2024-10-21T12:27:04Z,zwave_js,MindFreeze,,
128895,date extraction from google task,2024-10-21 12:04:01+00:00,2024-10-23 16:02:30+00:00,closed,6,0,1,https://github.com/home-assistant/core/pull/128895,New feature (which adds functionality to an existing integration),1090,2024-10-22T13:29:13Z,google_tasks,jagadish1296,,
128881,feat: add device trigger and conditoins to Steam Integration,2024-10-21 08:55:58+00:00,2024-10-22 10:02:03+00:00,closed,6,0,0,https://github.com/home-assistant/core/pull/128881,New feature (which adds functionality to an existing integration),527,2024-10-21T09:09:51Z,steam_online,juliusmarminge,,
128879,Change Stun server port to 80,2024-10-21 08:44:03+00:00,2024-10-23 16:02:31+00:00,merged,2,0,1,https://github.com/home-assistant/core/pull/128879,New feature (which adds functionality to an existing integration),4,2024-10-22T12:23:29Z,camera,klejejs,,
128870,Add subscription tier attribute to Twitch integration.,2024-10-21 03:26:04+00:00,2024-10-22 21:02:58+00:00,merged,5,15,0,https://github.com/home-assistant/core/pull/128870,New feature (which adds functionality to an existing integration),12,2024-10-21T19:54:11Z,twitch,qwell,"(from author) [2024-10-21T15:43:45Z] Added tier to tests.  Tests do not currently pass for me, so this is only theoretical.

---BEGIN THREAD---
Diff Hunk:
@@ -1,3 +1,4 @@
 {
-  ""is_gift"": true
+  ""is_gift"": true,
+  ""tier"": 2000

(from reviewer) [2024-10-21T15:44:17Z] Is this a real value? You probably use Twitch more than me, but I know that they have tier 1, 2 and 3 right?
(from author) [2024-10-21T15:45:48Z] Yes, the tier values are 1000, 2000, and 3000.  I have no idea why.  See https://dev.twitch.tv/docs/api/reference/#check-user-subscription
(from reviewer) [2024-10-21T15:47:24Z] oh lol
---END THREAD---

(from reviewer) [2024-10-21T15:47:31Z] mypy is failing

---BEGIN THREAD---
Diff Hunk:
@@ -18,8 +18,8 @@
 ATTR_GAME = ""game""
 ATTR_TITLE = ""title""
 ATTR_SUBSCRIPTION = ""subscribed""
-ATTR_SUBSCRIPTION_SINCE = ""subscribed_since""

(from author) [2024-10-21T15:52:15Z] This was unused (and doesn't exist in the API) so I removed it in passing.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -80,6 +80,7 @@ async def test_oauth_with_sub(
     sensor_state = hass.states.get(ENTITY_ID)
     assert sensor_state.attributes[""subscribed""] is True
     assert sensor_state.attributes[""subscription_is_gifted""] is False
+    assert sensor_state.attributes[""subscription_tier""] == 1000

(from reviewer) [2024-10-21T15:54:15Z] But, shouldn't we show 1/2/3 here?
(from author) [2024-10-21T15:58:13Z] I don't think we should change the value at all.  The end user would want to get it as the API provides it, I would think.  We only show the 1000, 2000, and 3000 as-is.
(from reviewer) [2024-10-21T16:05:31Z] Yes, but users don't talk to an API, users go on Twitch and have a Tier 1 sub, so they expect their tier to be `1`. If I don't have knowledge of the API, seeing myself being a `tier 1000` sub just feels off
(from author) [2024-10-21T16:06:03Z] Fair enough.  I'll look at it.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -80,6 +80,10 @@ async def test_oauth_with_sub(
     sensor_state = hass.states.get(ENTITY_ID)
     assert sensor_state.attributes[""subscribed""] is True
     assert sensor_state.attributes[""subscription_is_gifted""] is False
+    assert {""1000"": 1, ""2000"": 2, ""3000"": 3}.get(
+        sensor_state.attributes[""subscription_tier""], None
+    ) == 1

(from reviewer) [2024-10-21T17:44:52Z] The test is incorrect, that should just stay the same
(from author) [2024-10-21T17:49:09Z] This value should be what the sensor attribute ends up as though, shouldn't it?  Or does it go through that part of `TwitchCoordinator`?
(from reviewer) [2024-10-21T18:03:11Z] the subscription tier is now what we put into the fixtures right?
(from author) [2024-10-21T18:04:47Z] The fixture data (corrected a few minutes ago) is what gets returned from the API, so it's a string there.  The attribute `subscription_tier`, which is what gets displayed to the user, would be an integer.
(from reviewer) [2024-10-21T18:08:14Z] yes, then the test should be just `sensor_state.attributes[""subscription_tier""] == 1`?
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -111,6 +112,7 @@ async def _async_update_data(self) -> dict[str, TwitchUpdate]:
                 channel.profile_image_url,
                 sub is not None if sub else None,
                 sub.is_gift if sub else None,
+                {""1000"": 1, ""2000"": 2, ""3000"": 3}.get(sub.tier, None) if sub else None,

(from reviewer) [2024-10-21T19:09:18Z] ```suggestion
                {""1000"": 1, ""2000"": 2, ""3000"": 3}.get(sub.tier) if sub else None,
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -80,6 +80,8 @@ async def test_oauth_with_sub(
     sensor_state = hass.states.get(ENTITY_ID)
     assert sensor_state.attributes[""subscribed""] is True
     assert sensor_state.attributes[""subscription_is_gifted""] is False
+    assert sensor_state.attributes[""subscription_tier""] == 1
+

(from reviewer) [2024-10-21T19:09:36Z] ```suggestion
```
---END THREAD---",
128867,Add strings for ZHA Giex valves,2024-10-21 00:28:48+00:00,2024-10-28 01:29:08+00:00,closed,1,0,5,https://github.com/home-assistant/core/pull/128867,New feature (which adds functionality to an existing integration),48,2024-10-27T00:05:53Z,zha,prairiesnpr,"(from reviewer) [2024-10-21T00:34:54Z] Thanks! I'd have added these in the ZHA bump PR (containing the quirks bump) otherwise.
I'll mark this as a draft, until there's a PR for the lib bump containing the v2 quirks. We could also add the commits from this PR to the bump then, if we want to have it in the same PR.

(from author) [2024-10-27T00:05:53Z] Added in https://github.com/home-assistant/core/pull/129247 ",
128856,Set Plugwise connection-timeout based on Gateway version,2024-10-20 17:34:13+00:00,2024-10-29 17:02:03+00:00,closed,9,15,7,https://github.com/home-assistant/core/pull/128856,New feature (which adds functionality to an existing integration),230,2024-10-28T16:50:20Z,plugwise,bouwew,"---BEGIN THREAD---
Diff Hunk:
@@ -21,7 +22,8 @@ async def async_setup_entry(hass: HomeAssistant, entry: PlugwiseConfigEntry) ->
 
     coordinator = PlugwiseDataUpdateCoordinator(hass)
     await coordinator.async_config_entry_first_refresh()
-    migrate_sensor_entities(hass, coordinator)
+    await async_migrate_sensor_entities(hass, coordinator)
+    await async_migrate_plugwise_entry(hass, coordinator, entry)

(from reviewer) [2024-10-21T13:20:56Z] Please use the migrate function for this `async_migrate_entry`
(from author) [2024-10-21T13:42:24Z] Tried that, can't make it work. I need to access the coordinator to be able to pick up the firmware version.
(from reviewer) [2024-10-21T13:43:40Z] Ooh right. Hmm. Would it be possible to create a new connection during migration?
(from author) [2024-10-21T14:28:54Z] Unless... I store it as part of the `config-entry`, would that work?
(from reviewer) [2024-10-21T14:39:09Z] I mean, you need a few parameters to create a connection to the plugwise device right? Can't you create a new client during migration, get the info you need and close it.

I think we consider things like config flow and migration to be independent from the normal workflow, as in, when you set up the config flow, we also don't store the client used to verify to use later
(from author) [2024-10-21T15:34:04Z] I will try to get the required version from the `device_registry.sw_version`, that should be the simplest method.
(from reviewer) [2024-10-21T15:40:15Z] But wait (this is the moment I actually realize what we are doing here). Why don't we fetch this on runtime? Because you can change the update interval of a coordinator on runtime, why do we need to store the version in the entry?
(from author) [2024-10-26T10:22:22Z] Ok, the PR has been reworked.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -225,6 +233,38 @@ async def test_migrate_unique_id_relay(
     assert entity_migrated.unique_id == new_unique_id
 
 
+async def test_entry_migration(
+    hass: HomeAssistant, mock_smile_anna_2: MagicMock, snapshot: SnapshotAssertion
+) -> None:
+    """"""Test config entry version 1 -> 2 migration.""""""
+    entry = MockConfigEntry(
+        title=""My Plugwise"",
+        domain=DOMAIN,
+        data={
+            CONF_HOST: ""127.0.0.1"",
+            CONF_MAC: ""AA:BB:CC:DD:EE:FF"",
+            CONF_PASSWORD: ""test-password"",
+            CONF_PORT: 80,
+            CONF_USERNAME: ""smile"",
+        },
+        minor_version=1,
+        version=1,
+        unique_id=""smile98765"",
+    )
+
+    entry.runtime_data = MagicMock(api=mock_smile_anna_2)
+    entry.add_to_hass(hass)
+
+    assert entry.version == 1
+    assert entry.minor_version == 1
+
+    await hass.config_entries.async_setup(entry.entry_id)
+    await hass.async_block_till_done()
+
+    # Assert that the migrated entry matches the expected structure
+    assert hass.config_entries.async_get_entry(entry.entry_id) == snapshot

(from reviewer) [2024-10-21T13:22:20Z] I do like snapshots, but in this case I would rather see a test that tests if the entry is changed to what we expect. Snapshot tests are nice to fixate data objects, but they don't tell us the meaning behind the change nor what we expect it to test
(from author) [2024-10-21T13:39:15Z] OK, I took inspiration from a wrong integration then 🥲 
(from author) [2024-10-26T10:22:37Z] Changed as requested.
---END THREAD---

(from reviewer) [2024-10-26T10:36:18Z] Nice work @bouwew 

---BEGIN THREAD---
Diff Hunk:
@@ -2,8 +2,8 @@
   ""config"": {
     ""step"": {
       ""user"": {
-        ""title"": ""Connect to the Smile"",
-        ""description"": ""Please enter"",
+        ""title"": ""Set up Plugwise Adam/Smile/Stretch"",

(from reviewer) [2024-10-26T12:47:46Z] This change is not related to the goal of this PR and should not be in this PR for that reason. As a side-note, essentially, the title can be fully removed. We fall back to the integration title, which a user explicitly starts the addition process for.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -3,13 +3,26 @@
 from collections.abc import Awaitable, Callable, Coroutine
 from typing import Any, Concatenate
 
+from packaging import version
 from plugwise.exceptions import PlugwiseException
 
 from homeassistant.exceptions import HomeAssistantError
 
+from .const import DEFAULT_TIMEOUT
 from .entity import PlugwiseEntity
 
 
+def get_timeout_for_version(version_str: str) -> int:
+    """"""Determine timeout value based on gateway version.
+
+    A gateway firmware version > 3.2.0 should mean a latest-generation-device, allowing for a timeout of 10s.
+    Legacy devices require a timeout of 30s.
+    """"""
+    if version.parse(version_str) >= version.parse(""3.2.0""):
+        return 10
+    return DEFAULT_TIMEOUT

(from reviewer) [2024-10-26T12:49:17Z] I really think this is not integration logic.

The fact we pass down a timeout (which is also device depended) from Home Assistant down to the library is odd. Why not handle all of that in the library?

Home Assistant connects with a device... without passing a timeout, and it gets a timeout raised when... well whenever 🤷 
(from author) [2024-10-26T17:36:24Z] Yes, that's how we did it before but then we're stuck with an initial timeout of 30 secs for all devices.
So if a user makes a typo she/he has to wait for 90 sec before she/he can correct and try again.

The nice thing of the HA discovery is that we can use the discovered information to set the timeout as early as possible, from within HA, to 10 sec for most of the user having non-legacy devices.
That was my thinking behind this PR.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -167,6 +176,8 @@ async def async_step_user(
                 user_input[CONF_PORT] = self.discovery_info.port
                 user_input[CONF_USERNAME] = self._username
 
+            # Ensure a timeout-value is available, required for validation
+            user_input[CONF_TIMEOUT] = self._timeout

(from reviewer) [2024-10-26T12:49:59Z] There should be no reason for this to be part of the configuration data.
---END THREAD---",
128844,Add humidity to KNX climate,2024-10-20 12:13:15+00:00,2024-10-21 21:02:19+00:00,merged,6,0,0,https://github.com/home-assistant/core/pull/128844,New feature (which adds functionality to an existing integration),47,2024-10-20T20:17:00Z,knx,alexkn,"(from reviewer) [2024-10-20T13:35:37Z] Thank you for your contribution! 
Before starting CI, we'd need to release a new version of `xknx` and bump the dependency in HA. I'll try to do that tonight. 

(from reviewer) [2024-10-20T18:01:56Z] Here you go https://github.com/XKNX/xknx/releases/tag/3.3.0
Since the addition of humidity is the only change in this release, I guess its fine to add the dependency bump to this PR directly.",
128806,Add addon support to Home Assistant Analytics Insights,2024-10-19 20:21:21+00:00,2024-10-30 22:01:50+00:00,merged,9,1,9,https://github.com/home-assistant/core/pull/128806,New feature (which adds functionality to an existing integration),192,2024-10-29T19:13:56Z,analytics_insights,mib1185,"---BEGIN THREAD---
Diff Hunk:
@@ -55,15 +56,20 @@ async def async_step_user(
         """"""Handle the initial step.""""""
         errors: dict[str, str] = {}
         if user_input is not None:
-            if not user_input.get(CONF_TRACKED_INTEGRATIONS) and not user_input.get(
-                CONF_TRACKED_CUSTOM_INTEGRATIONS
+            if all(
+                [
+                    not user_input.get(CONF_TRACKED_ADDONS),
+                    not user_input.get(CONF_TRACKED_INTEGRATIONS),
+                    not user_input.get(CONF_TRACKED_CUSTOM_INTEGRATIONS),
+                ]
             ):
                 errors[""base""] = ""no_integrations_selected""
             else:
                 return self.async_create_entry(
                     title=""Home Assistant Analytics Insights"",
                     data={},
                     options={
+                        CONF_TRACKED_ADDONS: user_input.get(CONF_TRACKED_ADDONS, []),

(from author) [2024-10-19T20:22:04Z] i've decided to just use `get` here, instead of implementing a complex config entry migration logic
---END THREAD---",
128794,Add diagnostics to Comelit SimpleHome,2024-10-19 17:35:27+00:00,2024-10-25 18:13:02+00:00,merged,4,4,1,https://github.com/home-assistant/core/pull/128794,New feature (which adds functionality to an existing integration),397,2024-10-21T17:33:33Z,comelit,chemelli74,"---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,184 @@
+""""""Tests for Comelit Simplehome diagnostics platform.""""""
+
+from __future__ import annotations
+
+from unittest.mock import patch
+
+from aiocomelit.const import (
+    BRIDGE,
+    CLIMATE,
+    COVER,
+    IRRIGATION,
+    LIGHT,
+    OTHER,
+    SCENARIO,
+    WATT,
+    AlarmAreaState,
+    AlarmZoneState,
+)
+
+from homeassistant.components.comelit.const import DOMAIN
+from homeassistant.components.comelit.diagnostics import TO_REDACT
+from homeassistant.components.diagnostics import REDACTED
+from homeassistant.config_entries import ConfigEntryState
+from homeassistant.const import CONF_TYPE
+from homeassistant.core import HomeAssistant
+
+from .const import (
+    BRIDGE_DEVICE_QUERY,
+    MOCK_USER_BRIDGE_DATA,
+    MOCK_USER_VEDO_DATA,
+    VEDO_DEVICE_QUERY,
+)
+
+from tests.common import MockConfigEntry
+from tests.components.diagnostics import get_diagnostics_for_config_entry
+from tests.typing import ClientSessionGenerator
+
+
+async def test_entry_diagnostics(
+    hass: HomeAssistant,
+    hass_client: ClientSessionGenerator,
+) -> None:

(from reviewer) [2024-10-21T09:26:31Z] Please use `SnapshotAssertion` in diagnostic tests
(from author) [2024-10-21T15:55:17Z] Done!
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,80 @@
+""""""Tests for Comelit Simplehome diagnostics platform.""""""
+
+from __future__ import annotations
+
+from unittest.mock import patch
+
+from syrupy import SnapshotAssertion
+
+from homeassistant.components.comelit.const import DOMAIN
+from homeassistant.components.comelit.diagnostics import TO_REDACT
+from homeassistant.components.diagnostics import REDACTED
+from homeassistant.config_entries import ConfigEntryState
+from homeassistant.core import HomeAssistant
+
+from .const import (
+    BRIDGE_DEVICE_QUERY,
+    MOCK_USER_BRIDGE_DATA,
+    MOCK_USER_VEDO_DATA,
+    VEDO_DEVICE_QUERY,
+)
+
+from tests.common import MockConfigEntry
+from tests.components.diagnostics import get_diagnostics_for_config_entry
+from tests.typing import ClientSessionGenerator
+
+
+async def test_entry_diagnostics_bridge(
+    hass: HomeAssistant,
+    hass_client: ClientSessionGenerator,
+    snapshot: SnapshotAssertion,
+) -> None:
+    """"""Test Bridge config entry diagnostics.""""""
+    entry = MockConfigEntry(domain=DOMAIN, data=MOCK_USER_BRIDGE_DATA)
+    entry.add_to_hass(hass)
+
+    with (
+        patch(""aiocomelit.api.ComeliteSerialBridgeApi.login""),
+        patch(
+            ""aiocomelit.api.ComeliteSerialBridgeApi.get_all_devices"",
+            return_value=BRIDGE_DEVICE_QUERY,
+        ),
+    ):
+        await hass.config_entries.async_setup(entry.entry_id)
+        await hass.async_block_till_done()
+
+    assert entry.state == ConfigEntryState.LOADED
+
+    entry_dict = entry.as_dict()
+    for key in TO_REDACT:
+        entry_dict[""data""][key] = REDACTED

(from reviewer) [2024-10-21T15:56:48Z] Why do we have this? We want to test the code redacting itself right?
(from author) [2024-10-21T16:47:09Z] Yup right, took from below link at my first attempt to write the test.

https://github.com/home-assistant/core/blob/1cc776d3327ff57ecb5ddba7f9764e099b2fd78f/tests/components/fritzbox/test_diagnostics.py#L27L29
---END THREAD---

(from reviewer) [2024-10-21T16:57:04Z] You can exclude those keys in the snapshot",
128791,Adding OpenWeatherMap Minutely forecast action,2024-10-19 16:53:21+00:00,2024-10-20 18:02:26+00:00,closed,11,0,0,https://github.com/home-assistant/core/pull/128791,New feature (which adds functionality to an existing integration),95,2024-10-19T17:15:44Z,openweathermap,10100011,,
128789,Allow to select update interval whilst configuring,2024-10-19 16:36:33+00:00,2024-10-21 06:02:40+00:00,closed,4,3,0,https://github.com/home-assistant/core/pull/128789,New feature (which adds functionality to an existing integration),28,2024-10-19T17:20:21Z,geo_json_events,vingerha,"(from author) [2024-10-19T16:38:45Z] @exxamalte quite a while ago I asked if reducing the update interval was an option but got no response. For my own use-case I require a 60s update so my proposal is to limit it to that as a minimal value, no max. value

Am keeping default at 600s

![image](https://github.com/user-attachments/assets/0dcf13cf-0752-41a9-9e61-d101b65f2ed8)


---BEGIN THREAD---
Diff Hunk:
@@ -19,14 +19,22 @@
 from homeassistant.helpers import config_validation as cv, selector
 from homeassistant.util.unit_conversion import DistanceConverter
 
-from .const import DEFAULT_RADIUS_IN_M, DOMAIN
+from .const import (
+    CONF_UPDATE_INTERVAL,
+    DEFAULT_RADIUS_IN_M,
+    DEFAULT_UPDATE_INTERVAL,
+    DOMAIN,
+)
 
 DATA_SCHEMA = vol.Schema(
     {
         vol.Required(CONF_URL): cv.string,
         vol.Required(CONF_LOCATION): selector.LocationSelector(
             selector.LocationSelectorConfig(radius=True, icon="""")
         ),
+        vol.Required(CONF_UPDATE_INTERVAL, default=DEFAULT_UPDATE_INTERVAL): vol.All(
+            vol.Coerce(int), vol.Range(min=60)
+        ),

(from reviewer) [2024-10-19T17:20:06Z] Hi there @vingerha 👋 

We do not allow integrations to configure a update interval.

Instead, we provide a sane default out of the box. If a user wants a custom schedule or interval, one can use the `home_assistant.update_entity` action.

../Frenck
(from author) [2024-10-19T18:03:39Z] Clear but this integration does not allow that as it always defaults to 300s, so its present status it is already not adhering. I will have a look if this can be made more in-line
(from author) [2024-10-20T05:26:32Z] Correction, it works now... had not looked at it for almost 2y so either it changed or I missed things back then. If I would have known this to work then I would not have spent time on a PR :(
---END THREAD---",
128787,Add Twitch stream viewer as readable data for integration,2024-10-19 15:23:35+00:00,2024-10-21 15:02:02+00:00,merged,4,0,0,https://github.com/home-assistant/core/pull/128787,New feature (which adds functionality to an existing integration),8,2024-10-20T14:07:43Z,twitch,LunaBytesBack,,
128785,Add audio feature sensors to Spotify,2024-10-19 14:51:54+00:00,2024-10-22 08:02:27+00:00,merged,10,6,1,https://github.com/home-assistant/core/pull/128785,New feature (which adds functionality to an existing integration),274,2024-10-21T07:46:38Z,spotify,joostlek,"---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,86 @@
+""""""Sensor platform for Spotify.""""""
+
+from collections.abc import Callable
+from dataclasses import dataclass
+
+from spotifyaio.models import AudioFeatures
+
+from homeassistant.components.sensor import SensorEntity, SensorEntityDescription
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers.device_registry import DeviceEntryType, DeviceInfo
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.helpers.typing import StateType
+from homeassistant.helpers.update_coordinator import CoordinatorEntity
+
+from . import DOMAIN, SpotifyConfigEntry
+from .coordinator import SpotifyCoordinator
+
+
+@dataclass(frozen=True, kw_only=True)
+class SpotifyAudioFeaturesSensorEntityDescription(SensorEntityDescription):
+    """"""Describes Spotify sensor entity.""""""
+
+    value_fn: Callable[[AudioFeatures], StateType]

(from reviewer) [2024-10-19T17:23:56Z] Can we make this more specific instead of `StateType`?
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,65 @@
+""""""Tests for the Spotify sensor platform.""""""
+
+from unittest.mock import MagicMock, patch
+
+import pytest
+from spotifyaio import PlaybackState
+from syrupy import SnapshotAssertion
+
+from homeassistant.components.spotify import DOMAIN
+from homeassistant.const import STATE_UNKNOWN, Platform
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers import entity_registry as er
+
+from . import setup_integration
+
+from tests.common import MockConfigEntry, load_fixture, snapshot_platform
+
+
+@pytest.mark.usefixtures(""setup_credentials"")
+async def test_entities(
+    hass: HomeAssistant,
+    mock_spotify: MagicMock,
+    mock_config_entry: MockConfigEntry,
+    entity_registry: er.EntityRegistry,
+    snapshot: SnapshotAssertion,
+) -> None:
+    """"""Test the Spotify entities.""""""
+    with patch(""homeassistant.components.spotify.PLATFORMS"", [Platform.SENSOR]):
+        await setup_integration(hass, mock_config_entry)

(from reviewer) [2024-10-19T17:26:21Z] We should really figure out something for this weird patch behavior we put on everywhere. IMHO integration setup should just be a fixture and this patching should not be needed.
(from author) [2024-10-19T17:54:44Z] But I also don't find it ideal to have 5-10 extra mocks in the conftest, while 6-7 are only used in one test only.

It also makes it harder to see what the library should behave in one sight, you then are required to open two files to see the full picture.
(from reviewer) [2024-10-20T08:05:31Z] > But I also don't find it ideal to have 5-10 extra mocks in the conftest, while 6-7 are only used in one test only.

Not sure how that is related. We can just set up the whole integration. As a matter of fact. Setting up the integration partly as done in these constructs may hide side-effects.


(from author) [2024-10-20T08:59:48Z] I don't think I understand what you mean
(from reviewer) [2024-10-21T07:45:49Z] it is also not for now, I'm just not happy with seeing this pattern everywhere.
---END THREAD---",
128668,Dynamic add/remove devices for solarlog,2024-10-18 14:16:55+00:00,2024-10-26 17:02:15+00:00,merged,4,13,7,https://github.com/home-assistant/core/pull/128668,New feature (which adds functionality to an existing integration),122,2024-10-25T16:02:14Z,solarlog,dontinelli,"---BEGIN THREAD---
Diff Hunk:
@@ -35,6 +40,9 @@ def __init__(self, hass: HomeAssistant, entry: SolarlogConfigEntry) -> None:
             hass, _LOGGER, name=""SolarLog"", update_interval=timedelta(seconds=60)
         )
 
+        self.new_device_callbacks: list[Callable[[int], None]] = []
+        self._devices_last_update: dict[int, str] = {}

(from reviewer) [2024-10-20T15:12:50Z] So why do we store the last update?
(from author) [2024-10-20T15:56:55Z] To be able to compare the old with the new devices. Took this from tedee and expanded it with the name, as the latter is required to form the device identifier.
(from reviewer) [2024-10-20T18:30:42Z] but if we don't use the last update, rather make it a set of known devices. `set`s are very nice to subtract and see if you need to remove and add deviecs
(from author) [2024-10-20T18:46:33Z] Perhaps there is a misunderstanding in the ""last update"". `self._devices_last_update` is the current state of the devices, i.e. the last update before the current `_async_update_data`.
I first wanted to use a set of the id. But I could not think of a method to retreive the (old) name of the device with the (new) id without having the name also saved. As the (old) name is used to get the device, I therefore went for a dict.
(from reviewer) [2024-10-20T19:04:58Z] wait why do we need both id and name? I am not following that. What do we need to identify what devices we got?
(from author) [2024-10-20T19:17:48Z] I think primar identifier would be the id. But name is required to get the device details of the (old, now removed) device (cf. L132). As we have the name anyway, I also added a check for potential renamed devices (please note that the devices may not be renamed by the user, but names are detected by the SolarLog; cf. L156 ff.)
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -247,7 +247,11 @@ class SolarLogInverterSensorEntityDescription(SensorEntityDescription):
         native_unit_of_measurement=UnitOfPower.WATT,
         device_class=SensorDeviceClass.POWER,
         state_class=SensorStateClass.MEASUREMENT,
-        value_fn=lambda inverter: inverter.current_power,
+        value_fn=(
+            lambda inverter: None
+            if inverter.current_power is None
+            else inverter.current_power
+        ),

(from reviewer) [2024-10-20T15:14:48Z] But if `inverter.current_power is None` and you return `None`, isn't that the same as just returning `inverter.current_power`? Because if it is `None`, you return `None`, and if it is not `None`, it will return its value
(from author) [2024-10-20T18:27:51Z] I think you are right. But why had we added this for consumption_year (L263 ff.)?
(from reviewer) [2024-10-20T19:00:38Z] No clue, haha
(from author) [2024-10-21T06:58:51Z] Had a new thought on this and changed my mind. We added it, as the test goes for `inverter` and not for `inverter.current_power`. If `inverter` is `None`, then it cannot access `inverter.current_power` as no inverter data is available (for whatever reason). So I guess it makes sense to set the sensor values to `None`, showing them as unavailable.
(from author) [2024-10-21T06:59:15Z] Can you please confirm, before I change it back again? ;-)
(from reviewer) [2024-10-25T08:38:31Z] ```py
value_fn=(
            lambda inverter: None
            if inverter is not None
            else inverter.current_power
        ),
```
But then I would expect something like this, where we check if the inverter is not None
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -84,8 +92,61 @@ async def _async_update_data(self) -> SolarlogData:
 
         _LOGGER.debug(""Data successfully updated"")
 
+        if self.solarlog.extended_data:
+            self._async_add_remove_devices(data)
+            _LOGGER.debug(""Add_remove_devices finished"")
+
         return data
 
+    def _async_add_remove_devices(self, data: SolarlogData) -> None:
+        """"""Add new devices, remove non-existing devices.""""""
+        if not self._devices_last_update:
+            self._devices_last_update = {
+                (k, self.solarlog.device_name(k)) for k in data.inverter_data
+            }
+            return
+

(from reviewer) [2024-10-25T15:48:26Z] ```suggestion
```
I think you can remove this one, since it will just go through the whole process and still populate the list
---END THREAD---",
128661,Add media seek for sources other than Deezer for Bang & Olufsen,2024-10-18 11:59:06+00:00,2024-10-26 22:01:50+00:00,merged,4,1,7,https://github.com/home-assistant/core/pull/128661,New feature (which adds functionality to an existing integration),95,2024-10-25T21:34:40Z,bang_olufsen,mj23000,"---BEGIN THREAD---
Diff Hunk:
@@ -608,16 +608,27 @@ async def async_media_next_track(self) -> None:
 
     async def async_media_seek(self, position: float) -> None:
         """"""Seek to position in ms.""""""
-        if self._source_change.id == BangOlufsenSource.DEEZER.id:
+        if self._source_change.is_seekable:

(from reviewer) [2024-10-25T18:11:23Z] If the source is not seekable, the supported features should omit that instead of raising an error
---END THREAD---",
128651,Allow SSL security_protocol configuration property in apache_kafka component,2024-10-18 10:56:24+00:00,2024-10-20 11:01:53+00:00,merged,1,0,0,https://github.com/home-assistant/core/pull/128651,New integration (thank you!),4,2024-10-19T10:05:37Z,apache_kafka,jkaflik,,
128644,Add last alert timestamp for tplink waterleak,2024-10-18 10:02:58+00:00,2024-10-31 23:02:53+00:00,merged,5,0,12,https://github.com/home-assistant/core/pull/128644,New feature (which adds functionality to an existing integration),62,2024-10-30T22:25:30Z,tplink,rytilahti,"(from author) [2024-10-30T12:16:46Z] Current dev has the new version of the library containing the necessary changes, so this is now ready for a review.",
128637,Add throttling functionality to Alert component,2024-10-18 08:11:51+00:00,2024-10-19 09:02:57+00:00,closed,4,1,0,https://github.com/home-assistant/core/pull/128637,New feature (which adds functionality to an existing integration),67,2024-10-18T08:34:20Z,alert,mrwogu,"---BEGIN THREAD---
Diff Hunk:
@@ -47,6 +49,7 @@
         ),
         vol.Optional(CONF_CAN_ACK, default=DEFAULT_CAN_ACK): cv.boolean,
         vol.Optional(CONF_SKIP_FIRST, default=DEFAULT_SKIP_FIRST): cv.boolean,
+        vol.Optional(CONF_THROTTLE, default=DEFAULT_THROTTLE): vol.Coerce(float),

(from reviewer) [2024-10-18T08:34:06Z] We don't allow changes to YAML integrations that are YAML only at this point; especially because these could be migrated to the UI.

However, with that said, development on this integration is currently frozen, and changes for it should not be processed, as the functionality of this integration can be achieved using an automation or automation blueprint without the need for any integration at all.

We currently keep the integration around for historical/backward compatibility purposes, but are not planning on modernizing, refactoring, or extending it.

Nevertheless, thanks for being willing to contribute 👍 

../Frenck
---END THREAD---",
128622,Create a script service schema based on fields,2024-10-18 03:18:26+00:00,2024-10-27 00:08:24+00:00,merged,2,0,7,https://github.com/home-assistant/core/pull/128622,New feature (which adds functionality to an existing integration),132,2024-10-25T23:05:00Z,script,balloob,,
128618,Use fan mode when heat/cool is idle in homekit,2024-10-18 02:00:51+00:00,2024-10-29 07:16:03+00:00,merged,5,0,6,https://github.com/home-assistant/core/pull/128618,New feature (which adds functionality to an existing integration),38,2024-10-24T08:25:40Z,homekit_controller,Xeio,"(from reviewer) [2024-10-18T09:41:42Z] Nice!

Can you add the possible values for this characteristic to aiohomekit here https://github.com/Jc2k/aiohomekit/blob/main/aiohomekit/model/characteristics/const.py as an enum instead of having a const in the integration?

(from reviewer) [2024-10-21T14:15:56Z] aiohomekit 3.2.5 has the enums needed now.",
128590,Catch Reolink LoginFirmwareError,2024-10-17 14:19:56+00:00,2024-10-20 13:05:27+00:00,merged,3,0,1,https://github.com/home-assistant/core/pull/128590,New feature (which adds functionality to an existing integration),38,2024-10-19T11:02:29Z,reolink,starkillerOG,,
128547,"Add min, max for WATER_HEATER device",2024-10-17 07:12:36+00:00,2024-10-30 14:02:01+00:00,closed,1,8,12,https://github.com/home-assistant/core/pull/128547,New feature (which adds functionality to an existing integration),11,2024-10-29T13:20:26Z,lg_thinq,LG-ThinQ-Integration,"---BEGIN THREAD---
Diff Hunk:
@@ -117,7 +117,16 @@
     DeviceType.WASHTOWER_DRYER: WASHER_NUMBERS,
     DeviceType.WASHTOWER: WASHER_NUMBERS,
     DeviceType.WASHTOWER_WASHER: WASHER_NUMBERS,
-    DeviceType.WATER_HEATER: (NUMBER_DESC[ThinQProperty.TARGET_TEMPERATURE],),
+    DeviceType.WATER_HEATER: (
+        NumberEntityDescription(
+            key=ThinQProperty.TARGET_TEMPERATURE,
+            native_max_value=60,
+            native_min_value=35,
+            native_step=1,
+            native_unit_of_measurement=UnitOfTemperature.CELSIUS,
+            translation_key=ThinQProperty.TARGET_TEMPERATURE,
+        ),
+    ),

(from reviewer) [2024-10-17T07:16:00Z] Why didn't we implement the water_heater platform for this?
(from author) [2024-10-17T07:31:11Z] HA water_heater platform support only 0.5 step.
But our devices only support step 1.
That's why we didn't implement the water_header platform.
(from reviewer) [2024-10-17T07:40:24Z] You can overwrite the precision right?

https://github.com/home-assistant/home-assistant/blob/master/homeassistant%2Fcomponents%2Fwater_heater%2F__init__.py#L194-L201
(from author) [2024-10-17T08:08:51Z] Let us discuss about that.
(from author) [2024-10-18T05:30:16Z] As we tested in HomeAssistant, frontend only supporty 0.5 step with +,- buttons.
That is because water_heater entity does not have 'attr_target_temp_step'.
We need 0.5 step in frontend.
If I am wrong please let me know.
(from reviewer) [2024-10-21T14:28:27Z] Frontend has support but backend not (`target_temp_step` is not implemented in `WaterHeaterEntity`).
Otherwise for Fahrenheit it will be step 1, for celsius 0.5.
(from author) [2024-10-24T23:31:58Z] 'core' only supports 1step, but 'frontend' supports 0.5.
User could get it wrong.
In conclusion, 
WaterHeaterEntity does not work as we want.
So we need this.
(from reviewer) [2024-10-29T12:48:58Z] I think we can agree with that so I close this conversation as resolved.
---END THREAD---

(from author) [2024-10-29T12:12:22Z] This PR needs to be rebased properly.",
128544,Add ability to run CI on a single integration despite changes to core files,2024-10-17 06:24:11+00:00,2024-10-18 09:02:25+00:00,closed,1,0,0,https://github.com/home-assistant/core/pull/128544,New feature (which adds functionality to an existing integration),30,2024-10-17T07:10:49Z,,epenet,"(from reviewer) [2024-10-17T06:28:01Z] > Sometimes we want to make changes to CI and/or some core files and test the changes on a single integration.

Why do we want this? I usually run these tests locally, and use the CI to make sure I didn't mess up other integrations or forgot use cases

(from author) [2024-10-17T06:32:20Z] > > Sometimes we want to make changes to CI and/or some core files and test the changes on a single integration.
> 
> Why do we want this? I usually run these tests locally, and use the CI to make sure I didn't mess up other integrations or forgot use cases

#128162 is working just fine on my own machine, but it is failing on Home Assistant CI
I just don't understand why that is... so I'm running various tests

It's not first time that local runs differ from Home Assistant CI, and I thought it might be nice to ease that override.

(from reviewer) [2024-10-17T07:03:44Z] I'm not following, that sounds like a solution for an edge case; we can run the full CI for those exceptions? Not sure why we would add more complexity for this.

../Frenck

(from author) [2024-10-17T07:09:24Z] I needed this indeed for an edge case.
I needed it, I struggled with it, and I thought that I would share my solution.

I no longer need it (it was useful to resolve the issue in #128162), so if you think it adds too much complexity to the flow you can close this PR.",
128540,Add warm_mode to switch platform,2024-10-17 00:31:11+00:00,2024-10-21 14:02:57+00:00,merged,3,0,3,https://github.com/home-assistant/core/pull/128540,New feature (which adds functionality to an existing integration),13,2024-10-20T13:12:40Z,lg_thinq,LG-ThinQ-Integration,,
128530,Add switch entity to Cambridge Audio,2024-10-16 18:32:36+00:00,2024-10-26 13:05:03+00:00,merged,8,2,8,https://github.com/home-assistant/core/pull/128530,New feature (which adds functionality to an existing integration),265,2024-10-25T09:22:50Z,cambridge_audio,noahhusby,"---BEGIN THREAD---
Diff Hunk:
@@ -30,9 +30,17 @@
         ""state"": {
           ""bright"": ""Bright"",
           ""dim"": ""Dim"",
-          ""off"": ""Off""
+          ""off"": ""[%key:common::state::off%]""
         }
       }
+    },
+    ""switch"": {
+      ""pre_amp"": {
+        ""name"": ""Pre-Amp""
+      },
+      ""early_update"": {
+        ""name"": ""Early Update""

(from reviewer) [2024-10-16T19:15:19Z] ```suggestion
        ""name"": ""Early update""
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,84 @@
+""""""Support for Cambridge Audio switch entities.""""""
+
+from collections.abc import Awaitable, Callable
+from dataclasses import dataclass
+from typing import Any
+
+from aiostreammagic import StreamMagicClient
+
+from homeassistant.components.switch import SwitchEntity, SwitchEntityDescription
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import EntityCategory
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+
+from .entity import CambridgeAudioEntity
+
+
+@dataclass(frozen=True, kw_only=True)
+class CambridgeAudioSwitchEntityDescription(SwitchEntityDescription):
+    """"""Describes Cambridge Audio switch entity.""""""
+
+    value_fn: Callable[[StreamMagicClient], bool]
+    set_value_fn: Callable[[StreamMagicClient, bool], Awaitable[None]]
+
+
+CONTROL_ENTITIES: tuple[CambridgeAudioSwitchEntityDescription, ...] = (
+    CambridgeAudioSwitchEntityDescription(
+        key=""pre_amp"",
+        translation_key=""pre_amp"",
+        entity_category=EntityCategory.CONFIG,
+        value_fn=lambda client: client.state.pre_amp_mode,
+        set_value_fn=lambda client, value: client.set_pre_amp_mode(value),
+    ),
+    CambridgeAudioSwitchEntityDescription(
+        key=""early_update"",
+        translation_key=""early_update"",
+        entity_category=EntityCategory.CONFIG,
+        value_fn=lambda client: client.update.early_update,
+        set_value_fn=lambda client, value: client.set_early_update(value),
+    ),
+)
+
+
+async def async_setup_entry(
+    hass: HomeAssistant,
+    entry: ConfigEntry,
+    async_add_entities: AddEntitiesCallback,
+) -> None:
+    """"""Set up Cambridge Audio switch entities based on a config entry.""""""
+    async_add_entities(
+        [
+            CambridgeAudioSwitch(entry.runtime_data, description)
+            for description in CONTROL_ENTITIES
+        ]
+    )

(from reviewer) [2024-10-16T19:15:37Z] ```suggestion
    async_add_entities(
        CambridgeAudioSwitch(entry.runtime_data, description)
        for description in CONTROL_ENTITIES
    )
```
---END THREAD---",
128527,Add select entity to Cambridge Audio,2024-10-16 17:04:03+00:00,2024-10-17 19:01:59+00:00,merged,8,2,0,https://github.com/home-assistant/core/pull/128527,New feature (which adds functionality to an existing integration),221,2024-10-16T17:57:10Z,cambridge_audio,noahhusby,"---BEGIN THREAD---
Diff Hunk:
@@ -22,5 +22,17 @@
       ""cannot_connect"": ""[%key:common::config_flow::error::cannot_connect%]"",
       ""already_configured"": ""[%key:common::config_flow::abort::already_configured_device%]""
     }
+  },
+  ""entity"": {
+    ""select"": {
+      ""display_brightness"": {
+        ""name"": ""Display brightness"",
+        ""state"": {
+          ""bright"": ""Bright"",
+          ""dim"": ""Dim"",
+          ""off"": ""Off""

(from reviewer) [2024-10-16T17:58:42Z] ```suggestion
          ""off"": ""[%key:common::state::off%]""
```
(from author) [2024-10-16T18:00:51Z] @joostlek I'll include in follow-up PR
---END THREAD---",
128521,Add diagnostics to Spotify,2024-10-16 15:42:14+00:00,2024-10-17 19:02:03+00:00,merged,3,0,0,https://github.com/home-assistant/core/pull/128521,New feature (which adds functionality to an existing integration),470,2024-10-16T17:33:28Z,spotify,joostlek,,
128484,Remaining addon management to aiohasupervisor,2024-10-15 20:29:11+00:00,2024-10-22 15:02:00+00:00,merged,27,11,5,https://github.com/home-assistant/core/pull/128484,New feature (which adds functionality to an existing integration),879,2024-10-21T14:41:01Z,mqtt,mdegat01,"---BEGIN THREAD---
Diff Hunk:
@@ -36,10 +36,13 @@
 
 def api_error[_AddonManagerT: AddonManager, **_P, _R](
     error_message: str,
+    *,
+    expected_error_type: type[HassioAPIError | SupervisorError] | None = None,

(from author) [2024-10-15T20:32:14Z] For reviewers - this is a temporary change. Once the migration to `aiohasupervisor` is complete this will be removed as the decorator will just need to catch `SupervisorError`. But for now this helps ensure we aren't squashing errors that shouldn't be happening and unit tests are accurately mocking `aiohasupervisor` methods.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -187,19 +193,24 @@ def async_get_addon_state(self, addon_info: InstalledAddonComplete) -> AddonStat
 
         return addon_state
 
-    @api_error(""Failed to set the {addon_name} add-on options"")
+    @api_error(
+        ""Failed to set the {addon_name} add-on options"",
+        expected_error_type=SupervisorError,
+    )
     async def async_set_addon_options(self, config: dict) -> None:
         """"""Set manager add-on options.""""""
-        options = {""options"": config}
-        await async_set_addon_options(self._hass, self.addon_slug, options)
+        await self._supervisor_client.addons.addon_options(

(from reviewer) [2024-10-16T09:24:27Z] Side note: I think maybe we should add an alias method named `set_options` for this method. If I didn't know better I'd assume this method returned the add-on options.

Generally it's more clear if all methods (at least the ones that cause a change) start with a verb in the name.
(from author) [2024-10-16T15:54:35Z] Hm yea that's fair, that would be more intuitive.
(from author) [2024-10-16T17:17:26Z] https://github.com/home-assistant-libs/python-supervisor-client/pull/22
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -164,9 +166,12 @@ async def async_install(
         **kwargs: Any,
     ) -> None:
         """"""Install an update.""""""
+        supervisor_client = get_supervisor_client(self.hass)

(from reviewer) [2024-10-16T09:28:25Z] I'd store the client on the entity instance in the init method.
(from author) [2024-10-16T15:59:12Z] So I couldn't use the `__init__` method to do that for `AddonManager` as it seemed to create a race condition with the `HassIO` object being created and added to the hass object. That's why I went with the `property` that caches it on first access. I wasn't sure if that was only an issue in unit tests or something that would occur live as well though.

Is it safe to do that here? Or better to just go with a `property` like this:
https://github.com/home-assistant/core/blob/494511e099772722fc9daee15682a8abdf9bc939/homeassistant/components/hassio/addon_manager.py#L116-L121
(from author) [2024-10-16T16:15:35Z] Yea as with before doing this in `__init__` causes all the unit tests to fail:
```py
        self._supervisor_client: SupervisorClient | None = get_supervisor_client(self.hass)
```
But caching on first access to a private property works fine. I'm guessing this is not a real issue but rather one with how our mocking is setup. Because the fixture that mocks that `get_supervisor_client` isn't in place when all the objects are being initialized by a different fixture.

Assuming this isn't an issue on a live system I cant try and do some refactoring here to make this work if you think it is preferrable over the private property approach. Since we were ok with that in `AddonManager` I assumed it was ok here as well.
(from reviewer) [2024-10-17T10:47:46Z] I don't think we should store the client on the HassIO instance at all (for common access). I think we should use the singleton decorator on the function to get the client.
(from reviewer) [2024-10-17T10:53:12Z] <https://github.com/home-assistant/core/blob/2f60395ba9eaf9fb0a0b390267275ba0994a9c35/homeassistant/helpers/singleton.py#L27>
(from author) [2024-10-17T21:04:14Z] Ok that worked. It took a bit though. I don't really like how I had to patch mock every place I imported `get_supervisor_client` in the `supervisor_client` fixture to make it functional but nothing else seemed to work. If there's a better way to do that let me know, patching mocking only `homeassistant.components.hassio.handler.get_supervisor_client` did not seem to be enough. But at least the runtime code is nicer which is more important.
(from reviewer) [2024-10-21T14:40:45Z] We need to patch where the name is used, so I think this is expected and ok.
---END THREAD---",
128455,Add CameraCapabilities,2024-10-15 14:46:36+00:00,2024-10-30 21:01:58+00:00,merged,3,14,14,https://github.com/home-assistant/core/pull/128455,New feature (which adds functionality to an existing integration),214,2024-10-29T20:36:30Z,camera,edenhaus,"---BEGIN THREAD---
Diff Hunk:
@@ -169,6 +169,20 @@ class Image:
     content: bytes = attr.ib()
 
 
+@dataclass(frozen=True)
+class CameraCapabilities:
+    """"""Camera capabilities.""""""
+
+    frontend_stream_types: set[StreamType]
+
+    def to_frontend_dict(self) -> dict[str, Any]:
+        """"""Return a dict that can be used by the frontend.""""""
+
+        return {
+            ""frontendStreamTypes"": self.frontend_stream_types,

(from reviewer) [2024-10-15T14:56:39Z] No other data that we send to the frontend is using the consumers casing format. We just output our data in the Python's used snake casing format and the frontend (or any other consumer) can translate it to their casing.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -748,6 +763,26 @@ async def async_get_webrtc_client_configuration(self) -> WebRTCClientConfigurati
 
         return config
 
+    @final
+    @callback
+    def get_camera_capabilities(self) -> CameraCapabilities:

(from reviewer) [2024-10-15T14:57:36Z] Should we add the `@cache` decorator since we only need to calculate this once? 
(from author) [2024-10-15T15:03:42Z] We need to recalculate it if the WebRTC provider changes, but we will look into it tomorrow.
(from author) [2024-10-17T10:56:39Z] Nick told me we should use `@cache` only on a class or static functions. Otherwise, `self` will be added to the cache and, therefore, never garbage collected. Also, we can only invalidate the whole cache, not only for one instance.

I converted the function to a property so I can use `@under_cached_property`
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -169,6 +169,20 @@ class Image:
     content: bytes = attr.ib()
 
 
+@dataclass(frozen=True)
+class CameraCapabilities:
+    """"""Camera capabilities.""""""
+
+    frontend_stream_types: set[StreamType]
+
+    def to_frontend_dict(self) -> dict[str, Any]:

(from reviewer) [2024-10-15T14:57:56Z] `as_dict` is the function name that we use. 
---END THREAD---

(from reviewer) [2024-10-29T11:12:49Z] A camera test is failing.

---BEGIN THREAD---
Diff Hunk:
@@ -885,3 +900,114 @@ async def test_entity_picture_url_changes_on_token_update(hass: HomeAssistant) -
     new_entity_picture = camera_state.attributes[""entity_picture""]
     assert new_entity_picture != original_picture
     assert ""token="" in new_entity_picture
+
+
+async def _test_capbilities(

(from reviewer) [2024-10-29T11:14:13Z] ```suggestion
async def _test_capabilities(
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -23,3 +30,25 @@ def mock_turbo_jpeg(
     mocked_turbo_jpeg.scale_with_quality.return_value = EMPTY_8_6_JPEG
     mocked_turbo_jpeg.encode.return_value = EMPTY_8_6_JPEG
     return mocked_turbo_jpeg
+
+
+async def add_webrtc_provider(hass: HomeAssistant) -> CameraWebRTCProvider:
+    """"""Add test WebRTC provider.""""""
+
+    class TestProvider(CameraWebRTCProvider):

(from reviewer) [2024-10-29T11:14:58Z] ```suggestion
    class SomeTestProvider(CameraWebRTCProvider):
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -23,3 +30,25 @@ def mock_turbo_jpeg(
     mocked_turbo_jpeg.scale_with_quality.return_value = EMPTY_8_6_JPEG
     mocked_turbo_jpeg.encode.return_value = EMPTY_8_6_JPEG
     return mocked_turbo_jpeg
+
+
+async def add_webrtc_provider(hass: HomeAssistant) -> CameraWebRTCProvider:
+    """"""Add test WebRTC provider.""""""
+
+    class TestProvider(CameraWebRTCProvider):
+        """"""Test provider.""""""
+
+        async def async_is_supported(self, stream_source: str) -> bool:
+            """"""Determine if the provider supports the stream source.""""""
+            return True
+
+        async def async_handle_web_rtc_offer(
+            self, camera: Camera, offer_sdp: str
+        ) -> str | None:
+            """"""Handle the WebRTC offer and return an answer.""""""
+            return ""answer""
+
+    provider = TestProvider()

(from reviewer) [2024-10-29T11:15:06Z] ```suggestion
    provider = SomeTestProvider()
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -213,6 +213,8 @@ async def test_async_register_webrtc_provider_twice(
     register_test_provider: TestProvider,
 ) -> None:
     """"""Test registering a WebRTC provider twice should raise.""""""
+    await async_setup_component(hass, ""camera"", {})

(from reviewer) [2024-10-29T11:17:03Z] Why is this needed?
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -885,3 +900,114 @@ async def test_entity_picture_url_changes_on_token_update(hass: HomeAssistant) -
     new_entity_picture = camera_state.attributes[""entity_picture""]
     assert new_entity_picture != original_picture
     assert ""token="" in new_entity_picture
+
+
+async def _test_capbilities(
+    hass: HomeAssistant,
+    hass_ws_client: WebSocketGenerator,
+    entity_id: str,
+    expected_stream_types: set[StreamType],
+    expected_stream_types_with_webrtc_provider: set[StreamType],
+) -> None:
+    """"""Test camera capabilities.""""""
+    await async_setup_component(hass, ""camera"", {})
+    await hass.async_block_till_done()
+
+    async def test(expected_types: set[StreamType]) -> None:
+        camera_obj = get_camera_from_entity_id(hass, entity_id)
+        capabilities = camera_obj.camera_capabilities
+        assert capabilities == camera.CameraCapabilities(expected_types)
+
+        # Request capabilities through WebSocket
+        client = await hass_ws_client(hass)
+        await client.send_json_auto_id(
+            {""type"": ""camera/capabilities"", ""entity_id"": entity_id}
+        )
+        msg = await client.receive_json()
+
+        # Assert WebSocket response
+        assert msg[""type""] == TYPE_RESULT
+        assert msg[""success""]
+        assert msg[""result""] == {""frontend_stream_types"": list(expected_types)}
+
+    await test(expected_stream_types)
+
+    # Test with WebRTC provider
+    await add_webrtc_provider(hass)
+    await test(expected_stream_types_with_webrtc_provider)
+
+
+@pytest.mark.usefixtures(""mock_camera"", ""mock_stream_source"")
+async def test_camera_capabilities_hls(
+    hass: HomeAssistant,
+    hass_ws_client: WebSocketGenerator,
+) -> None:
+    """"""Test HLS camera capabilities.""""""
+    await _test_capbilities(

(from reviewer) [2024-10-29T11:17:37Z] ```suggestion
    await _test_capabilities(
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -885,3 +900,114 @@ async def test_entity_picture_url_changes_on_token_update(hass: HomeAssistant) -
     new_entity_picture = camera_state.attributes[""entity_picture""]
     assert new_entity_picture != original_picture
     assert ""token="" in new_entity_picture
+
+
+async def _test_capbilities(
+    hass: HomeAssistant,
+    hass_ws_client: WebSocketGenerator,
+    entity_id: str,
+    expected_stream_types: set[StreamType],
+    expected_stream_types_with_webrtc_provider: set[StreamType],
+) -> None:
+    """"""Test camera capabilities.""""""
+    await async_setup_component(hass, ""camera"", {})
+    await hass.async_block_till_done()
+
+    async def test(expected_types: set[StreamType]) -> None:
+        camera_obj = get_camera_from_entity_id(hass, entity_id)
+        capabilities = camera_obj.camera_capabilities
+        assert capabilities == camera.CameraCapabilities(expected_types)
+
+        # Request capabilities through WebSocket
+        client = await hass_ws_client(hass)
+        await client.send_json_auto_id(
+            {""type"": ""camera/capabilities"", ""entity_id"": entity_id}
+        )
+        msg = await client.receive_json()
+
+        # Assert WebSocket response
+        assert msg[""type""] == TYPE_RESULT
+        assert msg[""success""]
+        assert msg[""result""] == {""frontend_stream_types"": list(expected_types)}
+
+    await test(expected_stream_types)
+
+    # Test with WebRTC provider
+    await add_webrtc_provider(hass)
+    await test(expected_stream_types_with_webrtc_provider)
+
+
+@pytest.mark.usefixtures(""mock_camera"", ""mock_stream_source"")
+async def test_camera_capabilities_hls(
+    hass: HomeAssistant,
+    hass_ws_client: WebSocketGenerator,
+) -> None:
+    """"""Test HLS camera capabilities.""""""
+    await _test_capbilities(
+        hass,
+        hass_ws_client,
+        ""camera.demo_camera"",
+        {StreamType.HLS},
+        {StreamType.HLS, StreamType.WEB_RTC},
+    )
+
+
+async def test_camera_capabilities_webrtc(
+    hass: HomeAssistant,
+    hass_ws_client: WebSocketGenerator,
+) -> None:
+    """"""Test WebRTC camera capabilities.""""""
+
+    # Cannot use the fixture mock_camera_web_rtc as it's mocking Camera.async_handle_web_rtc_offer
+    # Camera capabilities are determined by by checking if the function was overwritten(implemented) or not
+    class MockCamera(camera.Camera):
+        """"""Mock Camera Entity.""""""
+
+        _attr_name = ""Test""
+        _attr_supported_features: camera.CameraEntityFeature = (
+            camera.CameraEntityFeature.STREAM
+        )
+
+        async def stream_source(self) -> str | None:
+            return STREAM_SOURCE
+
+        async def async_handle_web_rtc_offer(self, offer_sdp: str) -> str | None:
+            return WEBRTC_ANSWER
+
+    domain = ""test""
+
+    entry = MockConfigEntry(domain=domain)
+    entry.add_to_hass(hass)
+
+    async def async_setup_entry_init(
+        hass: HomeAssistant, config_entry: ConfigEntry
+    ) -> bool:
+        """"""Set up test config entry.""""""
+        await hass.config_entries.async_forward_entry_setups(config_entry, [DOMAIN])
+        return True
+
+    async def async_unload_entry_init(
+        hass: HomeAssistant, config_entry: ConfigEntry
+    ) -> bool:
+        """"""Unload test config entry.""""""
+        await hass.config_entries.async_forward_entry_unload(config_entry, DOMAIN)
+        return True
+
+    mock_integration(
+        hass,
+        MockModule(
+            domain,
+            async_setup_entry=async_setup_entry_init,
+            async_unload_entry=async_unload_entry_init,
+        ),
+    )
+    setup_test_component_platform(hass, DOMAIN, [MockCamera()], from_config_entry=True)
+    mock_platform(hass, f""{domain}.config_flow"", Mock())
+
+    with mock_config_flow(domain, ConfigFlow):
+        assert await hass.config_entries.async_setup(entry.entry_id)
+        await hass.async_block_till_done()
+
+    await _test_capbilities(

(from reviewer) [2024-10-29T11:17:46Z] ```suggestion
    await _test_capabilities(
```
---END THREAD---

(from reviewer) [2024-10-29T12:44:29Z] Frontend is approved and can be merged once this one is approved.

---BEGIN THREAD---
Diff Hunk:
@@ -930,6 +965,28 @@ async def handle(self, request: web.Request, camera: Camera) -> web.StreamRespon
             raise web.HTTPBadRequest from err
 
 
+@websocket_api.websocket_command(
+    {
+        vol.Required(""type""): ""camera/capabilities"",
+        vol.Required(""entity_id""): cv.entity_id,
+    }
+)
+@websocket_api.async_response
+async def ws_camera_capabilities(
+    hass: HomeAssistant, connection: ActiveConnection, msg: dict[str, Any]
+) -> None:
+    """"""Handle get camera capabilities websocket command.
+
+    Async friendly.
+    """"""
+    try:
+        camera = get_camera_from_entity_id(hass, msg[""entity_id""])

(from reviewer) [2024-10-29T19:51:42Z] In the WebRTC commands we didn't catch the `HomeAssistantError` coming from `get_camera_from_entity_id` since it will be handled by the common exception handler. I think we should be consistent.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -930,6 +965,28 @@ async def handle(self, request: web.Request, camera: Camera) -> web.StreamRespon
             raise web.HTTPBadRequest from err
 
 
+@websocket_api.websocket_command(
+    {
+        vol.Required(""type""): ""camera/capabilities"",
+        vol.Required(""entity_id""): cv.entity_id,
+    }
+)
+@websocket_api.async_response
+async def ws_camera_capabilities(
+    hass: HomeAssistant, connection: ActiveConnection, msg: dict[str, Any]
+) -> None:
+    """"""Handle get camera capabilities websocket command.
+
+    Async friendly.
+    """"""
+    try:
+        camera = get_camera_from_entity_id(hass, msg[""entity_id""])
+        connection.send_result(msg[""id""], asdict(camera.camera_capabilities))

(from reviewer) [2024-10-29T19:53:21Z] Can this raise HomeAssistantError?
(from author) [2024-10-29T20:06:14Z] Nope good finding
---END THREAD---",
128452,Add missing Weheat temperature sensors,2024-10-15 14:34:30+00:00,2024-10-17 10:01:53+00:00,merged,6,3,0,https://github.com/home-assistant/core/pull/128452,New feature (which adds functionality to an existing integration),191,2024-10-16T09:53:39Z,weheat,barryvdh,"(from author) [2024-10-15T14:43:21Z] Not sure why the tests are failing.

I also wanted to add:
 - rpm
 - controlBridgeStatusDecodedElectricHeater
 - controlBridgeStatusDecodedGasBoiler

But the first 2 are not exposed as property, only the latter: https://github.com/wefabricate/wh-python/blob/d39f233f78ea01394c238225dbc0b92edba0558f/weheat/abstractions/heat_pump.py#L175

(from reviewer) [2024-10-15T15:51:18Z] run
`pytest ./tests/components/weheat --snapshot-update` and commit what you got

(from author) [2024-10-15T15:55:34Z] > run `pytest ./tests/components/weheat --snapshot-update` and commit what you got

I already did that, but it seems I needed to run `script/setup` again. It now did it correctly I think/hope. Thanks!

(from reviewer) [2024-10-15T15:56:44Z] Ah, the translations were not generated

(from author) [2024-10-16T07:50:46Z] Added docs and tested locally. Seems to work.

![image](https://github.com/user-attachments/assets/491f9101-fa8b-4c36-aebe-a9b50dd91ace)


---BEGIN THREAD---
Diff Hunk:
@@ -95,6 +95,33 @@ class WeHeatSensorEntityDescription(SensorEntityDescription):
         suggested_display_precision=DISPLAY_PRECISION_WATER_TEMP,
         value_fn=lambda status: status.air_inlet_temperature,
     ),
+    WeHeatSensorEntityDescription(
+        translation_key=""thermostat_water_setpoint"",
+        key=""thermostat_water_setpoint"",
+        native_unit_of_measurement=UnitOfTemperature.CELSIUS,
+        device_class=SensorDeviceClass.TEMPERATURE,
+        state_class=SensorStateClass.MEASUREMENT,
+        suggested_display_precision=DISPLAY_PRECISION_WATER_TEMP,
+        value_fn=lambda status: status.thermostat_water_setpoint,
+    ),
+    WeHeatSensorEntityDescription(
+        translation_key=""thermostat_room_temperature"",
+        key=""thermostat_room_temperature"",
+        native_unit_of_measurement=UnitOfTemperature.CELSIUS,
+        device_class=SensorDeviceClass.TEMPERATURE,
+        state_class=SensorStateClass.MEASUREMENT,
+        suggested_display_precision=DISPLAY_PRECISION_WATER_TEMP,
+        value_fn=lambda status: status.thermostat_room_temperature,
+    ),
+    WeHeatSensorEntityDescription(
+        translation_key=""thermostat_room_temperature_setpoint"",
+        key=""thermostat_room_temperature_setpoint"",
+        native_unit_of_measurement=UnitOfTemperature.CELSIUS,
+        device_class=SensorDeviceClass.TEMPERATURE,
+        state_class=SensorStateClass.MEASUREMENT,
+        suggested_display_precision=DISPLAY_PRECISION_WATER_TEMP,
+        value_fn=lambda status: status.thermostat_room_temperature_setpoint,
+    ),

(from reviewer) [2024-10-16T07:54:05Z] Does this only support 1 room?
(from author) [2024-10-16T08:01:34Z] Yes, it is the room where the thermostat is placed. Dutch screenshot from the portal:
![image](https://github.com/user-attachments/assets/3e52d429-5493-454d-9352-4228a643ce20)


---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -54,6 +54,15 @@
       ""outside_temperature"": {
         ""name"": ""Outside temperature""
       },
+      ""thermostat_water_setpoint"": {
+        ""name"": ""Water target Temperature""

(from reviewer) [2024-10-16T08:15:50Z] ```suggestion
        ""name"": ""Water target temperature""
```

---END THREAD---

(from reviewer) [2024-10-16T09:18:40Z] For completeness also add the sensors to icons.json and then it is good to go @barryvdh 

(from reviewer) [2024-10-16T09:26:24Z] Oh good point, but we should only do that if the default icons don't suffice

(from author) [2024-10-16T09:35:52Z] I added home-thermometer for the room temperatures, and the default thermometer for the water target.

(from reviewer) [2024-10-16T09:38:24Z] Every entity with device class temperature has `mdi:thermometer` as icon. I think there are a few entities that have both the device class and the same icon set now, we could deduplicate that

(from author) [2024-10-16T09:42:18Z] I removed the duplicate ones.

![image](https://github.com/user-attachments/assets/0235ce03-8dcc-4c50-a411-6f9acb21247a)


(from reviewer) [2024-10-16T09:56:51Z] Thanks @barryvdh !",
128432,Allow fetching HA url to display it in the network settings,2024-10-15 09:36:55+00:00,2024-10-30 15:05:58+00:00,merged,2,9,14,https://github.com/home-assistant/core/pull/128432,New feature (which adds functionality to an existing integration),79,2024-10-29T14:28:54Z,network,MindFreeze,"---BEGIN THREAD---
Diff Hunk:
@@ -80,12 +80,15 @@ async def websocket_network_url(
     msg: dict[str, Any],
 ) -> None:
     """"""Get the internal URL.""""""
+    if msg[""url_type""] not in [""internal"", ""external"", ""cloud""]:

(from reviewer) [2024-10-15T13:30:14Z] Maybe add an enum for these strings and use that in the parameter schema with `vol.Coerce`?
(from author) [2024-10-15T14:04:44Z] good idea
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -62,3 +69,28 @@ async def websocket_network_adapters_configure(
         msg[""id""],
         {ATTR_CONFIGURED_ADAPTERS: network.configured_adapters},
     )
+
+
+@websocket_api.require_admin
+@websocket_api.websocket_command(
+    {
+        vol.Required(""type""): ""network/url"",
+        vol.Required(""url_type""): vol.In(URL_TYPES),
+    }
+)
+@websocket_api.async_response
+async def websocket_network_url(
+    hass: HomeAssistant,
+    connection: ActiveConnection,
+    msg: dict[str, Any],
+) -> None:
+    """"""Get the internal URL.""""""
+    connection.send_result(
+        msg[""id""],
+        get_url(

(from reviewer) [2024-10-15T15:31:49Z] Should we make this websocket command a bit more generally useful ? Maybe we can just return all URLs for all situations as a dict?

```
{ ""internal"": ""…"", ""external"": ""…"", ""cloud"": ""…"" }
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -62,3 +69,28 @@ async def websocket_network_adapters_configure(
         msg[""id""],
         {ATTR_CONFIGURED_ADAPTERS: network.configured_adapters},
     )
+
+
+@websocket_api.require_admin
+@websocket_api.websocket_command(
+    {
+        vol.Required(""type""): ""network/url"",

(from reviewer) [2024-10-15T15:32:17Z] I wonder if we shouldn't just include this data in the existing `network` command? We can return adapters, configured adapters and the resolved URLs? 
(from author) [2024-10-16T08:01:39Z] I considered this but urls are handled in a different component in the frontend and it would make loading the data even more complicated
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -30,3 +30,5 @@
         ): vol.Schema(vol.All(cv.ensure_list, [cv.string])),
     }
 )
+
+URL_TYPES: Final = [""internal"", ""external"", ""cloud""]

(from reviewer) [2024-10-16T00:06:43Z] no need to move this into the network helper. Let's keep it around the WS command.
(from reviewer) [2024-10-16T08:40:10Z] Is there a reason to have this as a constant list instead of a string enum?
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -62,3 +65,40 @@ async def websocket_network_adapters_configure(
         msg[""id""],
         {ATTR_CONFIGURED_ADAPTERS: network.configured_adapters},
     )
+
+
+@websocket_api.require_admin

(from reviewer) [2024-10-16T09:10:07Z] ```suggestion
@callback
@websocket_api.require_admin
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -62,3 +65,40 @@ async def websocket_network_adapters_configure(
         msg[""id""],
         {ATTR_CONFIGURED_ADAPTERS: network.configured_adapters},
     )
+
+
+@websocket_api.require_admin
+@websocket_api.websocket_command(
+    {
+        vol.Required(""type""): ""network/url"",
+    }
+)
+@websocket_api.async_response
+async def websocket_network_url(

(from reviewer) [2024-10-16T09:10:31Z] ```suggestion
def websocket_network_url(
```
---END THREAD---

(from author) [2024-10-29T14:00:16Z] Ready to merge. Frontend is approved",
128430,Add WS endpoint to fetch the details of a backup,2024-10-15 08:32:59+00:00,2024-10-16 11:02:01+00:00,merged,3,1,0,https://github.com/home-assistant/core/pull/128430,New feature (which adds functionality to an existing integration),108,2024-10-15T11:00:34Z,backup,ludeeus,"---BEGIN THREAD---
Diff Hunk:
@@ -43,6 +44,30 @@ async def handle_info(
     )
 
 
+@websocket_api.require_admin
+@websocket_api.websocket_command(
+    {
+        vol.Required(""type""): ""backup/details"",
+        vol.Required(""slug""): str,
+    }
+)
+@websocket_api.async_response
+async def handle_details(
+    hass: HomeAssistant,
+    connection: websocket_api.ActiveConnection,
+    msg: dict[str, Any],
+) -> None:
+    """"""Get backup details for a specific slug.""""""
+    manager = hass.data[DATA_MANAGER]
+    backup = await manager.get_backup(msg[""slug""])

(from reviewer) [2024-10-15T08:36:00Z] Single-use variable
```suggestion
    backup = await hass.data[DATA_MANAGER].get_backup(msg[""slug""])
```
---END THREAD---

(from reviewer) [2024-10-15T10:25:00Z] Can be merged when frontend is happy.

(from reviewer) [2024-10-15T10:41:11Z] Looks good 👍 ",
128404,Allow to set `entity picture` on mqtt entity platforms,2024-10-14 22:05:21+00:00,2024-10-28 02:20:40+00:00,merged,13,0,10,https://github.com/home-assistant/core/pull/128404,New feature (which adds functionality to an existing integration),181,2024-10-25T18:16:12Z,mqtt,jbouwh,(from author) [2024-10-25T18:25:22Z] Thanks 👍,
128394,Add support for fetching bindkey from Mi cloud,2024-10-14 20:26:53+00:00,2024-10-23 16:02:27+00:00,merged,3,0,7,https://github.com/home-assistant/core/pull/128394,New feature (which adds functionality to an existing integration),618,2024-10-22T15:53:02Z,xiaomi_ble,bdraco,(from author) [2024-10-22T15:52:59Z] thanks. I'll adjust as needed in a followup if testing shows any changes are needed.,
128381,Updated CONTRIBUTING.md,2024-10-14 18:50:13+00:00,2024-10-15 20:02:01+00:00,closed,1,1,0,https://github.com/home-assistant/core/pull/128381,New integration (thank you!),6,2024-10-14T19:02:51Z,,bhakarboy01,"---BEGIN THREAD---
Diff Hunk:
@@ -1,8 +1,8 @@
-# Contributing to Home Assistant
+<h1> Contributing to Home Assistant </h1>

(from reviewer) [2024-10-14T19:02:27Z] This is a Markdown file…
---END THREAD---",
128380,Update CODE_OF_CONDUCT.md,2024-10-14 18:35:22+00:00,2024-10-15 20:02:00+00:00,closed,1,0,0,https://github.com/home-assistant/core/pull/128380,New feature (which adds functionality to an existing integration),4,2024-10-14T19:05:21Z,,bhakarboy01,,
128365,Add handler to restore a backup file with the backup integration,2024-10-14 13:16:24+00:00,2024-11-02 16:01:45+00:00,merged,13,21,18,https://github.com/home-assistant/core/pull/128365,New feature (which adds functionality to an existing integration),482,2024-11-01T15:25:22Z,backup,ludeeus,"---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,95 @@
+""""""Home Assistant module to handle restoring backups.""""""
+
+import json
+import logging
+import os
+import shutil
+import sys
+from tempfile import TemporaryDirectory
+from typing import TypedDict
+
+import securetar
+
+RESTORE_BACKUP_FILE = "".HA_RESTORE""
+KEEP_PATHS = (""backups"", "".HA_RESTORE"")

(from author) [2024-10-14T13:16:51Z] "".HA_RESTORE"" is only here while testing, this will be removed.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,95 @@
+""""""Home Assistant module to handle restoring backups.""""""
+
+import json
+import logging
+import os
+import shutil
+import sys
+from tempfile import TemporaryDirectory
+from typing import TypedDict
+
+import securetar
+
+RESTORE_BACKUP_FILE = "".HA_RESTORE""
+KEEP_PATHS = (""backups"", "".HA_RESTORE"")
+
+_LOGGER = logging.getLogger(__name__)
+
+
+class RestoreBackupFileContent(TypedDict):

(from author) [2024-10-14T13:17:41Z] The idea is to expand this to also support passwords in a follow-up PR, so while this is not needed as a dict now, it makes future enhancement simpler.
(from reviewer) [2024-10-14T15:26:42Z] I'd make this a dataclass instead.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,95 @@
+""""""Home Assistant module to handle restoring backups.""""""
+
+import json
+import logging
+import os
+import shutil
+import sys
+from tempfile import TemporaryDirectory
+from typing import TypedDict
+
+import securetar
+
+RESTORE_BACKUP_FILE = "".HA_RESTORE""
+KEEP_PATHS = (""backups"", "".HA_RESTORE"")
+
+_LOGGER = logging.getLogger(__name__)
+
+
+class RestoreBackupFileContent(TypedDict):
+    """"""Type definition for restore backup file content.""""""
+
+    backup_file_path: str
+
+
+def restore_backup_file_content(config_dir: str) -> RestoreBackupFileContent | None:
+    """"""Return the contents of the restore backup file.""""""
+    instruction_path = os.path.join(config_dir, RESTORE_BACKUP_FILE)
+    if os.path.exists(instruction_path):
+        with open(instruction_path, encoding=""utf-8"") as file:
+            [backup_file_path, *_] = file.readline().split("";"")
+            return RestoreBackupFileContent(backup_file_path=backup_file_path)
+    return None
+
+
+def _clear_configuration_directory(config_dir: str) -> None:
+    """"""Delete all files and directories in the config directory except for the backups directory.""""""
+    config_contents = sorted(
+        [entry for entry in os.listdir(config_dir) if entry not in KEEP_PATHS]
+    )
+
+    for entry in config_contents:
+        entrypath = os.path.join(config_dir, entry)
+        if os.path.isfile(entrypath):
+            os.remove(entrypath)
+        elif os.path.isdir(entrypath):
+            shutil.rmtree(entrypath)
+
+
+def _extract_backup(config_dir: str, backup_file_path: str) -> None:
+    """"""Extract the backup file to the config directory.""""""
+    with (
+        TemporaryDirectory() as tempdir,
+        securetar.SecureTarFile(
+            backup_file_path,
+            gzip=False,
+            mode=""r"",
+        ) as ostf,
+    ):
+        ostf.extractall(os.path.join(tempdir, ""extracted""))
+        with open(
+            os.path.join(tempdir, ""extracted"", ""backup.json""),
+            encoding=""utf8"",
+        ) as backup_meta_file:
+            backup_meta = json.load(backup_meta_file)
+
+        with securetar.SecureTarFile(
+            os.path.join(
+                tempdir,
+                ""extracted"",
+                f""homeassistant.tar{'.gz' if backup_meta[""compressed""] else ''}"",
+            ),
+            gzip=backup_meta[""compressed""],
+            mode=""r"",
+        ) as istf:
+            for member in istf.getmembers():
+                if member.name == ""data"":
+                    continue
+                member.name = member.name.replace(""data/"", """")

(from author) [2024-10-14T13:18:16Z] Workaround to deal with the fact that the target directory will not be empty.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,96 @@
+""""""Home Assistant module to handle restoring backups.""""""
+
+import json
+import logging
+import os
+import shutil
+import sys
+from tempfile import TemporaryDirectory
+from typing import TypedDict
+
+import securetar
+
+RESTORE_BACKUP_FILE = "".HA_RESTORE""
+KEEP_PATHS = (""backups"", "".HA_RESTORE"")
+
+_LOGGER = logging.getLogger(__name__)
+
+
+class RestoreBackupFileContent(TypedDict):
+    """"""Type definition for restore backup file content.""""""
+
+    backup_file_path: str
+
+
+def restore_backup_file_content(config_dir: str) -> RestoreBackupFileContent | None:
+    """"""Return the contents of the restore backup file.""""""
+    instruction_path = os.path.join(config_dir, RESTORE_BACKUP_FILE)
+    if os.path.exists(instruction_path):
+        with open(instruction_path, encoding=""utf-8"") as file:
+            [backup_file_path, *_] = file.readline().split("";"")
+            return RestoreBackupFileContent(backup_file_path=backup_file_path)

(from reviewer) [2024-10-14T15:29:28Z] ```suggestion
        instruction_content = instruction_path.read_text(encoding=""utf-8"")
        backup_file_path = instruction_content.split("";"")[0]
        return RestoreBackupFileContent(backup_file_path=backup_file_path)
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,96 @@
+""""""Home Assistant module to handle restoring backups.""""""
+
+import json
+import logging
+import os
+import shutil
+import sys
+from tempfile import TemporaryDirectory
+from typing import TypedDict
+
+import securetar
+
+RESTORE_BACKUP_FILE = "".HA_RESTORE""
+KEEP_PATHS = (""backups"", "".HA_RESTORE"")
+
+_LOGGER = logging.getLogger(__name__)
+
+
+class RestoreBackupFileContent(TypedDict):
+    """"""Type definition for restore backup file content.""""""
+
+    backup_file_path: str
+
+
+def restore_backup_file_content(config_dir: str) -> RestoreBackupFileContent | None:
+    """"""Return the contents of the restore backup file.""""""
+    instruction_path = os.path.join(config_dir, RESTORE_BACKUP_FILE)
+    if os.path.exists(instruction_path):

(from reviewer) [2024-10-14T15:30:25Z] ```suggestion
    instruction_path = Path(config_dir, RESTORE_BACKUP_FILE)
    if instruction_path.exists():
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,96 @@
+""""""Home Assistant module to handle restoring backups.""""""
+
+import json
+import logging
+import os
+import shutil

(from reviewer) [2024-10-14T15:31:14Z] ```suggestion
from pathlib import Path
import shutil
```
(from author) [2024-10-14T17:15:26Z] Was included in https://github.com/home-assistant/core/pull/128365/commits/2f9122a8fb1cfaef6fb753badb16b5cb7ac80b07
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,96 @@
+""""""Home Assistant module to handle restoring backups.""""""
+
+import json
+import logging
+import os
+import shutil
+import sys
+from tempfile import TemporaryDirectory
+from typing import TypedDict
+
+import securetar
+
+RESTORE_BACKUP_FILE = "".HA_RESTORE""
+KEEP_PATHS = (""backups"", "".HA_RESTORE"")
+
+_LOGGER = logging.getLogger(__name__)
+
+
+class RestoreBackupFileContent(TypedDict):
+    """"""Type definition for restore backup file content.""""""
+
+    backup_file_path: str
+
+
+def restore_backup_file_content(config_dir: str) -> RestoreBackupFileContent | None:
+    """"""Return the contents of the restore backup file.""""""
+    instruction_path = os.path.join(config_dir, RESTORE_BACKUP_FILE)

(from reviewer) [2024-10-14T15:31:47Z] Try to use `pathlib.Path` as much as possible instead of `os.path` and other related os module APIs. The former is higher level and often easier/nicer to use.

https://docs.python.org/3/library/pathlib.html#corresponding-tools
---END THREAD---

(from author) [2024-10-14T17:16:23Z] Thanks @MartinHjelmare; I _think_ I covered all of them; I left one `os` call (for listdir), because I found that a lot simpler to work with than the Path.walk alternative.

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,107 @@
+""""""Home Assistant module to handle restoring backups.""""""
+
+from dataclasses import dataclass
+import json
+import logging
+import os
+from pathlib import Path
+import shutil
+import sys
+from tempfile import TemporaryDirectory
+
+import securetar
+
+RESTORE_BACKUP_FILE = "".HA_RESTORE""
+KEEP_PATHS = (""backups"", "".HA_RESTORE"")
+
+_LOGGER = logging.getLogger(__name__)
+
+
+@dataclass
+class RestoreBackupFileContent:
+    """"""Definition for restore backup file content.""""""
+
+    backup_file_path: Path
+
+
+def restore_backup_file_content(config_dir: Path) -> RestoreBackupFileContent | None:
+    """"""Return the contents of the restore backup file.""""""
+    instruction_path = config_dir.joinpath(RESTORE_BACKUP_FILE)
+    if instruction_path.exists():
+        instruction_content = instruction_path.read_text(encoding=""utf-8"")
+        return RestoreBackupFileContent(
+            backup_file_path=Path(instruction_content.split("";"")[0])
+        )
+    return None
+
+
+def _clear_configuration_directory(config_dir: Path) -> None:
+    """"""Delete all files and directories in the config directory except for the backups directory.""""""
+    config_contents = sorted(
+        [entry for entry in os.listdir(config_dir) if entry not in KEEP_PATHS]

(from reviewer) [2024-10-14T20:51:52Z] ```suggestion
        [entry for entry in config_dir.iterdir() if entry not in KEEP_PATHS]
```
(from reviewer) [2024-10-14T21:03:29Z] Does this work?

https://docs.python.org/3/library/pathlib.html#pathlib.Path.iterdir
(from author) [2024-10-15T05:36:21Z] It did 👍 
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,107 @@
+""""""Home Assistant module to handle restoring backups.""""""
+
+from dataclasses import dataclass
+import json
+import logging
+import os
+from pathlib import Path
+import shutil
+import sys
+from tempfile import TemporaryDirectory
+
+import securetar
+
+RESTORE_BACKUP_FILE = "".HA_RESTORE""
+KEEP_PATHS = (""backups"", "".HA_RESTORE"")
+
+_LOGGER = logging.getLogger(__name__)
+
+
+@dataclass
+class RestoreBackupFileContent:
+    """"""Definition for restore backup file content.""""""
+
+    backup_file_path: Path
+
+
+def restore_backup_file_content(config_dir: Path) -> RestoreBackupFileContent | None:
+    """"""Return the contents of the restore backup file.""""""
+    instruction_path = config_dir.joinpath(RESTORE_BACKUP_FILE)
+    if instruction_path.exists():
+        instruction_content = instruction_path.read_text(encoding=""utf-8"")
+        return RestoreBackupFileContent(
+            backup_file_path=Path(instruction_content.split("";"")[0])
+        )
+    return None
+
+
+def _clear_configuration_directory(config_dir: Path) -> None:
+    """"""Delete all files and directories in the config directory except for the backups directory.""""""
+    config_contents = sorted(
+        [entry for entry in os.listdir(config_dir) if entry not in KEEP_PATHS]
+    )
+
+    for entry in config_contents:
+        entrypath = config_dir.joinpath(entry)
+        if entrypath.is_file():
+            entrypath.unlink()
+        elif entrypath.is_dir():
+            shutil.rmtree(entrypath)
+
+
+def _extract_backup(config_dir: Path, backup_file_path: Path) -> None:
+    """"""Extract the backup file to the config directory.""""""
+    with (
+        TemporaryDirectory() as tempdir,
+        securetar.SecureTarFile(
+            backup_file_path,
+            gzip=False,
+            mode=""r"",
+        ) as ostf,
+    ):
+        ostf.extractall(Path(tempdir, ""extracted""))
+        with open(
+            Path(tempdir, ""extracted"", ""backup.json""),
+            encoding=""utf8"",
+        ) as backup_meta_file:
+            backup_meta = json.load(backup_meta_file)

(from reviewer) [2024-10-14T20:55:12Z] ```suggestion
        backup_meta_file = Path(tempdir, ""extracted"", ""backup.json"")
        backup_meta = json.loads(backup_meta_file.read_text(encoding=""utf8""))
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -263,6 +264,23 @@ def _mkdir_and_generate_backup_contents(
 
         return tar_file_path.stat().st_size
 
+    async def restore_backup(self, slug: str) -> None:
+        """"""Restore a backup.""""""
+        if (backup := await self.get_backup(slug)) is None:
+            raise HomeAssistantError(f""Backup {slug} not found"")
+
+        def _write_restore_file() -> None:
+            """"""Write the restore file.""""""
+            with open(
+                self.hass.config.path(RESTORE_BACKUP_FILE),
+                mode=""w"",
+                encoding=""utf-8"",
+            ) as restore_fp:
+                restore_fp.write(f""{backup.path.as_posix()};"")

(from reviewer) [2024-10-14T21:01:04Z] ```suggestion
            Path(
                self.hass.config.path(RESTORE_BACKUP_FILE),
            ).write_text(f""{backup.path.as_posix()};"", encoding=""utf-8"")
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,118 @@
+""""""Home Assistant module to handle restoring backups.""""""
+
+from dataclasses import dataclass
+import json
+import logging
+from pathlib import Path
+import shutil
+import sys
+from tempfile import TemporaryDirectory
+
+from awesomeversion import AwesomeVersion
+import securetar
+
+from .const import __version__ as HA_VERSION
+
+RESTORE_BACKUP_FILE = "".HA_RESTORE""
+KEEP_PATHS = (""backups"", "".HA_RESTORE"")
+
+_LOGGER = logging.getLogger(__name__)
+
+
+@dataclass
+class RestoreBackupFileContent:
+    """"""Definition for restore backup file content.""""""
+
+    backup_file_path: Path
+
+
+def restore_backup_file_content(config_dir: Path) -> RestoreBackupFileContent | None:
+    """"""Return the contents of the restore backup file.""""""
+    instruction_path = config_dir.joinpath(RESTORE_BACKUP_FILE)
+    if instruction_path.exists():
+        instruction_content = instruction_path.read_text(encoding=""utf-8"")
+        return RestoreBackupFileContent(
+            backup_file_path=Path(instruction_content.split("";"")[0])
+        )
+    return None
+
+
+def _clear_configuration_directory(config_dir: Path) -> None:
+    """"""Delete all files and directories in the config directory except for the backups directory.""""""
+    keep_paths = [config_dir.joinpath(path) for path in KEEP_PATHS]
+    config_contents = sorted(
+        [entry for entry in config_dir.iterdir() if entry not in keep_paths]
+    )
+
+    for entry in config_contents:
+        entrypath = config_dir.joinpath(entry)
+
+        if entrypath.is_file():
+            entrypath.unlink()
+        elif entrypath.is_dir():
+            shutil.rmtree(entrypath)
+
+
+def _extract_backup(config_dir: Path, backup_file_path: Path) -> None:
+    """"""Extract the backup file to the config directory.""""""
+    with (
+        TemporaryDirectory() as tempdir,
+        securetar.SecureTarFile(
+            backup_file_path,
+            gzip=False,
+            mode=""r"",
+        ) as ostf,
+    ):
+        ostf.extractall(Path(tempdir, ""extracted""))
+        backup_meta_file = Path(tempdir, ""extracted"", ""backup.json"")
+        backup_meta = json.loads(backup_meta_file.read_text(encoding=""utf8""))
+
+        if (
+            backup_meta_version := AwesomeVersion(
+                backup_meta[""homeassistant""][""version""]
+            )
+        ) > HA_VERSION:
+            raise ValueError(
+                f""You need at least Home Assistant version {backup_meta_version} to restore this backup""
+            )
+
+        with securetar.SecureTarFile(
+            Path(
+                tempdir,
+                ""extracted"",
+                f""homeassistant.tar{'.gz' if backup_meta[""compressed""] else ''}"",
+            ),
+            gzip=backup_meta[""compressed""],
+            mode=""r"",
+        ) as istf:
+            for member in istf.getmembers():
+                if member.name == ""data"":
+                    continue
+                member.name = member.name.replace(""data/"", """")
+            _clear_configuration_directory(config_dir)
+            istf.extractall(config_dir)
+
+
+def restore_backup(config_dir_path: str) -> bool:
+    """"""Restore the backup file if any.
+
+    Returns True if a restore backup file was found and restored, False otherwise.
+    """"""
+    config_dir = Path(config_dir_path)
+    if not (restore_content := restore_backup_file_content(config_dir)):
+        return False
+
+    if (
+        not restore_content.backup_file_path.exists()

(from reviewer) [2024-10-16T06:53:19Z] Generally, it's safer to try and open or read from the file and catch `FileNotFoundError` than checking first. The file can be removed after the check so checking doesn't completely safeguard the case that is checked.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,80 @@
+""""""Test methods in backup_restore.""""""
+
+from pathlib import Path
+from unittest import mock
+
+import pytest
+
+from homeassistant import backup_restore
+
+from .common import get_test_config_dir
+
+
+@pytest.mark.parametrize(
+    (""exists"", ""content"", ""expected""),
+    [
+        (False, """", None),
+        (True, """", backup_restore.RestoreBackupFileContent(backup_file_path=Path(""""))),
+        (
+            True,
+            ""test;"",
+            backup_restore.RestoreBackupFileContent(backup_file_path=Path(""test"")),
+        ),
+        (
+            True,
+            ""test;;;;"",
+            backup_restore.RestoreBackupFileContent(backup_file_path=Path(""test"")),
+        ),
+    ],
+)
+def test_reading_the_instruction_contents(
+    exists: bool,
+    content: str,
+    expected: backup_restore.RestoreBackupFileContent | None,
+) -> None:
+    """"""Test reading the content of the .HA_RESTORE file.""""""
+    with (
+        mock.patch(""pathlib.Path.read_text"", return_value=content),
+        mock.patch(""pathlib.Path.exists"", return_value=exists),
+    ):
+        read_content = backup_restore.restore_backup_file_content(
+            Path(get_test_config_dir())
+        )
+        assert read_content == expected
+
+
+def test_restoring_backup_that_does_not_exist() -> None:
+    """"""Test restoring a backup that does not exist.""""""
+    backup_file_path = Path(get_test_config_dir(""backups"", ""test""))
+    with (
+        mock.patch(
+            ""homeassistant.backup_restore.restore_backup_file_content"",
+            return_value=backup_restore.RestoreBackupFileContent(
+                backup_file_path=backup_file_path
+            ),
+        ),
+        mock.patch(""pathlib.Path.exists"", return_value=False),

(from reviewer) [2024-10-21T13:57:38Z] Patch a `Path.read_text` operation instead and set a side effect `FileNotFoundError`.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,113 @@
+""""""Home Assistant module to handle restoring backups.""""""

(from author) [2024-10-29T07:40:33Z] So while the `.HA_RESTORE` file _can_ be manually added, I dont think that is something we should document.
So the documentation requirement of this feature, IMO should not be triggered until this is implemented in the UI, or a service call is added.
---END THREAD---

(from reviewer) [2024-10-29T20:34:07Z] I don't understand the test failure. The test looks ok to me.

(from reviewer) [2024-10-30T14:46:21Z] Why did it matter to move the patch of sys.exit?

(from author) [2024-10-30T15:03:45Z] Because its not actually called directly here, `main()` returns an int (100) which when called as a script its passed to sys.exit

(from reviewer) [2024-10-30T15:09:57Z] Right. Do we still need to patch it then?

(from author) [2024-10-30T15:13:57Z] It seems like it, but I do not see why yet.
Currently working on testing the actual restoring, will look more at this one once that is done

(from author) [2024-10-31T18:44:58Z] It exited with code 2 (pytest exit because of user interruption), due to ""wrong arguments"",  this commit <https://github.com/home-assistant/core/pull/128365/commits/8771a8c34d7e12e39f1b46f7de48731c20dc0487> solved that.

---BEGIN THREAD---
Diff Hunk:
@@ -34,8 +35,11 @@ def test_reading_the_instruction_contents(
 ) -> None:
     """"""Test reading the content of the .HA_RESTORE file.""""""
     with (
-        mock.patch(""pathlib.Path.read_text"", return_value=content),
-        mock.patch(""pathlib.Path.exists"", return_value=exists),
+        mock.patch(
+            ""pathlib.Path.read_text"",
+            return_value=content,
+            side_effect=FileNotFoundError if not exists else None,

(from reviewer) [2024-11-01T11:11:43Z] I'd change the test parameters instead to be the return value and side effect or just the side effect, to avoid encoding logic to the parameter.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -78,3 +93,128 @@ def test_restoring_backup_that_is_not_a_file() -> None:
         ),
     ):
         assert backup_restore.restore_backup(Path(get_test_config_dir())) is False
+
+
+def test_aborting_for_older_versions() -> None:
+    """"""Test that we abort for older versions.""""""
+    config_dir = Path(get_test_config_dir())
+    backup_file_path = Path(config_dir, ""backups"", ""test.tar"")
+
+    def _patched_path_read_text(path: Path, **kwargs):
+        return '{""homeassistant"": {""version"": ""9999.99.99""}, ""compressed"": false}'
+
+    with (
+        mock.patch(
+            ""homeassistant.backup_restore.restore_backup_file_content"",
+            return_value=backup_restore.RestoreBackupFileContent(
+                backup_file_path=backup_file_path
+            ),
+        ),
+        mock.patch(""securetar.SecureTarFile""),
+        mock.patch(""homeassistant.backup_restore.TemporaryDirectory""),
+        mock.patch(""pathlib.Path.read_text"", _patched_path_read_text),
+        mock.patch(""homeassistant.backup_restore.HA_VERSION"", ""2013.09.17""),
+        pytest.raises(
+            ValueError,
+            match=""You need at least Home Assistant version 9999.99.99 to restore this backup"",
+        ),
+    ):
+        assert backup_restore.restore_backup(config_dir) is True
+
+
+def test_removal_of_current_configuration_when_restoring() -> None:
+    """"""Test that we are removing the current configuration directory.""""""
+    config_dir = Path(get_test_config_dir())
+    backup_file_path = Path(config_dir, ""backups"", ""test.tar"")
+    mock_config_dir = [
+        {""path"": Path(config_dir, "".HA_RESTORE""), ""is_file"": True},
+        {""path"": Path(config_dir, "".HA_VERSION""), ""is_file"": True},
+        {""path"": Path(config_dir, ""backups""), ""is_file"": False},
+        {""path"": Path(config_dir, ""www""), ""is_file"": False},
+    ]
+
+    def _patched_path_read_text(path: Path, **kwargs):
+        return '{""homeassistant"": {""version"": ""2013.09.17""}, ""compressed"": false}'
+
+    def _patched_path_is_file(path: Path, **kwargs):
+        return [x for x in mock_config_dir if x[""path""] == path][0][""is_file""]
+
+    def _patched_path_is_dir(path: Path, **kwargs):
+        return not [x for x in mock_config_dir if x[""path""] == path][0][""is_file""]
+
+    with (
+        mock.patch(
+            ""homeassistant.backup_restore.restore_backup_file_content"",
+            return_value=backup_restore.RestoreBackupFileContent(
+                backup_file_path=backup_file_path
+            ),
+        ),
+        mock.patch(""securetar.SecureTarFile""),
+        mock.patch(""homeassistant.backup_restore.TemporaryDirectory""),
+        mock.patch(""homeassistant.backup_restore.HA_VERSION"", ""2013.09.17""),
+        mock.patch(""pathlib.Path.read_text"", _patched_path_read_text),
+        mock.patch(""pathlib.Path.is_file"", _patched_path_is_file),
+        mock.patch(""pathlib.Path.is_dir"", _patched_path_is_dir),
+        mock.patch(
+            ""pathlib.Path.iterdir"",
+            return_value=[x[""path""] for x in mock_config_dir],
+        ),
+        mock.patch(""pathlib.Path.unlink"") as unlinkmock,
+        mock.patch(""shutil.rmtree"") as rmtreemock,
+    ):
+        assert backup_restore.restore_backup(config_dir) is True
+        assert unlinkmock.call_count == 2
+        assert (
+            rmtreemock.call_count == 1
+        )  # We have 2 directories in the config directory, but backups is kept
+
+        removed_directories = {Path(call.args[0]) for call in rmtreemock.mock_calls}
+        assert removed_directories == {Path(config_dir, ""www"")}
+
+
+def test_extracting_the_contents_of_a_backup_file() -> None:
+    """"""Test extracting the contents of a backup file.""""""
+    config_dir = Path(get_test_config_dir())
+    backup_file_path = Path(config_dir, ""backups"", ""test.tar"")
+
+    def _patched_path_read_text(path: Path, **kwargs):
+        return '{""homeassistant"": {""version"": ""2013.09.17""}, ""compressed"": false}'
+
+    getmembersmock = mock.MagicMock(

(from reviewer) [2024-11-01T11:13:31Z] ```suggestion
    getmembers_mock = mock.MagicMock(
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -78,3 +93,128 @@ def test_restoring_backup_that_is_not_a_file() -> None:
         ),
     ):
         assert backup_restore.restore_backup(Path(get_test_config_dir())) is False
+
+
+def test_aborting_for_older_versions() -> None:
+    """"""Test that we abort for older versions.""""""
+    config_dir = Path(get_test_config_dir())
+    backup_file_path = Path(config_dir, ""backups"", ""test.tar"")
+
+    def _patched_path_read_text(path: Path, **kwargs):
+        return '{""homeassistant"": {""version"": ""9999.99.99""}, ""compressed"": false}'
+
+    with (
+        mock.patch(
+            ""homeassistant.backup_restore.restore_backup_file_content"",
+            return_value=backup_restore.RestoreBackupFileContent(
+                backup_file_path=backup_file_path
+            ),
+        ),
+        mock.patch(""securetar.SecureTarFile""),
+        mock.patch(""homeassistant.backup_restore.TemporaryDirectory""),
+        mock.patch(""pathlib.Path.read_text"", _patched_path_read_text),
+        mock.patch(""homeassistant.backup_restore.HA_VERSION"", ""2013.09.17""),
+        pytest.raises(
+            ValueError,
+            match=""You need at least Home Assistant version 9999.99.99 to restore this backup"",
+        ),
+    ):
+        assert backup_restore.restore_backup(config_dir) is True
+
+
+def test_removal_of_current_configuration_when_restoring() -> None:
+    """"""Test that we are removing the current configuration directory.""""""
+    config_dir = Path(get_test_config_dir())
+    backup_file_path = Path(config_dir, ""backups"", ""test.tar"")
+    mock_config_dir = [
+        {""path"": Path(config_dir, "".HA_RESTORE""), ""is_file"": True},
+        {""path"": Path(config_dir, "".HA_VERSION""), ""is_file"": True},
+        {""path"": Path(config_dir, ""backups""), ""is_file"": False},
+        {""path"": Path(config_dir, ""www""), ""is_file"": False},
+    ]
+
+    def _patched_path_read_text(path: Path, **kwargs):
+        return '{""homeassistant"": {""version"": ""2013.09.17""}, ""compressed"": false}'
+
+    def _patched_path_is_file(path: Path, **kwargs):
+        return [x for x in mock_config_dir if x[""path""] == path][0][""is_file""]
+
+    def _patched_path_is_dir(path: Path, **kwargs):
+        return not [x for x in mock_config_dir if x[""path""] == path][0][""is_file""]
+
+    with (
+        mock.patch(
+            ""homeassistant.backup_restore.restore_backup_file_content"",
+            return_value=backup_restore.RestoreBackupFileContent(
+                backup_file_path=backup_file_path
+            ),
+        ),
+        mock.patch(""securetar.SecureTarFile""),
+        mock.patch(""homeassistant.backup_restore.TemporaryDirectory""),
+        mock.patch(""homeassistant.backup_restore.HA_VERSION"", ""2013.09.17""),
+        mock.patch(""pathlib.Path.read_text"", _patched_path_read_text),
+        mock.patch(""pathlib.Path.is_file"", _patched_path_is_file),
+        mock.patch(""pathlib.Path.is_dir"", _patched_path_is_dir),
+        mock.patch(
+            ""pathlib.Path.iterdir"",
+            return_value=[x[""path""] for x in mock_config_dir],
+        ),
+        mock.patch(""pathlib.Path.unlink"") as unlinkmock,
+        mock.patch(""shutil.rmtree"") as rmtreemock,
+    ):
+        assert backup_restore.restore_backup(config_dir) is True
+        assert unlinkmock.call_count == 2
+        assert (
+            rmtreemock.call_count == 1
+        )  # We have 2 directories in the config directory, but backups is kept
+
+        removed_directories = {Path(call.args[0]) for call in rmtreemock.mock_calls}
+        assert removed_directories == {Path(config_dir, ""www"")}
+
+
+def test_extracting_the_contents_of_a_backup_file() -> None:
+    """"""Test extracting the contents of a backup file.""""""
+    config_dir = Path(get_test_config_dir())
+    backup_file_path = Path(config_dir, ""backups"", ""test.tar"")
+
+    def _patched_path_read_text(path: Path, **kwargs):
+        return '{""homeassistant"": {""version"": ""2013.09.17""}, ""compressed"": false}'
+
+    getmembersmock = mock.MagicMock(
+        return_value=[
+            tarfile.TarInfo(name=""data""),
+            tarfile.TarInfo(name=""data/../test""),
+            tarfile.TarInfo(name=""data/.HA_VERSION""),
+            tarfile.TarInfo(name=""data/.storage""),
+            tarfile.TarInfo(name=""data/www""),
+        ]
+    )
+    extractallmock = mock.MagicMock()

(from reviewer) [2024-11-01T11:14:06Z] ```suggestion
    extractall_mock = mock.MagicMock()
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -78,3 +93,128 @@ def test_restoring_backup_that_is_not_a_file() -> None:
         ),
     ):
         assert backup_restore.restore_backup(Path(get_test_config_dir())) is False
+
+
+def test_aborting_for_older_versions() -> None:
+    """"""Test that we abort for older versions.""""""
+    config_dir = Path(get_test_config_dir())
+    backup_file_path = Path(config_dir, ""backups"", ""test.tar"")
+
+    def _patched_path_read_text(path: Path, **kwargs):
+        return '{""homeassistant"": {""version"": ""9999.99.99""}, ""compressed"": false}'
+
+    with (
+        mock.patch(
+            ""homeassistant.backup_restore.restore_backup_file_content"",
+            return_value=backup_restore.RestoreBackupFileContent(
+                backup_file_path=backup_file_path
+            ),
+        ),
+        mock.patch(""securetar.SecureTarFile""),
+        mock.patch(""homeassistant.backup_restore.TemporaryDirectory""),
+        mock.patch(""pathlib.Path.read_text"", _patched_path_read_text),
+        mock.patch(""homeassistant.backup_restore.HA_VERSION"", ""2013.09.17""),
+        pytest.raises(
+            ValueError,
+            match=""You need at least Home Assistant version 9999.99.99 to restore this backup"",
+        ),
+    ):
+        assert backup_restore.restore_backup(config_dir) is True
+
+
+def test_removal_of_current_configuration_when_restoring() -> None:
+    """"""Test that we are removing the current configuration directory.""""""
+    config_dir = Path(get_test_config_dir())
+    backup_file_path = Path(config_dir, ""backups"", ""test.tar"")
+    mock_config_dir = [
+        {""path"": Path(config_dir, "".HA_RESTORE""), ""is_file"": True},
+        {""path"": Path(config_dir, "".HA_VERSION""), ""is_file"": True},
+        {""path"": Path(config_dir, ""backups""), ""is_file"": False},
+        {""path"": Path(config_dir, ""www""), ""is_file"": False},
+    ]
+
+    def _patched_path_read_text(path: Path, **kwargs):
+        return '{""homeassistant"": {""version"": ""2013.09.17""}, ""compressed"": false}'
+
+    def _patched_path_is_file(path: Path, **kwargs):
+        return [x for x in mock_config_dir if x[""path""] == path][0][""is_file""]
+
+    def _patched_path_is_dir(path: Path, **kwargs):
+        return not [x for x in mock_config_dir if x[""path""] == path][0][""is_file""]
+
+    with (
+        mock.patch(
+            ""homeassistant.backup_restore.restore_backup_file_content"",
+            return_value=backup_restore.RestoreBackupFileContent(
+                backup_file_path=backup_file_path
+            ),
+        ),
+        mock.patch(""securetar.SecureTarFile""),
+        mock.patch(""homeassistant.backup_restore.TemporaryDirectory""),
+        mock.patch(""homeassistant.backup_restore.HA_VERSION"", ""2013.09.17""),
+        mock.patch(""pathlib.Path.read_text"", _patched_path_read_text),
+        mock.patch(""pathlib.Path.is_file"", _patched_path_is_file),
+        mock.patch(""pathlib.Path.is_dir"", _patched_path_is_dir),
+        mock.patch(
+            ""pathlib.Path.iterdir"",
+            return_value=[x[""path""] for x in mock_config_dir],
+        ),
+        mock.patch(""pathlib.Path.unlink"") as unlinkmock,

(from reviewer) [2024-11-01T11:15:11Z] ```suggestion
        mock.patch(""pathlib.Path.unlink"") as unlink_mock,
```
---END THREAD---",
128361,New syntax for all template entities,2024-10-14 13:11:50+00:00,2024-10-15 23:01:56+00:00,closed,3,0,0,https://github.com/home-assistant/core/pull/128361,New feature (which adds functionality to an existing integration),142,2024-10-14T22:07:59Z,template,tetele,"(from reviewer) [2024-10-14T15:21:53Z] I'd recommend doing one platform per PR.

(from author) [2024-10-14T22:07:59Z] Closing this and moving to per-platform PRs, as per Martin's suggestion",
128357,Add reconfigure flow to ring integration,2024-10-14 12:29:48+00:00,2024-10-28 12:02:28+00:00,merged,3,4,7,https://github.com/home-assistant/core/pull/128357,New feature (which adds functionality to an existing integration),163,2024-10-21T13:30:05Z,ring,sdb9696,"---BEGIN THREAD---
Diff Hunk:
@@ -183,19 +189,58 @@ async def async_step_reauth_confirm(
                     CONF_TOKEN: token,
                     CONF_DEVICE_ID: self.hardware_id,
                 }
-                self.hass.config_entries.async_update_entry(
-                    self.reauth_entry, data=data
-                )
-                await self.hass.config_entries.async_reload(self.reauth_entry.entry_id)
-                return self.async_abort(reason=""reauth_successful"")
+                return self.async_update_reload_and_abort(reauth_entry, data=data)
 
         return self.async_show_form(
             step_id=""reauth_confirm"",
             data_schema=STEP_REAUTH_DATA_SCHEMA,
             errors=errors,
             description_placeholders={
-                CONF_USERNAME: self.reauth_entry.data[CONF_USERNAME],
-                CONF_NAME: self.reauth_entry.data[CONF_USERNAME],
+                CONF_USERNAME: reauth_entry.data[CONF_USERNAME],
+                CONF_NAME: reauth_entry.data[CONF_USERNAME],
+            },
+        )
+
+    async def async_step_reconfigure(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""Trigger a reconfiguration flow.""""""
+        errors: dict[str, str] = {}
+        reconfigure_entry = self._get_reconfigure_entry()
+        entry_data = reconfigure_entry.data
+        username = entry_data[CONF_USERNAME]
+        await self.async_set_unique_id(username)
+        if user_input:
+            user_input[CONF_USERNAME] = username
+            # Reconfigure will generate a new hardware id and create a new
+            # authorised device at ring.com.
+            if not self.hardware_id:
+                self.hardware_id = str(uuid.uuid4())
+            try:
+                assert self.hardware_id
+                token = await validate_input(self.hass, self.hardware_id, user_input)
+            except Require2FA:
+                self.user_pass = user_input
+                return await self.async_step_2fa()
+            except InvalidAuth:
+                errors[""base""] = ""invalid_auth""
+            except Exception:
+                _LOGGER.exception(""Unexpected exception"")
+                errors[""base""] = ""unknown""
+            else:
+                data = {
+                    CONF_USERNAME: user_input[CONF_USERNAME],

(from reviewer) [2024-10-20T22:01:31Z] ```suggestion
                    CONF_USERNAME: username,
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -183,19 +189,58 @@ async def async_step_reauth_confirm(
                     CONF_TOKEN: token,
                     CONF_DEVICE_ID: self.hardware_id,
                 }
-                self.hass.config_entries.async_update_entry(
-                    self.reauth_entry, data=data
-                )
-                await self.hass.config_entries.async_reload(self.reauth_entry.entry_id)
-                return self.async_abort(reason=""reauth_successful"")
+                return self.async_update_reload_and_abort(reauth_entry, data=data)
 
         return self.async_show_form(
             step_id=""reauth_confirm"",
             data_schema=STEP_REAUTH_DATA_SCHEMA,
             errors=errors,
             description_placeholders={
-                CONF_USERNAME: self.reauth_entry.data[CONF_USERNAME],
-                CONF_NAME: self.reauth_entry.data[CONF_USERNAME],
+                CONF_USERNAME: reauth_entry.data[CONF_USERNAME],
+                CONF_NAME: reauth_entry.data[CONF_USERNAME],
+            },
+        )
+
+    async def async_step_reconfigure(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""Trigger a reconfiguration flow.""""""
+        errors: dict[str, str] = {}
+        reconfigure_entry = self._get_reconfigure_entry()
+        entry_data = reconfigure_entry.data
+        username = entry_data[CONF_USERNAME]
+        await self.async_set_unique_id(username)
+        if user_input:
+            user_input[CONF_USERNAME] = username
+            # Reconfigure will generate a new hardware id and create a new
+            # authorised device at ring.com.
+            if not self.hardware_id:
+                self.hardware_id = str(uuid.uuid4())
+            try:
+                assert self.hardware_id
+                token = await validate_input(self.hass, self.hardware_id, user_input)
+            except Require2FA:
+                self.user_pass = user_input
+                return await self.async_step_2fa()
+            except InvalidAuth:
+                errors[""base""] = ""invalid_auth""
+            except Exception:
+                _LOGGER.exception(""Unexpected exception"")
+                errors[""base""] = ""unknown""
+            else:
+                data = {
+                    CONF_USERNAME: user_input[CONF_USERNAME],
+                    CONF_TOKEN: token,
+                    CONF_DEVICE_ID: self.hardware_id,
+                }
+                return self.async_update_reload_and_abort(reconfigure_entry, data=data)
+
+        return self.async_show_form(
+            step_id=""reconfigure"",
+            data_schema=STEP_RECONFIGURE_DATA_SCHEMA,
+            errors=errors,
+            description_placeholders={
+                CONF_USERNAME: entry_data[CONF_USERNAME],

(from reviewer) [2024-10-20T22:02:56Z] ```suggestion
                CONF_USERNAME: username,
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -183,19 +189,58 @@ async def async_step_reauth_confirm(
                     CONF_TOKEN: token,
                     CONF_DEVICE_ID: self.hardware_id,
                 }
-                self.hass.config_entries.async_update_entry(
-                    self.reauth_entry, data=data
-                )
-                await self.hass.config_entries.async_reload(self.reauth_entry.entry_id)
-                return self.async_abort(reason=""reauth_successful"")
+                return self.async_update_reload_and_abort(reauth_entry, data=data)
 
         return self.async_show_form(
             step_id=""reauth_confirm"",
             data_schema=STEP_REAUTH_DATA_SCHEMA,
             errors=errors,
             description_placeholders={
-                CONF_USERNAME: self.reauth_entry.data[CONF_USERNAME],
-                CONF_NAME: self.reauth_entry.data[CONF_USERNAME],
+                CONF_USERNAME: reauth_entry.data[CONF_USERNAME],
+                CONF_NAME: reauth_entry.data[CONF_USERNAME],
+            },
+        )
+
+    async def async_step_reconfigure(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""Trigger a reconfiguration flow.""""""
+        errors: dict[str, str] = {}
+        reconfigure_entry = self._get_reconfigure_entry()
+        entry_data = reconfigure_entry.data
+        username = entry_data[CONF_USERNAME]

(from reviewer) [2024-10-20T22:03:18Z] ```suggestion
        username = reconfigure_entry.data[CONF_USERNAME]
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -308,3 +308,102 @@ async def test_dhcp_discovery(
     )
     assert result[""type""] is FlowResultType.ABORT
     assert result[""reason""] == ""already_configured""
+
+
+async def test_reconfigure(
+    hass: HomeAssistant,
+    mock_setup_entry: AsyncMock,
+    mock_ring_client: Mock,
+    mock_added_config_entry: MockConfigEntry,
+) -> None:
+    """"""Test the reconfigure config flow.""""""
+
+    assert mock_added_config_entry.data[CONF_DEVICE_ID] == MOCK_HARDWARE_ID
+
+    result = await mock_added_config_entry.start_reconfigure_flow(hass)
+
+    assert result[""type""] is FlowResultType.FORM
+    assert result[""step_id""] == ""reconfigure""
+
+    with patch(""uuid.uuid4"", return_value=""new-hardware-id""):
+        result2 = await hass.config_entries.flow.async_configure(
+            result[""flow_id""],
+            {""password"": ""test-password""},
+        )
+        await hass.async_block_till_done()
+
+    assert result2[""type""] is FlowResultType.ABORT
+    assert result2[""reason""] == ""reconfigure_successful""
+    assert mock_added_config_entry.data[CONF_DEVICE_ID] == ""new-hardware-id""
+
+
+@pytest.mark.parametrize(
+    (""error_type"", ""errors_msg""),
+    [
+        (ring_doorbell.AuthenticationError, ""invalid_auth""),
+        (Exception, ""unknown""),
+    ],
+    ids=[""invalid-auth"", ""unknown-error""],
+)
+async def test_reconfigure_errors(
+    hass: HomeAssistant,
+    mock_added_config_entry: MockConfigEntry,
+    mock_setup_entry: AsyncMock,
+    mock_ring_auth: Mock,
+    error_type,
+    errors_msg,
+) -> None:
+    """"""Testerrors during the reconfigure config flow.""""""

(from reviewer) [2024-10-21T13:19:43Z] ```suggestion
    """"""Test errors during the reconfigure config flow.""""""
```
---END THREAD---",
128324,Add port to config flow of P1 Monitor integration,2024-10-14 00:20:38+00:00,2024-10-17 19:02:02+00:00,merged,10,0,2,https://github.com/home-assistant/core/pull/128324,New feature (which adds functionality to an existing integration),148,2024-10-16T17:40:20Z,p1_monitor,klaasnicolaas,,
128308,Add light support to WMS WebControl pro,2024-10-13 18:25:34+00:00,2024-10-26 17:02:06+00:00,merged,7,4,11,https://github.com/home-assistant/core/pull/128308,New feature (which adds functionality to an existing integration),392,2024-10-25T16:20:40Z,wmspro,mback2k,"---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,205 @@
+""""""Test the wmspro cover support.""""""
+
+from unittest.mock import AsyncMock, patch
+
+from syrupy import SnapshotAssertion
+
+from homeassistant.components.light import ATTR_BRIGHTNESS
+from homeassistant.components.wmspro.const import DOMAIN
+from homeassistant.const import (
+    ATTR_ENTITY_ID,
+    SERVICE_TURN_OFF,
+    SERVICE_TURN_ON,
+    Platform,
+)
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers import device_registry as dr
+from homeassistant.setup import async_setup_component
+
+from . import setup_config_entry
+
+from tests.common import MockConfigEntry
+
+
+async def test_light_device(
+    hass: HomeAssistant,
+    mock_config_entry: MockConfigEntry,
+    mock_hub_ping: AsyncMock,
+    mock_hub_configuration_prod: AsyncMock,
+    mock_hub_status_prod_dimmer: AsyncMock,
+    device_registry: dr.DeviceRegistry,
+    snapshot: SnapshotAssertion,
+) -> None:
+    """"""Test that a light device is created correctly.""""""
+    assert await setup_config_entry(hass, mock_config_entry)
+    assert len(mock_hub_ping.mock_calls) == 1
+    assert len(mock_hub_configuration_prod.mock_calls) == 1
+    assert len(mock_hub_status_prod_dimmer.mock_calls) == 2
+
+    device_entry = device_registry.async_get_device(identifiers={(DOMAIN, ""97358"")})
+    assert device_entry is not None
+    assert device_entry == snapshot
+
+
+async def test_light_update(
+    hass: HomeAssistant,
+    mock_config_entry: MockConfigEntry,
+    mock_hub_ping: AsyncMock,
+    mock_hub_configuration_prod: AsyncMock,
+    mock_hub_status_prod_dimmer: AsyncMock,
+    snapshot: SnapshotAssertion,
+) -> None:
+    """"""Test that a light entity is created and updated correctly.""""""
+    assert await setup_config_entry(hass, mock_config_entry)
+    assert len(mock_hub_ping.mock_calls) == 1
+    assert len(mock_hub_configuration_prod.mock_calls) == 1
+    assert len(mock_hub_status_prod_dimmer.mock_calls) == 2
+
+    entity = hass.states.get(""light.licht"")
+    assert entity is not None
+    assert entity == snapshot
+
+    await async_setup_component(hass, ""homeassistant"", {})
+    await hass.services.async_call(
+        ""homeassistant"",
+        ""update_entity"",
+        {ATTR_ENTITY_ID: entity.entity_id},
+        blocking=True,
+    )

(from reviewer) [2024-10-13T19:32:10Z] Please don't use the update entity service for this, rather let the entity naturally update, for example with either freezing and skipping time or by calling a callback function fetched from a mock
(from author) [2024-10-13T20:08:01Z] Time skipping it is, thanks for the hint!
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,205 @@
+""""""Test the wmspro cover support.""""""
+
+from unittest.mock import AsyncMock, patch
+
+from syrupy import SnapshotAssertion
+
+from homeassistant.components.light import ATTR_BRIGHTNESS
+from homeassistant.components.wmspro.const import DOMAIN
+from homeassistant.const import (
+    ATTR_ENTITY_ID,
+    SERVICE_TURN_OFF,
+    SERVICE_TURN_ON,
+    Platform,
+)
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers import device_registry as dr
+from homeassistant.setup import async_setup_component
+
+from . import setup_config_entry
+
+from tests.common import MockConfigEntry
+
+
+async def test_light_device(
+    hass: HomeAssistant,
+    mock_config_entry: MockConfigEntry,
+    mock_hub_ping: AsyncMock,
+    mock_hub_configuration_prod: AsyncMock,
+    mock_hub_status_prod_dimmer: AsyncMock,
+    device_registry: dr.DeviceRegistry,
+    snapshot: SnapshotAssertion,
+) -> None:
+    """"""Test that a light device is created correctly.""""""
+    assert await setup_config_entry(hass, mock_config_entry)
+    assert len(mock_hub_ping.mock_calls) == 1
+    assert len(mock_hub_configuration_prod.mock_calls) == 1
+    assert len(mock_hub_status_prod_dimmer.mock_calls) == 2
+
+    device_entry = device_registry.async_get_device(identifiers={(DOMAIN, ""97358"")})
+    assert device_entry is not None
+    assert device_entry == snapshot
+
+
+async def test_light_update(
+    hass: HomeAssistant,
+    mock_config_entry: MockConfigEntry,
+    mock_hub_ping: AsyncMock,
+    mock_hub_configuration_prod: AsyncMock,
+    mock_hub_status_prod_dimmer: AsyncMock,
+    snapshot: SnapshotAssertion,
+) -> None:
+    """"""Test that a light entity is created and updated correctly.""""""
+    assert await setup_config_entry(hass, mock_config_entry)
+    assert len(mock_hub_ping.mock_calls) == 1
+    assert len(mock_hub_configuration_prod.mock_calls) == 1
+    assert len(mock_hub_status_prod_dimmer.mock_calls) == 2
+
+    entity = hass.states.get(""light.licht"")
+    assert entity is not None
+    assert entity == snapshot
+
+    await async_setup_component(hass, ""homeassistant"", {})
+    await hass.services.async_call(
+        ""homeassistant"",
+        ""update_entity"",
+        {ATTR_ENTITY_ID: entity.entity_id},
+        blocking=True,
+    )
+
+    assert len(mock_hub_status_prod_dimmer.mock_calls) == 3
+
+
+async def test_light_turn_on_and_off(
+    hass: HomeAssistant,
+    mock_config_entry: MockConfigEntry,
+    mock_hub_ping: AsyncMock,
+    mock_hub_configuration_prod: AsyncMock,
+    mock_hub_status_prod_dimmer: AsyncMock,
+    mock_action_call: AsyncMock,
+) -> None:
+    """"""Test that a light entity is turned on and off correctly.""""""
+    assert await setup_config_entry(hass, mock_config_entry)
+    assert len(mock_hub_ping.mock_calls) == 1
+    assert len(mock_hub_configuration_prod.mock_calls) == 1
+    assert len(mock_hub_status_prod_dimmer.mock_calls) >= 1
+
+    entity = hass.states.get(""light.licht"")
+    assert entity is not None
+    assert entity.state == ""off""
+    assert entity.attributes[""brightness""] is None
+
+    with patch(
+        ""wmspro.destination.Destination.refresh"",
+        return_value=True,
+    ):
+        before = len(mock_hub_status_prod_dimmer.mock_calls)
+
+        await hass.services.async_call(
+            Platform.LIGHT,
+            SERVICE_TURN_ON,
+            {ATTR_ENTITY_ID: entity.entity_id},
+            blocking=True,
+        )
+
+        entity = hass.states.get(""light.licht"")
+        assert entity is not None
+        assert entity.state == ""on""
+        assert entity.attributes[""brightness""] >= 1
+        assert len(mock_hub_status_prod_dimmer.mock_calls) == before
+
+    with patch(
+        ""wmspro.destination.Destination.refresh"",
+        return_value=True,
+    ):
+        before = len(mock_hub_status_prod_dimmer.mock_calls)
+
+        await hass.services.async_call(
+            Platform.LIGHT,
+            SERVICE_TURN_OFF,
+            {ATTR_ENTITY_ID: entity.entity_id},
+            blocking=True,
+        )
+
+        entity = hass.states.get(""light.licht"")
+        assert entity is not None
+        assert entity.state == ""off""
+        assert entity.attributes[""brightness""] is None
+        assert len(mock_hub_status_prod_dimmer.mock_calls) == before
+
+
+async def test_light_dimm_on_and_off(
+    hass: HomeAssistant,
+    mock_config_entry: MockConfigEntry,
+    mock_hub_ping: AsyncMock,
+    mock_hub_configuration_prod: AsyncMock,
+    mock_hub_status_prod_dimmer: AsyncMock,
+    mock_action_call: AsyncMock,
+) -> None:
+    """"""Test that a light entity is dimmed on and off correctly.""""""
+    assert await setup_config_entry(hass, mock_config_entry)
+    assert len(mock_hub_ping.mock_calls) == 1
+    assert len(mock_hub_configuration_prod.mock_calls) == 1
+    assert len(mock_hub_status_prod_dimmer.mock_calls) >= 1
+
+    entity = hass.states.get(""light.licht"")
+    assert entity is not None
+    assert entity.state == ""off""
+    assert entity.attributes[""brightness""] is None
+
+    with patch(
+        ""wmspro.destination.Destination.refresh"",
+        return_value=True,
+    ):
+        before = len(mock_hub_status_prod_dimmer.mock_calls)
+
+        await hass.services.async_call(
+            Platform.LIGHT,
+            SERVICE_TURN_ON,
+            {ATTR_ENTITY_ID: entity.entity_id},
+            blocking=True,
+        )
+
+        entity = hass.states.get(""light.licht"")
+        assert entity is not None
+        assert entity.state == ""on""
+        assert entity.attributes[""brightness""] >= 1
+        assert len(mock_hub_status_prod_dimmer.mock_calls) == before
+
+    with patch(
+        ""wmspro.destination.Destination.refresh"",
+        return_value=True,
+    ):
+        before = len(mock_hub_status_prod_dimmer.mock_calls)
+
+        await hass.services.async_call(
+            Platform.LIGHT,
+            SERVICE_TURN_ON,
+            {ATTR_ENTITY_ID: entity.entity_id, ATTR_BRIGHTNESS: 128},
+            blocking=True,
+        )
+
+        entity = hass.states.get(""light.licht"")
+        assert entity is not None
+        assert entity.state == ""on""
+        assert entity.attributes[""brightness""] == 128

(from reviewer) [2024-10-13T19:32:46Z] ```suggestion
        assert entity.state == STATE_ON
        assert entity.attributes[ATTR_BRIGHTNESS] == 128
```
Please apply this to the whole file :)
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,206 @@
+""""""Test the wmspro cover support.""""""

(from reviewer) [2024-10-25T16:16:30Z] ```suggestion
""""""Test the wmspro light support.""""""
```
---END THREAD---

(from author) [2024-10-25T16:35:12Z] Thanks a lot!",
128296,Add missing state_class to sensors in solarlog,2024-10-13 13:08:03+00:00,2024-10-26 08:03:17+00:00,merged,2,0,11,https://github.com/home-assistant/core/pull/128296,New feature (which adds functionality to an existing integration),53,2024-10-25T07:32:56Z,solarlog,dontinelli,,
128295,Add missing state_class for sensors in solarlog,2024-10-13 13:03:28+00:00,2024-10-14 14:04:56+00:00,closed,2,0,0,https://github.com/home-assistant/core/pull/128295,New feature (which adds functionality to an existing integration),53,2024-10-13T13:06:40Z,solarlog,dontinelli,(from author) [2024-10-13T13:06:30Z] @home-assistant add-label new-feature,
128292,Add lighting effects to Hue lights managed by deCONZ,2024-10-13 12:35:53+00:00,2024-10-20 08:06:29+00:00,merged,3,6,5,https://github.com/home-assistant/core/pull/128292,New feature (which adds functionality to an existing integration),46,2024-10-19T07:09:01Z,deconz,hanskroner,"---BEGIN THREAD---
Diff Hunk:
@@ -208,6 +223,15 @@ def __init__(self, device: _LightDeviceT, hub: DeconzHub) -> None:
         if device.effect is not None:
             self._attr_supported_features |= LightEntityFeature.EFFECT
             self._attr_effect_list = [EFFECT_COLORLOOP]
+
+            # For lights that report supported effects.
+            if isinstance(self._device, Light):
+                light = cast(Light, device)
+                if light.supported_effects is not None:
+                    self._attr_effect_list = [
+                        el.value for el in light.supported_effects
+                    ]

(from reviewer) [2024-10-14T06:30:30Z] ```suggestion
            if isinstance(device, Light):
                if device.supported_effects is not None:
                    self._attr_effect_list = [
                        el.value for el in light.supported_effects
                    ]
```
If you use the same object all the time you can probably get away with removing a couple of steps.

You will need to use the keys in EFFECT_TO_DECONZ 
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -208,6 +223,13 @@ def __init__(self, device: _LightDeviceT, hub: DeconzHub) -> None:
         if device.effect is not None:
             self._attr_supported_features |= LightEntityFeature.EFFECT
             self._attr_effect_list = [EFFECT_COLORLOOP]
+
+            # For lights that report supported effects.
+            if isinstance(device, Light) and device.supported_effects is not None:
+                self._attr_effect_list = [
+                    EFFECT_TO_DECONZ[el.value] for el in device.supported_effects
+                ]

(from reviewer) [2024-10-15T19:08:54Z] What if EFFECT_TO_DECONZ doesn't contain a newer value supported by deconz?
Also the LightEffect is a StrEnum so shouldn't need to use el.value here
```suggestion
                    EFFECT_TO_DECONZ[el] for el in device.supported_effects
                    if el in EFFECT_TO_DECONZ
                ]
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -208,6 +223,15 @@ def __init__(self, device: _LightDeviceT, hub: DeconzHub) -> None:
         if device.effect is not None:
             self._attr_supported_features |= LightEntityFeature.EFFECT
             self._attr_effect_list = [EFFECT_COLORLOOP]
+
+            # For lights that report supported effects.
+            if isinstance(device, Light) and device.supported_effects is not None:
+                self._attr_effect_list = [
+                    EFFECT_TO_DECONZ[el]
+                    for el in device.supported_effects
+                    if el in EFFECT_TO_DECONZ
+                ]
+
             if device.model_id in (""HG06467"", ""TS0601""):
                 self._attr_effect_list = XMAS_LIGHT_EFFECTS

(from reviewer) [2024-10-18T15:17:29Z] As there is now logic to identify a light lets move everything in behind that check
```suggestion
            if isinstance(device, Light):
                if device.supported_effects is not None:
                    self._attr_effect_list = [
                        EFFECT_TO_DECONZ[el]
                        for el in device.supported_effects
                        if el in EFFECT_TO_DECONZ
                    ]

                if device.model_id in (""HG06467"", ""TS0601""):
                    self._attr_effect_list = XMAS_LIGHT_EFFECTS
```
(from author) [2024-10-18T17:09:53Z] Done!
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -39,7 +39,22 @@
 DECONZ_GROUP = ""is_deconz_group""
 EFFECT_TO_DECONZ = {
     EFFECT_COLORLOOP: LightEffect.COLOR_LOOP,
-    ""None"": LightEffect.NONE,
+    ""none"": LightEffect.NONE,

(from reviewer) [2024-10-18T15:18:16Z] Why did you change this to `""none""`?
(from author) [2024-10-18T17:15:18Z] The deCONZ REST API uses lowercase, so it reports `none`. That's also what pydeconz returns from `supported_effects`.
---END THREAD---",
128287,Add translatable title to history_stats,2024-10-13 11:22:01+00:00,2024-10-14 13:06:56+00:00,merged,2,0,0,https://github.com/home-assistant/core/pull/128287,New feature (which adds functionality to an existing integration),3,2024-10-13T12:33:12Z,history_stats,gjohansson-ST,,
128286,Add translatable title to statistics,2024-10-13 11:19:05+00:00,2024-10-14 13:06:53+00:00,merged,2,0,0,https://github.com/home-assistant/core/pull/128286,New feature (which adds functionality to an existing integration),3,2024-10-13T12:37:57Z,statistics,gjohansson-ST,,
128259,Palazzetti integration,2024-10-12 18:56:12+00:00,2024-10-29 17:02:03+00:00,merged,19,112,15,https://github.com/home-assistant/core/pull/128259,New integration (thank you!),897,2024-10-28T16:19:06Z,palazzetti,dotvav,"(from author) [2024-10-12T19:46:00Z] Not sure about the 2 failed checks:
* The license audit is failing for palazzetti-sdk-local-api, its github page mentions the MIT license
* The tests that fail don't seem to be related to my changes

(from reviewer) [2024-10-12T20:51:39Z] It looks like it's failing because the MIT license isn't present in [`setup.py`](https://github.com/marcopal74/palazzetti_local_api/blob/main/setup.py).

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,33 @@
+""""""The Palazzetti integration.""""""
+
+from __future__ import annotations
+
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import Platform
+from homeassistant.core import HomeAssistant
+
+from .const import DOMAIN
+from .coordinator import PalazzettiDataUpdateCoordinator
+
+PLATFORMS: list[Platform] = [Platform.CLIMATE]
+
+
+async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
+    """"""Set up Palazzetti from a config entry.""""""
+
+    hass.data.setdefault(DOMAIN, {})
+    coordinator = PalazzettiDataUpdateCoordinator(hass, entry)
+    hass.data.setdefault(DOMAIN, {})
+    hass.data[DOMAIN][entry.entry_id] = coordinator

(from reviewer) [2024-10-14T12:25:23Z] ```suggestion
    hass.data.setdefault(DOMAIN, {})
    hass.data[DOMAIN][entry.entry_id] = coordinator
```
use `entry.runtime_data` instead
(from author) [2024-10-16T16:30:30Z] Thanks, addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,33 @@
+""""""The Palazzetti integration.""""""
+
+from __future__ import annotations
+
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import Platform
+from homeassistant.core import HomeAssistant
+
+from .const import DOMAIN
+from .coordinator import PalazzettiDataUpdateCoordinator
+
+PLATFORMS: list[Platform] = [Platform.CLIMATE]
+
+
+async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
+    """"""Set up Palazzetti from a config entry.""""""
+
+    hass.data.setdefault(DOMAIN, {})
+    coordinator = PalazzettiDataUpdateCoordinator(hass, entry)
+    hass.data.setdefault(DOMAIN, {})
+    hass.data[DOMAIN][entry.entry_id] = coordinator
+
+    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)
+
+    return True
+
+
+async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
+    """"""Unload a config entry.""""""
+    if unload_ok := await hass.config_entries.async_unload_platforms(entry, PLATFORMS):
+        hass.data[DOMAIN].pop(entry.entry_id)

(from reviewer) [2024-10-14T12:26:00Z] ```suggestion
    await hass.config_entries.async_unload_platforms(entry, PLATFORMS):
```
not needed if switching to runtime_data
(from author) [2024-10-16T16:30:39Z] Thanks, addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,164 @@
+""""""Support for Palazzetti climates.""""""
+
+from typing import Any, cast
+
+from palazzetti_sdk_local_api.exceptions import InvalidStateTransitionError
+
+from homeassistant.components.climate import (
+    ClimateEntity,
+    ClimateEntityFeature,
+    HVACMode,
+)
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import ATTR_TEMPERATURE, UnitOfTemperature
+from homeassistant.core import HomeAssistant, callback
+from homeassistant.exceptions import ServiceValidationError
+from homeassistant.helpers.device_registry import DeviceInfo
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.helpers.update_coordinator import CoordinatorEntity
+
+from .const import (
+    ACTION_NOT_UNAVAILABLE,
+    API_HW_VERSION,
+    API_NAME,
+    API_SW_VERSION,
+    AVAILABLE,
+    DOMAIN,
+    FAN_AUTO,
+    FAN_HIGH,
+    FAN_MODE,
+    FAN_MODES,
+    FAN_SILENT,
+    HEATING_STATUSES,
+    MAC,
+    MODE,
+    PALAZZETTI,
+    ROOM_TEMPERATURE,
+    TARGET_TEMPERATURE,
+)
+from .coordinator import PalazzettiDataUpdateCoordinator
+
+
+async def async_setup_entry(
+    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
+) -> None:
+    """"""Set up Palazzetti climates based on a config entry.""""""
+    coordinator: PalazzettiDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]
+    entities: list[PalazzettiClimateEntity] = []
+    await coordinator.async_config_entry_first_refresh()

(from reviewer) [2024-10-14T12:26:23Z] better to do that in `init` instead
(from author) [2024-10-15T08:15:25Z] Not sure I get that. Can I await an async call in `init`? I'll look into it.
(from reviewer) [2024-10-15T08:47:38Z] Sorry, meant `__init__.py` in setup_entry
(from author) [2024-10-16T16:30:55Z] Got it. Addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,84 @@
+""""""Helpers to help coordinate updates.""""""
+
+from typing import TypedDict
+
+from palazzetti_sdk_local_api import Hub
+
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator
+
+from .const import (
+    API_EXHAUST_TEMPERATURE,
+    API_FAN_MODE,
+    API_MODE,
+    API_OUTPUT_TEMPERATURE,
+    API_PELLET_QUANTITY,
+    API_ROOM_TEMPERATURE,
+    API_TARGET_TEMPERATURE,
+    AVAILABLE,
+    DOMAIN,
+    EXHAUST_TEMPERATURE,
+    FAN_MODE,
+    HOST,
+    LOGGER,
+    MODE,
+    OUTPUT_TEMPERATURE,
+    PELLET_QUANTITY,
+    ROOM_TEMPERATURE,
+    SCAN_INTERVAL,
+    TARGET_TEMPERATURE,
+)
+
+
+class PalazzettiData(TypedDict):
+    """"""Class for defining data in dict.""""""
+
+    available: bool
+    mode: int
+    target_temperature: int
+    room_temperature: float
+    output_temperature: float
+    exhaust_temperature: float
+    pellet_quantity: int
+    fan_mode: int
+
+
+class PalazzettiDataUpdateCoordinator(DataUpdateCoordinator[PalazzettiData]):
+    """"""Class to manage fetching Palazzetti data from a Palazzetti hub.""""""
+
+    entry: ConfigEntry
+    hub: Hub
+
+    def __init__(self, hass: HomeAssistant, entry: ConfigEntry) -> None:
+        """"""Initialize global Palazzetti data updater.""""""
+        super().__init__(
+            hass,
+            LOGGER,
+            name=DOMAIN,
+            update_interval=SCAN_INTERVAL,
+        )
+        self.entry = entry
+        self.hub = Hub(host=entry.data[HOST], isbiocc=False)
+
+    async def _async_update_data(self) -> PalazzettiData:
+        """"""Fetch data from Palazzetti.""""""
+        await self.hub.async_update(discovery=True, deep=True)

(from reviewer) [2024-10-14T12:28:15Z] can we maybe instead `try:` here? This should throw some errors probably
(from author) [2024-10-16T16:31:06Z] Thanks, addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,24 @@
+{
+  ""config"": {
+    ""step"": {
+      ""user"": {
+        ""description"": ""Enter the host name or the ip address of the Palazzetti CBox"",

(from reviewer) [2024-10-14T12:30:35Z] ```suggestion
        ""description"": ""Enter the host name or the IP address of the Palazzetti CBox"",
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,14 @@
+{
+  ""domain"": ""palazzetti"",
+  ""name"": ""Palazzetti"",
+  ""codeowners"": [""@dotvav""],
+  ""config_flow"": true,
+  ""dependencies"": [],

(from reviewer) [2024-10-14T12:30:50Z] remove empty keys
(from author) [2024-10-16T16:31:25Z] Thanks, addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,94 @@
+""""""Constants for the Palazzetti integration.""""""
+
+from datetime import timedelta
+import logging
+from typing import Final
+
+DOMAIN: Final = ""palazzetti""
+PALAZZETTI: Final = ""Palazzetti""
+LOGGER = logging.getLogger(__package__)
+SCAN_INTERVAL = timedelta(seconds=5)
+ACTION_NOT_UNAVAILABLE = ""action_not_available""
+
+API_NAME: Final = ""LABEL""
+API_HOST: Final = ""IP""
+API_MAC: Final = ""MAC""
+API_TARGET_TEMPERATURE: Final = ""SETP""
+API_ROOM_TEMPERATURE: Final = ""T1""
+API_OUTPUT_TEMPERATURE: Final = ""T2""
+API_EXHAUST_TEMPERATURE: Final = ""T3""
+API_PELLET_QUANTITY: Final = ""PQT""
+API_FAN_MODE: Final = ""F2L""
+API_MODE: Final = ""LSTATUS""
+API_HW_VERSION: Final = ""SYSTEM""
+API_SW_VERSION: Final = ""plzbridge""
+
+HUB: Final = ""hub""
+NAME: Final = ""name""
+HOST: Final = ""host""
+MAC: Final = ""mac""
+AVAILABLE: Final = ""available""
+TARGET_TEMPERATURE: Final = ""target_temperature""
+ROOM_TEMPERATURE: Final = ""room_temperature""
+OUTPUT_TEMPERATURE: Final = ""output_temperature""
+EXHAUST_TEMPERATURE: Final = ""exhaust_temperature""
+PELLET_QUANTITY: Final = ""pellet_quantity""
+FAN_MODE: Final = ""fan_mode""
+MODE: Final = ""mode""
+
+STATUSES: Final = {
+    0: ""OFF"",
+    1: ""OFF_TIMER"",
+    2: ""TESTFIRE"",
+    3: ""HEATUP"",
+    4: ""FUELING"",
+    5: ""IGNTEST"",
+    6: ""BURNING"",
+    7: ""BURNINGMOD"",
+    8: ""UNKNOWN"",
+    9: ""COOLFLUID"",
+    10: ""FIRESTOP"",
+    11: ""CLEANFIRE"",
+    12: ""COOL"",
+    50: ""CLEANUP"",
+    51: ""ECOMODE"",
+    241: ""CHIMNEY_ALARM"",
+    243: ""GRATE_ERROR"",
+    244: ""PELLET_WATER_ERROR"",
+    245: ""T05_ERROR"",
+    247: ""HATCH_DOOR_OPEN"",
+    248: ""PRESSURE_ERROR"",
+    249: ""MAIN_PROBE_FAILURE"",
+    250: ""FLUE_PROBE_FAILURE"",
+    252: ""EXHAUST_TEMP_HIGH"",
+    253: ""PELLET_FINISHED"",
+    501: ""OFF"",
+    502: ""FUELING"",
+    503: ""IGNTEST"",
+    504: ""BURNING"",
+    505: ""FIREWOOD_FINISHED"",
+    506: ""COOLING"",
+    507: ""CLEANFIRE"",
+    1000: ""GENERAL_ERROR"",
+    1001: ""GENERAL_ERROR"",
+    1239: ""DOOR_OPEN"",
+    1240: ""TEMP_TOO_HIGH"",
+    1241: ""CLEANING_WARNING"",
+    1243: ""FUEL_ERROR"",
+    1244: ""PELLET_WATER_ERROR"",
+    1245: ""T05_ERROR"",
+    1247: ""HATCH_DOOR_OPEN"",
+    1248: ""PRESSURE_ERROR"",
+    1249: ""MAIN_PROBE_FAILURE"",
+    1250: ""FLUE_PROBE_FAILURE"",
+    1252: ""EXHAUST_TEMP_HIGH"",
+    1253: ""PELLET_FINISHED"",
+    1508: ""GENERAL_ERROR"",
+}
+
+HEATING_STATUSES = [2, 3, 4, 5, 6, 7, 51, 502, 503, 504]

(from reviewer) [2024-10-14T12:31:25Z] belongs in the lib
(from author) [2024-10-16T16:31:33Z] Thanks, addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,56 @@
+""""""Config flow for Palazzetti.""""""
+
+from typing import Any
+
+from palazzetti_sdk_local_api import Hub
+import voluptuous as vol
+
+from homeassistant import config_entries
+from homeassistant.config_entries import ConfigFlowResult
+from homeassistant.const import CONF_HOST
+from homeassistant.helpers import device_registry as dr
+
+from .const import API_MAC, API_NAME, DOMAIN, HOST, MAC, NAME, PALAZZETTI
+
+
+class PalazzettiConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
+    """"""Palazzetti config flow.""""""
+
+    VERSION = 1
+    MINOR_VERSION = 1

(from reviewer) [2024-10-14T12:31:51Z] ```suggestion
```
is default
(from author) [2024-10-16T16:33:29Z] Thanks, addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,56 @@
+""""""Config flow for Palazzetti.""""""
+
+from typing import Any
+
+from palazzetti_sdk_local_api import Hub
+import voluptuous as vol
+
+from homeassistant import config_entries
+from homeassistant.config_entries import ConfigFlowResult
+from homeassistant.const import CONF_HOST
+from homeassistant.helpers import device_registry as dr
+
+from .const import API_MAC, API_NAME, DOMAIN, HOST, MAC, NAME, PALAZZETTI
+
+
+class PalazzettiConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
+    """"""Palazzetti config flow.""""""
+
+    VERSION = 1
+    MINOR_VERSION = 1
+
+    async def async_step_user(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""User confiiguration step.""""""
+        if user_input is None:
+            return self.async_show_form(
+                step_id=""user"", data_schema=vol.Schema({vol.Required(CONF_HOST): str})
+            )
+
+        host = user_input[CONF_HOST]
+        hub = Hub(host=host, isbiocc=False)
+        await hub.async_update(discovery=False, deep=False)

(from reviewer) [2024-10-14T12:32:08Z] can't this throw?
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,56 @@
+""""""Config flow for Palazzetti.""""""
+
+from typing import Any
+
+from palazzetti_sdk_local_api import Hub
+import voluptuous as vol
+
+from homeassistant import config_entries
+from homeassistant.config_entries import ConfigFlowResult
+from homeassistant.const import CONF_HOST
+from homeassistant.helpers import device_registry as dr
+
+from .const import API_MAC, API_NAME, DOMAIN, HOST, MAC, NAME, PALAZZETTI
+
+
+class PalazzettiConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):
+    """"""Palazzetti config flow.""""""
+
+    VERSION = 1
+    MINOR_VERSION = 1
+
+    async def async_step_user(
+        self, user_input: dict[str, Any] | None = None
+    ) -> ConfigFlowResult:
+        """"""User confiiguration step.""""""
+        if user_input is None:
+            return self.async_show_form(
+                step_id=""user"", data_schema=vol.Schema({vol.Required(CONF_HOST): str})
+            )
+
+        host = user_input[CONF_HOST]
+        hub = Hub(host=host, isbiocc=False)
+        await hub.async_update(discovery=False, deep=False)
+
+        attributes = hub.get_attributes()
+
+        if API_MAC not in attributes:
+            return self.async_show_form(
+                step_id=""user"",
+                data_schema=vol.Schema({vol.Required(CONF_HOST): str}),
+                errors={""base"": ""invalid_host""},
+            )
+        formatted_mac = dr.format_mac(attributes[API_MAC])
+        device_unique_id = formatted_mac
+
+        # Assign a unique ID to the flow
+        await self.async_set_unique_id(device_unique_id)
+
+        # Abort the flow if a config entry with the same unique ID exists
+        self._abort_if_unique_id_configured()
+
+        name = attributes.get(API_NAME, PALAZZETTI)
+        return self.async_create_entry(
+            title=name,
+            data={NAME: name, HOST: host, MAC: formatted_mac},

(from reviewer) [2024-10-14T12:35:11Z] I'd suggest to use the `CONF_` prefixed versions from central `const` instead
(from author) [2024-10-16T16:31:41Z] Thanks, addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,64 @@
+""""""Test the Palazzetti config flow.""""""
+
+from unittest.mock import patch
+
+from homeassistant.components.palazzetti.const import DOMAIN
+from homeassistant.config_entries import SOURCE_USER
+from homeassistant.const import CONF_HOST
+from homeassistant.core import HomeAssistant
+from homeassistant.data_entry_flow import FlowResultType
+
+
+async def test_full_user_flow(hass: HomeAssistant) -> None:
+    """"""Test the full user configuration flow.""""""
+    result = await hass.config_entries.flow.async_init(
+        DOMAIN, context={""source"": SOURCE_USER}
+    )
+
+    assert result.get(""type"") is FlowResultType.FORM
+    assert result.get(""step_id"") == ""user""

(from reviewer) [2024-10-14T12:37:00Z] ```suggestion
    assert result[""type""] is FlowResultType.FORM
    assert result[""step_id""]== ""user""
```
avoid `get` here
(from author) [2024-10-16T16:31:48Z] Thanks, addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,64 @@
+""""""Test the Palazzetti config flow.""""""
+
+from unittest.mock import patch
+
+from homeassistant.components.palazzetti.const import DOMAIN
+from homeassistant.config_entries import SOURCE_USER
+from homeassistant.const import CONF_HOST
+from homeassistant.core import HomeAssistant
+from homeassistant.data_entry_flow import FlowResultType
+
+
+async def test_full_user_flow(hass: HomeAssistant) -> None:
+    """"""Test the full user configuration flow.""""""
+    result = await hass.config_entries.flow.async_init(
+        DOMAIN, context={""source"": SOURCE_USER}
+    )
+
+    assert result.get(""type"") is FlowResultType.FORM
+    assert result.get(""step_id"") == ""user""
+
+    with (
+        patch(
+            ""homeassistant.components.palazzetti.config_flow.Hub.async_update"",
+            return_value=None,
+        ) as mock_async_update,
+        patch(
+            ""homeassistant.components.palazzetti.config_flow.Hub.get_attributes"",
+            return_value={""MAC"": ""11:22:33:44:55:66""},
+        ) as mock_get_attributes,
+        patch(
+            ""homeassistant.components.palazzetti.async_setup_entry"", return_value=True
+        ) as mock_setup_entry,
+    ):
+        result2 = await hass.config_entries.flow.async_configure(
+            result[""flow_id""],
+            user_input={CONF_HOST: ""192.168.1.1""},
+        )
+
+    assert result2.get(""type"") is FlowResultType.CREATE_ENTRY

(from reviewer) [2024-10-14T12:37:21Z] same
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,164 @@
+""""""Support for Palazzetti climates.""""""
+
+from typing import Any, cast
+
+from palazzetti_sdk_local_api.exceptions import InvalidStateTransitionError
+
+from homeassistant.components.climate import (
+    ClimateEntity,
+    ClimateEntityFeature,
+    HVACMode,
+)
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import ATTR_TEMPERATURE, UnitOfTemperature
+from homeassistant.core import HomeAssistant, callback
+from homeassistant.exceptions import ServiceValidationError
+from homeassistant.helpers.device_registry import DeviceInfo
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.helpers.update_coordinator import CoordinatorEntity
+
+from .const import (
+    ACTION_NOT_UNAVAILABLE,
+    API_HW_VERSION,
+    API_NAME,
+    API_SW_VERSION,
+    AVAILABLE,
+    DOMAIN,
+    FAN_AUTO,
+    FAN_HIGH,
+    FAN_MODE,
+    FAN_MODES,
+    FAN_SILENT,
+    HEATING_STATUSES,
+    MAC,
+    MODE,
+    PALAZZETTI,
+    ROOM_TEMPERATURE,
+    TARGET_TEMPERATURE,
+)
+from .coordinator import PalazzettiDataUpdateCoordinator
+
+
+async def async_setup_entry(
+    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
+) -> None:
+    """"""Set up Palazzetti climates based on a config entry.""""""
+    coordinator: PalazzettiDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]
+    entities: list[PalazzettiClimateEntity] = []
+    await coordinator.async_config_entry_first_refresh()
+    if coordinator.data[AVAILABLE]:
+        entities.append(PalazzettiClimateEntity(coordinator=coordinator))
+        async_add_entities(entities)
+
+
+class PalazzettiClimateEntity(
+    CoordinatorEntity[PalazzettiDataUpdateCoordinator], ClimateEntity
+):
+    """"""Defines a Palazzetti climate.""""""
+
+    _attr_has_entity_name = True
+    _attr_hvac_modes = []  # The available modes will be set when we know the current state
+    _attr_fan_modes = FAN_MODES
+    _attr_target_temperature_step = 1.0
+    _attr_temperature_unit = UnitOfTemperature.CELSIUS
+    _attr_translation_key = DOMAIN
+
+    def __init__(
+        self,
+        *,
+        coordinator: PalazzettiDataUpdateCoordinator,
+    ) -> None:
+        """"""Initialize Palazzetti climate.""""""
+        super().__init__(coordinator=coordinator)
+        self.hub = coordinator.hub
+
+        # TURN_OFF and TURN_ON are not always available. An update coordinator listener will add them when possible.
+        self._attr_supported_features = (
+            ClimateEntityFeature.TARGET_TEMPERATURE | ClimateEntityFeature.FAN_MODE
+        )
+        coordinator.async_add_listener(self._coordinator_update)

(from reviewer) [2024-10-14T12:40:42Z] ```suggestion
        config_entry.async_on_unload(coordinator.async_add_listener(self._coordinator_update))
```
make sure it's removed
(from author) [2024-10-16T16:32:25Z] I removed the listener in the new revision. Using properties directly instead.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,164 @@
+""""""Support for Palazzetti climates.""""""
+
+from typing import Any, cast
+
+from palazzetti_sdk_local_api.exceptions import InvalidStateTransitionError
+
+from homeassistant.components.climate import (
+    ClimateEntity,
+    ClimateEntityFeature,
+    HVACMode,
+)
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import ATTR_TEMPERATURE, UnitOfTemperature
+from homeassistant.core import HomeAssistant, callback
+from homeassistant.exceptions import ServiceValidationError
+from homeassistant.helpers.device_registry import DeviceInfo
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.helpers.update_coordinator import CoordinatorEntity
+
+from .const import (
+    ACTION_NOT_UNAVAILABLE,
+    API_HW_VERSION,
+    API_NAME,
+    API_SW_VERSION,
+    AVAILABLE,
+    DOMAIN,
+    FAN_AUTO,
+    FAN_HIGH,
+    FAN_MODE,
+    FAN_MODES,
+    FAN_SILENT,
+    HEATING_STATUSES,
+    MAC,
+    MODE,
+    PALAZZETTI,
+    ROOM_TEMPERATURE,
+    TARGET_TEMPERATURE,
+)
+from .coordinator import PalazzettiDataUpdateCoordinator
+
+
+async def async_setup_entry(
+    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
+) -> None:
+    """"""Set up Palazzetti climates based on a config entry.""""""
+    coordinator: PalazzettiDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]
+    entities: list[PalazzettiClimateEntity] = []
+    await coordinator.async_config_entry_first_refresh()
+    if coordinator.data[AVAILABLE]:
+        entities.append(PalazzettiClimateEntity(coordinator=coordinator))
+        async_add_entities(entities)
+
+
+class PalazzettiClimateEntity(
+    CoordinatorEntity[PalazzettiDataUpdateCoordinator], ClimateEntity
+):
+    """"""Defines a Palazzetti climate.""""""
+
+    _attr_has_entity_name = True
+    _attr_hvac_modes = []  # The available modes will be set when we know the current state
+    _attr_fan_modes = FAN_MODES
+    _attr_target_temperature_step = 1.0
+    _attr_temperature_unit = UnitOfTemperature.CELSIUS
+    _attr_translation_key = DOMAIN
+
+    def __init__(
+        self,
+        *,
+        coordinator: PalazzettiDataUpdateCoordinator,
+    ) -> None:
+        """"""Initialize Palazzetti climate.""""""
+        super().__init__(coordinator=coordinator)
+        self.hub = coordinator.hub
+
+        # TURN_OFF and TURN_ON are not always available. An update coordinator listener will add them when possible.
+        self._attr_supported_features = (
+            ClimateEntityFeature.TARGET_TEMPERATURE | ClimateEntityFeature.FAN_MODE
+        )
+        coordinator.async_add_listener(self._coordinator_update)
+
+        name = self.hub.product.response_json[API_NAME]
+        self._attr_unique_id = coordinator.entry.data[MAC]
+        self._attr_device_info = DeviceInfo(
+            identifiers={(DOMAIN, coordinator.entry.data[MAC])},
+            name=PALAZZETTI,
+            manufacturer=PALAZZETTI,
+            sw_version=self.hub.product.response_json[API_SW_VERSION],
+            hw_version=self.hub.product.response_json[API_HW_VERSION],
+        )
+        self._attr_name = name
+
+    @callback
+    def _coordinator_update(self) -> None:
+        available = (
+            self.coordinator.data[""available""]
+            and self.hub
+            and self.hub.hub_online
+            and self.hub.product
+            and self.hub.product_online
+        )
+        self._attr_available = available

(from reviewer) [2024-10-14T12:43:12Z] can we move that code to the `available` property
(from author) [2024-10-16T16:32:39Z] Addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,164 @@
+""""""Support for Palazzetti climates.""""""
+
+from typing import Any, cast
+
+from palazzetti_sdk_local_api.exceptions import InvalidStateTransitionError
+
+from homeassistant.components.climate import (
+    ClimateEntity,
+    ClimateEntityFeature,
+    HVACMode,
+)
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import ATTR_TEMPERATURE, UnitOfTemperature
+from homeassistant.core import HomeAssistant, callback
+from homeassistant.exceptions import ServiceValidationError
+from homeassistant.helpers.device_registry import DeviceInfo
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.helpers.update_coordinator import CoordinatorEntity
+
+from .const import (
+    ACTION_NOT_UNAVAILABLE,
+    API_HW_VERSION,
+    API_NAME,
+    API_SW_VERSION,
+    AVAILABLE,
+    DOMAIN,
+    FAN_AUTO,
+    FAN_HIGH,
+    FAN_MODE,
+    FAN_MODES,
+    FAN_SILENT,
+    HEATING_STATUSES,
+    MAC,
+    MODE,
+    PALAZZETTI,
+    ROOM_TEMPERATURE,
+    TARGET_TEMPERATURE,
+)
+from .coordinator import PalazzettiDataUpdateCoordinator
+
+
+async def async_setup_entry(
+    hass: HomeAssistant, entry: ConfigEntry, async_add_entities: AddEntitiesCallback
+) -> None:
+    """"""Set up Palazzetti climates based on a config entry.""""""
+    coordinator: PalazzettiDataUpdateCoordinator = hass.data[DOMAIN][entry.entry_id]
+    entities: list[PalazzettiClimateEntity] = []
+    await coordinator.async_config_entry_first_refresh()
+    if coordinator.data[AVAILABLE]:
+        entities.append(PalazzettiClimateEntity(coordinator=coordinator))
+        async_add_entities(entities)
+
+
+class PalazzettiClimateEntity(
+    CoordinatorEntity[PalazzettiDataUpdateCoordinator], ClimateEntity
+):
+    """"""Defines a Palazzetti climate.""""""
+
+    _attr_has_entity_name = True
+    _attr_hvac_modes = []  # The available modes will be set when we know the current state
+    _attr_fan_modes = FAN_MODES
+    _attr_target_temperature_step = 1.0
+    _attr_temperature_unit = UnitOfTemperature.CELSIUS
+    _attr_translation_key = DOMAIN
+
+    def __init__(
+        self,
+        *,
+        coordinator: PalazzettiDataUpdateCoordinator,
+    ) -> None:
+        """"""Initialize Palazzetti climate.""""""
+        super().__init__(coordinator=coordinator)
+        self.hub = coordinator.hub
+
+        # TURN_OFF and TURN_ON are not always available. An update coordinator listener will add them when possible.
+        self._attr_supported_features = (
+            ClimateEntityFeature.TARGET_TEMPERATURE | ClimateEntityFeature.FAN_MODE
+        )
+        coordinator.async_add_listener(self._coordinator_update)
+
+        name = self.hub.product.response_json[API_NAME]
+        self._attr_unique_id = coordinator.entry.data[MAC]
+        self._attr_device_info = DeviceInfo(
+            identifiers={(DOMAIN, coordinator.entry.data[MAC])},
+            name=PALAZZETTI,
+            manufacturer=PALAZZETTI,
+            sw_version=self.hub.product.response_json[API_SW_VERSION],
+            hw_version=self.hub.product.response_json[API_HW_VERSION],
+        )
+        self._attr_name = name
+
+    @callback
+    def _coordinator_update(self) -> None:
+        available = (
+            self.coordinator.data[""available""]
+            and self.hub
+            and self.hub.hub_online
+            and self.hub.product
+            and self.hub.product_online
+        )
+        self._attr_available = available
+        if available:
+            if self.hub.product.get_data_config_object().flag_has_switch_on_off:
+                self._attr_supported_features |= (
+                    ClimateEntityFeature.TURN_OFF | ClimateEntityFeature.TURN_ON
+                )
+                self._attr_hvac_modes = [HVACMode.OFF, HVACMode.HEAT]
+            else:
+                self._attr_supported_features &= ~(
+                    ClimateEntityFeature.TURN_OFF | ClimateEntityFeature.TURN_ON
+                )
+                self._attr_hvac_modes = [self.hvac_mode]

(from reviewer) [2024-10-14T12:44:14Z] I think I'd prefer the properties here as well for readability
(from author) [2024-10-16T16:33:11Z] Addressed in the new revision.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,40 @@
+""""""The Palazzetti integration.""""""
+
+from __future__ import annotations
+
+from pypalazzetti.exceptions import CommunicationError, ValidationError
+
+from homeassistant.config_entries import ConfigEntry
+from homeassistant.const import Platform
+from homeassistant.core import HomeAssistant
+from homeassistant.exceptions import ConfigEntryError
+
+from .const import DOMAIN
+from .coordinator import PalazzettiDataUpdateCoordinator
+
+PLATFORMS: list[Platform] = [Platform.CLIMATE]
+
+
+async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
+    """"""Set up Palazzetti from a config entry.""""""
+
+    hass.data.setdefault(DOMAIN, {})
+    coordinator = PalazzettiDataUpdateCoordinator(hass, entry)
+    try:
+        await coordinator.palazzetti.connect()
+        await coordinator.palazzetti.update_state()
+    except (CommunicationError, ValidationError) as err:
+        raise ConfigEntryError(
+            err, translation_domain=DOMAIN, translation_key=""invalid_host""
+        ) from err

(from reviewer) [2024-10-16T18:31:23Z] Why would it be an invalid host?
---END THREAD---

(from author) [2024-10-19T16:39:06Z] @zweckj @joostlek I think I have addressed all your comments.

(from reviewer) [2024-10-28T15:05:05Z] Aight, I pulled the code and I fixed the last things. You now will have translated fan modes, better tests (I removed the other example, I think airgradient isn't the best example anymore, but in that case I have 2 different devices and then we have something different to test, which is different from the same but different data) and a test for the device",
128248,Add calendar platform to Habitica integration,2024-10-12 16:24:04+00:00,2024-10-31 04:02:39+00:00,merged,12,78,17,https://github.com/home-assistant/core/pull/128248,New feature (which adds functionality to an existing integration),1198,2024-10-30T03:53:49Z,habitica,tr4nt0r,"---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,261 @@
+""""""Calendar platform for Habitica integration.""""""
+
+from __future__ import annotations
+
+from datetime import datetime, time, timedelta
+from enum import StrEnum
+
+from homeassistant.components.calendar import (
+    CalendarEntity,
+    CalendarEntityDescription,
+    CalendarEvent,
+)
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.util import dt as dt_util
+
+from . import HabiticaConfigEntry
+from .coordinator import HabiticaDataUpdateCoordinator
+from .entity import HabiticaBase
+from .types import HabiticaTaskType
+from .util import build_rrule, to_date
+
+
+class HabiticaCalendar(StrEnum):
+    """"""Habitica calendars.""""""
+
+    DAILIES = ""dailys""
+    TODOS = ""todos""
+    REMINDERS = ""reminders""
+
+
+async def async_setup_entry(
+    hass: HomeAssistant,
+    config_entry: HabiticaConfigEntry,
+    async_add_entities: AddEntitiesCallback,
+) -> None:
+    """"""Set up the calendar platform.""""""
+    coordinator = config_entry.runtime_data
+
+    async_add_entities(
+        [
+            HabiticaTodosCalendarEntity(coordinator),
+            HabiticaDailiesCalendarEntity(coordinator),
+            HabiticaRemindersCalendarEntity(coordinator),
+        ]
+    )
+
+
+class HabiticaCalendarEntity(HabiticaBase, CalendarEntity):
+    """"""Base Habitica calendar entity.""""""
+
+    def __init__(
+        self,
+        coordinator: HabiticaDataUpdateCoordinator,
+    ) -> None:
+        """"""Initialize calendar entity.""""""
+        super().__init__(coordinator, self.entity_description)
+
+
+class HabiticaTodosCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica todos calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.TODOS,
+        translation_key=HabiticaCalendar.TODOS,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+
+        events = [
+            CalendarEvent(
+                start=start,
+                end=start,

(from reviewer) [2024-10-13T05:35:29Z] The end date should be exclusive (https://developers.home-assistant.io/docs/core/entity/calendar/#calendarevent) and must be after start, so +1 day here, and below too.
(from author) [2024-10-13T11:32:28Z] CalendarEvent already handles this and adds 1 day so i thought it might be unnecessary
(from reviewer) [2024-10-13T14:34:06Z] It's there just to fix input bugs, and is shared with the input handling code for creating events from the service. 
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,261 @@
+""""""Calendar platform for Habitica integration.""""""
+
+from __future__ import annotations
+
+from datetime import datetime, time, timedelta
+from enum import StrEnum
+
+from homeassistant.components.calendar import (
+    CalendarEntity,
+    CalendarEntityDescription,
+    CalendarEvent,
+)
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.util import dt as dt_util
+
+from . import HabiticaConfigEntry
+from .coordinator import HabiticaDataUpdateCoordinator
+from .entity import HabiticaBase
+from .types import HabiticaTaskType
+from .util import build_rrule, to_date
+
+
+class HabiticaCalendar(StrEnum):
+    """"""Habitica calendars.""""""
+
+    DAILIES = ""dailys""
+    TODOS = ""todos""
+    REMINDERS = ""reminders""
+
+
+async def async_setup_entry(
+    hass: HomeAssistant,
+    config_entry: HabiticaConfigEntry,
+    async_add_entities: AddEntitiesCallback,
+) -> None:
+    """"""Set up the calendar platform.""""""
+    coordinator = config_entry.runtime_data
+
+    async_add_entities(
+        [
+            HabiticaTodosCalendarEntity(coordinator),
+            HabiticaDailiesCalendarEntity(coordinator),
+            HabiticaRemindersCalendarEntity(coordinator),
+        ]
+    )
+
+
+class HabiticaCalendarEntity(HabiticaBase, CalendarEntity):
+    """"""Base Habitica calendar entity.""""""
+
+    def __init__(
+        self,
+        coordinator: HabiticaDataUpdateCoordinator,
+    ) -> None:
+        """"""Initialize calendar entity.""""""
+        super().__init__(coordinator, self.entity_description)
+
+
+class HabiticaTodosCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica todos calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.TODOS,
+        translation_key=HabiticaCalendar.TODOS,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+
+        events = [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.TODO
+            and not task[""completed""]
+            and task.get(""date"")
+            and (start := to_date(task[""date""]))
+            and start >= dt_util.now().date()
+        ]
+        events_sorted = sorted(
+            events,
+            key=lambda event: (
+                event.start,
+                self.coordinator.data.user[""tasksOrder""][""todos""].index(event.uid),
+            ),
+        )
+
+        return events_sorted[0] if events_sorted else None
+
+    async def async_get_events(
+        self, hass: HomeAssistant, start_date: datetime, end_date: datetime
+    ) -> list[CalendarEvent]:
+        """"""Return calendar events within a datetime range.""""""
+
+        return [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.TODO
+            and not task[""completed""]
+            and task.get(""date"")
+            and (start := to_date(task[""date""]))
+            and (start_date.date() <= start <= end_date.date())
+        ]
+
+
+class HabiticaDailiesCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica dailies calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.DAILIES,
+        translation_key=HabiticaCalendar.DAILIES,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+
+        today = datetime.combine(
+            dt_util.now().date(), time(), dt_util.DEFAULT_TIME_ZONE

(from reviewer) [2024-10-13T05:38:48Z] You can just use `dt_util.now()` here and it will give you a local datetime in the current timezone as described here https://developers.home-assistant.io/docs/core/entity/calendar/#get-events 
(from author) [2024-10-13T12:09:08Z] But that's exactly what i need, a tz-aware datetime representation of today (starttime 0:00) for rrule to return also events for today.
(from reviewer) [2024-10-13T14:40:06Z] Is that `dt_util.start_of_local_day()`?
(from author) [2024-10-13T15:05:58Z] lol, that method does the exact same thing 😂
(now that I know this exists, I'd preferably use that instead)
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,261 @@
+""""""Calendar platform for Habitica integration.""""""
+
+from __future__ import annotations
+
+from datetime import datetime, time, timedelta
+from enum import StrEnum
+
+from homeassistant.components.calendar import (
+    CalendarEntity,
+    CalendarEntityDescription,
+    CalendarEvent,
+)
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.util import dt as dt_util
+
+from . import HabiticaConfigEntry
+from .coordinator import HabiticaDataUpdateCoordinator
+from .entity import HabiticaBase
+from .types import HabiticaTaskType
+from .util import build_rrule, to_date
+
+
+class HabiticaCalendar(StrEnum):
+    """"""Habitica calendars.""""""
+
+    DAILIES = ""dailys""
+    TODOS = ""todos""
+    REMINDERS = ""reminders""
+
+
+async def async_setup_entry(
+    hass: HomeAssistant,
+    config_entry: HabiticaConfigEntry,
+    async_add_entities: AddEntitiesCallback,
+) -> None:
+    """"""Set up the calendar platform.""""""
+    coordinator = config_entry.runtime_data
+
+    async_add_entities(
+        [
+            HabiticaTodosCalendarEntity(coordinator),
+            HabiticaDailiesCalendarEntity(coordinator),
+            HabiticaRemindersCalendarEntity(coordinator),
+        ]
+    )
+
+
+class HabiticaCalendarEntity(HabiticaBase, CalendarEntity):
+    """"""Base Habitica calendar entity.""""""
+
+    def __init__(
+        self,
+        coordinator: HabiticaDataUpdateCoordinator,
+    ) -> None:
+        """"""Initialize calendar entity.""""""
+        super().__init__(coordinator, self.entity_description)
+
+
+class HabiticaTodosCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica todos calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.TODOS,
+        translation_key=HabiticaCalendar.TODOS,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+
+        events = [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.TODO
+            and not task[""completed""]
+            and task.get(""date"")
+            and (start := to_date(task[""date""]))
+            and start >= dt_util.now().date()
+        ]
+        events_sorted = sorted(
+            events,
+            key=lambda event: (
+                event.start,
+                self.coordinator.data.user[""tasksOrder""][""todos""].index(event.uid),
+            ),
+        )
+
+        return events_sorted[0] if events_sorted else None
+
+    async def async_get_events(
+        self, hass: HomeAssistant, start_date: datetime, end_date: datetime
+    ) -> list[CalendarEvent]:
+        """"""Return calendar events within a datetime range.""""""
+
+        return [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.TODO
+            and not task[""completed""]
+            and task.get(""date"")
+            and (start := to_date(task[""date""]))
+            and (start_date.date() <= start <= end_date.date())
+        ]
+
+
+class HabiticaDailiesCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica dailies calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.DAILIES,
+        translation_key=HabiticaCalendar.DAILIES,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+
+        today = datetime.combine(
+            dt_util.now().date(), time(), dt_util.DEFAULT_TIME_ZONE
+        )
+        events = [
+            CalendarEvent(
+                start=(start := next_recurrence.date()),
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.DAILY
+            and not task[""completed""]
+            and task[""everyX""]
+            if (next_recurrence := build_rrule(task).after(today, inc=True))
+        ]
+        events_sorted = sorted(
+            events,
+            key=lambda event: (
+                event.start,
+                self.coordinator.data.user[""tasksOrder""][""dailys""].index(event.uid),
+            ),
+        )
+
+        return events_sorted[0] if events_sorted else None
+
+    async def async_get_events(
+        self, hass: HomeAssistant, start_date: datetime, end_date: datetime
+    ) -> list[CalendarEvent]:
+        """"""Return calendar events within a datetime range.""""""
+
+        today = to_date(self.coordinator.data.user[""lastCron""])
+        # returns only todays and future dailies.
+        # If a daily is completed it will not be shown for today but still future recurrences
+        # If the cron hasn't run, not completed dailies are yesterdailies and displayed yesterday
+        return [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+                rrule=str(build_rrule(task))[30:],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.DAILY and task[""everyX""]
+            for recurrence in build_rrule(task).between(start_date, end_date, inc=True)
+            if (start := recurrence.date()) > today
+            or (start == today and not task[""completed""])
+        ]
+
+
+class HabiticaRemindersCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica reminders calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.REMINDERS,
+        translation_key=HabiticaCalendar.REMINDERS,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+        events_sorted = None

(from reviewer) [2024-10-13T05:40:09Z] ```suggestion
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,261 @@
+""""""Calendar platform for Habitica integration.""""""
+
+from __future__ import annotations
+
+from datetime import datetime, time, timedelta
+from enum import StrEnum
+
+from homeassistant.components.calendar import (
+    CalendarEntity,
+    CalendarEntityDescription,
+    CalendarEvent,
+)
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.util import dt as dt_util
+
+from . import HabiticaConfigEntry
+from .coordinator import HabiticaDataUpdateCoordinator
+from .entity import HabiticaBase
+from .types import HabiticaTaskType
+from .util import build_rrule, to_date
+
+
+class HabiticaCalendar(StrEnum):
+    """"""Habitica calendars.""""""
+
+    DAILIES = ""dailys""
+    TODOS = ""todos""
+    REMINDERS = ""reminders""
+
+
+async def async_setup_entry(
+    hass: HomeAssistant,
+    config_entry: HabiticaConfigEntry,
+    async_add_entities: AddEntitiesCallback,
+) -> None:
+    """"""Set up the calendar platform.""""""
+    coordinator = config_entry.runtime_data
+
+    async_add_entities(
+        [
+            HabiticaTodosCalendarEntity(coordinator),
+            HabiticaDailiesCalendarEntity(coordinator),
+            HabiticaRemindersCalendarEntity(coordinator),
+        ]
+    )
+
+
+class HabiticaCalendarEntity(HabiticaBase, CalendarEntity):
+    """"""Base Habitica calendar entity.""""""
+
+    def __init__(
+        self,
+        coordinator: HabiticaDataUpdateCoordinator,
+    ) -> None:
+        """"""Initialize calendar entity.""""""
+        super().__init__(coordinator, self.entity_description)
+
+
+class HabiticaTodosCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica todos calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.TODOS,
+        translation_key=HabiticaCalendar.TODOS,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+
+        events = [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.TODO
+            and not task[""completed""]
+            and task.get(""date"")
+            and (start := to_date(task[""date""]))
+            and start >= dt_util.now().date()
+        ]
+        events_sorted = sorted(
+            events,
+            key=lambda event: (
+                event.start,
+                self.coordinator.data.user[""tasksOrder""][""todos""].index(event.uid),
+            ),
+        )
+
+        return events_sorted[0] if events_sorted else None
+
+    async def async_get_events(
+        self, hass: HomeAssistant, start_date: datetime, end_date: datetime
+    ) -> list[CalendarEvent]:
+        """"""Return calendar events within a datetime range.""""""
+
+        return [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.TODO
+            and not task[""completed""]
+            and task.get(""date"")
+            and (start := to_date(task[""date""]))
+            and (start_date.date() <= start <= end_date.date())
+        ]
+
+
+class HabiticaDailiesCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica dailies calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.DAILIES,
+        translation_key=HabiticaCalendar.DAILIES,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+
+        today = datetime.combine(
+            dt_util.now().date(), time(), dt_util.DEFAULT_TIME_ZONE
+        )
+        events = [
+            CalendarEvent(
+                start=(start := next_recurrence.date()),
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.DAILY
+            and not task[""completed""]
+            and task[""everyX""]
+            if (next_recurrence := build_rrule(task).after(today, inc=True))
+        ]
+        events_sorted = sorted(
+            events,
+            key=lambda event: (
+                event.start,
+                self.coordinator.data.user[""tasksOrder""][""dailys""].index(event.uid),
+            ),
+        )
+
+        return events_sorted[0] if events_sorted else None
+
+    async def async_get_events(
+        self, hass: HomeAssistant, start_date: datetime, end_date: datetime
+    ) -> list[CalendarEvent]:
+        """"""Return calendar events within a datetime range.""""""
+
+        today = to_date(self.coordinator.data.user[""lastCron""])
+        # returns only todays and future dailies.
+        # If a daily is completed it will not be shown for today but still future recurrences
+        # If the cron hasn't run, not completed dailies are yesterdailies and displayed yesterday
+        return [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+                rrule=str(build_rrule(task))[30:],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.DAILY and task[""everyX""]
+            for recurrence in build_rrule(task).between(start_date, end_date, inc=True)
+            if (start := recurrence.date()) > today
+            or (start == today and not task[""completed""])
+        ]
+
+
+class HabiticaRemindersCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica reminders calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.REMINDERS,
+        translation_key=HabiticaCalendar.REMINDERS,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+        events_sorted = None
+        now = dt_util.now()
+        events = [
+            CalendarEvent(
+                start=start,
+                end=start + timedelta(hours=1),
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=f""{task[""id""]}_{reminder[""id""]}"",
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] in (HabiticaTaskType.DAILY, HabiticaTaskType.TODO)
+            and not task[""completed""]
+            for reminder in task.get(""reminders"", [])
+            if (
+                start := datetime.fromisoformat(reminder[""time""]).replace(
+                    tzinfo=dt_util.DEFAULT_TIME_ZONE
+                )
+            )
+            >= (now - timedelta(hours=1))
+        ]
+
+        events_sorted = sorted(
+            events,
+            key=lambda event: event.start,
+        )
+
+        # return the last reminder that went off in the last hour

(from reviewer) [2024-10-13T05:41:42Z] This doesn't seem quite right to me since it is potentially hiding additional upcoming events? Current the rules are this returns either the current or next upcoming CalendarEvent.

I believe a simple way to implement ""active after"" is to iterate over the sorted event list and find the first event where the start time or end time are greater than the ""now"" time like here https://github.com/allenporter/ical/blob/d34a26a0af5bdd2a56c6601e7c35c6c012c9f0d8/ical/iter.py#L371 (used by local_calendar)
(from reviewer) [2024-10-13T05:59:23Z] I would recommend implementing this logic for the upcoming event and the event date range search once, and just make each type of event supply a sorted list of `CalendarEvent` and hand the rest with shared code.  Having the variance between them may introduce some bugs if we don't find all the subtle differences here so its easier to just get them right once and do them the same way.  (The logic can be the same whether or not its an all day event just by converting the dates to a timezone aware date when doing the range comparison)
(from author) [2024-10-13T12:57:01Z] I think i still need some tweeking for the reminders calendar, I'm considering adding them in a follow-up PR
(from reviewer) [2024-10-13T14:34:45Z] It's not implementing the spec correctly.
(from reviewer) [2024-10-13T14:38:29Z] I see, you removed from the pr.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,261 @@
+""""""Calendar platform for Habitica integration.""""""
+
+from __future__ import annotations
+
+from datetime import datetime, time, timedelta
+from enum import StrEnum
+
+from homeassistant.components.calendar import (
+    CalendarEntity,
+    CalendarEntityDescription,
+    CalendarEvent,
+)
+from homeassistant.core import HomeAssistant
+from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.util import dt as dt_util
+
+from . import HabiticaConfigEntry
+from .coordinator import HabiticaDataUpdateCoordinator
+from .entity import HabiticaBase
+from .types import HabiticaTaskType
+from .util import build_rrule, to_date
+
+
+class HabiticaCalendar(StrEnum):
+    """"""Habitica calendars.""""""
+
+    DAILIES = ""dailys""
+    TODOS = ""todos""
+    REMINDERS = ""reminders""
+
+
+async def async_setup_entry(
+    hass: HomeAssistant,
+    config_entry: HabiticaConfigEntry,
+    async_add_entities: AddEntitiesCallback,
+) -> None:
+    """"""Set up the calendar platform.""""""
+    coordinator = config_entry.runtime_data
+
+    async_add_entities(
+        [
+            HabiticaTodosCalendarEntity(coordinator),
+            HabiticaDailiesCalendarEntity(coordinator),
+            HabiticaRemindersCalendarEntity(coordinator),
+        ]
+    )
+
+
+class HabiticaCalendarEntity(HabiticaBase, CalendarEntity):
+    """"""Base Habitica calendar entity.""""""
+
+    def __init__(
+        self,
+        coordinator: HabiticaDataUpdateCoordinator,
+    ) -> None:
+        """"""Initialize calendar entity.""""""
+        super().__init__(coordinator, self.entity_description)
+
+
+class HabiticaTodosCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica todos calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.TODOS,
+        translation_key=HabiticaCalendar.TODOS,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+
+        events = [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.TODO
+            and not task[""completed""]
+            and task.get(""date"")
+            and (start := to_date(task[""date""]))
+            and start >= dt_util.now().date()
+        ]
+        events_sorted = sorted(
+            events,
+            key=lambda event: (
+                event.start,
+                self.coordinator.data.user[""tasksOrder""][""todos""].index(event.uid),
+            ),
+        )
+
+        return events_sorted[0] if events_sorted else None
+
+    async def async_get_events(
+        self, hass: HomeAssistant, start_date: datetime, end_date: datetime
+    ) -> list[CalendarEvent]:
+        """"""Return calendar events within a datetime range.""""""
+
+        return [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.TODO
+            and not task[""completed""]
+            and task.get(""date"")
+            and (start := to_date(task[""date""]))
+            and (start_date.date() <= start <= end_date.date())
+        ]
+
+
+class HabiticaDailiesCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica dailies calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.DAILIES,
+        translation_key=HabiticaCalendar.DAILIES,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+
+        today = datetime.combine(
+            dt_util.now().date(), time(), dt_util.DEFAULT_TIME_ZONE
+        )
+        events = [
+            CalendarEvent(
+                start=(start := next_recurrence.date()),
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.DAILY
+            and not task[""completed""]
+            and task[""everyX""]
+            if (next_recurrence := build_rrule(task).after(today, inc=True))
+        ]
+        events_sorted = sorted(
+            events,
+            key=lambda event: (
+                event.start,
+                self.coordinator.data.user[""tasksOrder""][""dailys""].index(event.uid),
+            ),
+        )
+
+        return events_sorted[0] if events_sorted else None
+
+    async def async_get_events(
+        self, hass: HomeAssistant, start_date: datetime, end_date: datetime
+    ) -> list[CalendarEvent]:
+        """"""Return calendar events within a datetime range.""""""
+
+        today = to_date(self.coordinator.data.user[""lastCron""])
+        # returns only todays and future dailies.
+        # If a daily is completed it will not be shown for today but still future recurrences
+        # If the cron hasn't run, not completed dailies are yesterdailies and displayed yesterday
+        return [
+            CalendarEvent(
+                start=start,
+                end=start,
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=task[""id""],
+                rrule=str(build_rrule(task))[30:],
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] == HabiticaTaskType.DAILY and task[""everyX""]
+            for recurrence in build_rrule(task).between(start_date, end_date, inc=True)
+            if (start := recurrence.date()) > today
+            or (start == today and not task[""completed""])
+        ]
+
+
+class HabiticaRemindersCalendarEntity(HabiticaCalendarEntity):
+    """"""Habitica reminders calendar entity.""""""
+
+    entity_description = CalendarEntityDescription(
+        key=HabiticaCalendar.REMINDERS,
+        translation_key=HabiticaCalendar.REMINDERS,
+    )
+
+    @property
+    def event(self) -> CalendarEvent | None:
+        """"""Return the next upcoming event.""""""
+        events_sorted = None
+        now = dt_util.now()
+        events = [
+            CalendarEvent(
+                start=start,
+                end=start + timedelta(hours=1),
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=f""{task[""id""]}_{reminder[""id""]}"",
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] in (HabiticaTaskType.DAILY, HabiticaTaskType.TODO)
+            and not task[""completed""]
+            for reminder in task.get(""reminders"", [])
+            if (
+                start := datetime.fromisoformat(reminder[""time""]).replace(
+                    tzinfo=dt_util.DEFAULT_TIME_ZONE
+                )
+            )
+            >= (now - timedelta(hours=1))
+        ]
+
+        events_sorted = sorted(
+            events,
+            key=lambda event: event.start,
+        )
+
+        # return the last reminder that went off in the last hour
+        if past_events := [
+            event
+            for event in events_sorted
+            if now >= event.start >= (now - timedelta(hours=1))
+        ]:
+            return past_events[-1]
+
+        # if there is no active reminder, move on to the next upcoming event
+        if upcoming_events := [event for event in events_sorted if event.start > now]:
+            return upcoming_events[0]
+        return None
+
+    async def async_get_events(
+        self, hass: HomeAssistant, start_date: datetime, end_date: datetime
+    ) -> list[CalendarEvent]:
+        """"""Return calendar events within a datetime range.""""""
+
+        return [
+            CalendarEvent(
+                start=start,
+                end=start + timedelta(hours=1),
+                summary=task[""text""],
+                description=task[""notes""],
+                uid=f""{task[""id""]}_{reminder[""id""]}"",
+            )
+            for task in self.coordinator.data.tasks
+            if task[""type""] in (HabiticaTaskType.DAILY, HabiticaTaskType.TODO)
+            and not task[""completed""]
+            for reminder in task.get(""reminders"", [])
+            if (
+                start_date

(from reviewer) [2024-10-13T05:56:45Z] There are two changes needed here i think to meet the spec described here  https://developers.home-assistant.io/docs/core/entity/calendar/#get-events

(1) the end date is exclusive.
(2) This need to check if the event end date is between requested start and end dates.

(from author) [2024-10-13T12:55:04Z] The events don't have enddates, so it is not necessary to check if the enddate is in between. 
(from reviewer) [2024-10-13T14:37:21Z] All calendar events have an end date. I understand the habitica tasks/events don't, but i'm talking about how its represented as a home assistant event.  They set an end date  (""start + timedelta(hours=1)"".) This is not implementing the get events spec correctly ""The start_date is the lower bound and applied to the event's end (exclusive).""
(from author) [2024-10-13T14:53:27Z] I removed the reminders for now as there are still some other things i have to figure out about how they work in Habitica, the to-dos and dailies are all-day events so i think this doesn't apply to them. 
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -0,0 +1,179 @@
+""""""Calendar platform for Habitica integration.""""""
+
+from __future__ import annotations
+
+from datetime import datetime, time, timedelta
+from enum import StrEnum
+
+from homeassistant.components.calendar import (
+    CalendarEntity,
+    CalendarEntityDescription,
+    CalendarEvent,
+)
+from homeassistant.core import HomeAssistant
+from homeassistant.he",
pers.entity_platform import AddEntitiesCallback,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from . import HabiticaConfigEntry,,,,,,,,,,,,,,,
+from .coordinator import HabiticaDataUpdateCoordinator,,,,,,,,,,,,,,,
+from .entity import HabiticaBase,,,,,,,,,,,,,,,
+from .types import HabiticaTaskType,,,,,,,,,,,,,,,
+from .util import build_rrule, to_date,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaCalendar(StrEnum):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica calendars.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+    DAILIES = """"dailys""""",,,,,,,,,,,,,,,
"+    TODOS = """"todos""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+async def async_setup_entry(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+) -> None:,,,,,,,,,,,,,,,
"+    """"""""""""Set up the calendar platform.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async_add_entities(,,,,,,,,,,,,,,,
+        [,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaCalendarEntity(HabiticaBase, CalendarEntity):,,,,,,,,,,,,,,
"+    """"""""""""Base Habitica calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Initialize calendar entity.""""""""""""",,,,,,,,,,,,,,,
+        super().__init__(coordinator, self.entity_description),,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaTodosCalendarEntity(HabiticaCalendarEntity):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica todos calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    entity_description = CalendarEntityDescription(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def event(self) -> CalendarEvent | None:,,,,,,,,,,,,,,,
"+        """"""""""""Return the next upcoming event.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        events = [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.TODO",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task.get(""""date"""")",,,,,,,,,,,,,,,
"+            and (start := to_date(task[""""date""""]))",,,,,,,,,,,,,,,
+            and start >= dt_util.now().date(),,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+        events_sorted = sorted(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            key=lambda event: (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                self.coordinator.data.user[""""tasksOrder""""][""""todos""""].index(event.uid)",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return events_sorted[0] if events_sorted else None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_get_events(,,,,,,,,,,,,,,,
#NAME?, hass: HomeAssistant, start_date: datetime, end_date: datetime,,,,,,,,,,,,
+    ) -> list[CalendarEvent]:,,,,,,,,,,,,,,,
"+        """"""""""""Return calendar events within a datetime range.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.TODO",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task.get(""""date"""")",,,,,,,,,,,,,,,
"+            and (start := to_date(task[""""date""""]))",,,,,,,,,,,,,,,
+            and (start_date.date() <= start <= end_date.date()),,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaDailiesCalendarEntity(HabiticaCalendarEntity):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica dailies calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    entity_description = CalendarEntityDescription(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def event(self) -> CalendarEvent | None:,,,,,,,,,,,,,,,
"+        """"""""""""Return the next upcoming event.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        today = datetime.combine(,,,,,,,,,,,,,,,
+            dt_util.now().date(), time(), dt_util.DEFAULT_TIME_ZONE,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+        events = [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
+                start=(start := next_recurrence.date()),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.DAILY",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-13T14:54:05Z] Will this prevent future occurrences from showing up here? As I was saying before for the other event type, a single  timeline view will ensure we don't have inconsistent behavior.,,,,,,,,,,,,,,
(from author) [2024-10-13T15:51:19Z] the future occurrences should still show up, just for the current day they should not show up after beeing completed,,,,,,,,,,,,,,
(from author) [2024-10-13T22:22:59Z] I must admit, that was a very good catch. Now it does what it is expected to do 😁,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
I think i can't use a single timeline as you suggest, the future recurrences are generated events. In `async_get_events` i can use end_date to limit how many recurrence events are generated, but in the `events` property I only ask `rrule` for the next recurrence of each task. I would have to provide an arbitrary date in the future. How far into the future would i have to go if want to get sure to get the next recurrence of a task? If it is too close in the future i could miss recurrences. If it is too far in the future i would get a very long list of events for daily recurring tasks.,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,179 @@,,,,,,,,,,,,,
"+""""""""""""Calendar platform for Habitica integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?, time, timedelta,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from homeassistant.components.calendar import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from . import HabiticaConfigEntry,,,,,,,,,,,,,,,
+from .coordinator import HabiticaDataUpdateCoordinator,,,,,,,,,,,,,,,
+from .entity import HabiticaBase,,,,,,,,,,,,,,,
+from .types import HabiticaTaskType,,,,,,,,,,,,,,,
+from .util import build_rrule, to_date,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaCalendar(StrEnum):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica calendars.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+    DAILIES = """"dailys""""",,,,,,,,,,,,,,,
"+    TODOS = """"todos""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+async def async_setup_entry(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+) -> None:,,,,,,,,,,,,,,,
"+    """"""""""""Set up the calendar platform.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async_add_entities(,,,,,,,,,,,,,,,
+        [,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaCalendarEntity(HabiticaBase, CalendarEntity):,,,,,,,,,,,,,,
"+    """"""""""""Base Habitica calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Initialize calendar entity.""""""""""""",,,,,,,,,,,,,,,
+        super().__init__(coordinator, self.entity_description),,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaTodosCalendarEntity(HabiticaCalendarEntity):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica todos calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    entity_description = CalendarEntityDescription(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def event(self) -> CalendarEvent | None:,,,,,,,,,,,,,,,
"+        """"""""""""Return the next upcoming event.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        events = [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.TODO",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task.get(""""date"""")",,,,,,,,,,,,,,,
"+            and (start := to_date(task[""""date""""]))",,,,,,,,,,,,,,,
+            and start >= dt_util.now().date(),,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+        events_sorted = sorted(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            key=lambda event: (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                self.coordinator.data.user[""""tasksOrder""""][""""todos""""].index(event.uid)",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return events_sorted[0] if events_sorted else None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_get_events(,,,,,,,,,,,,,,,
#NAME?, hass: HomeAssistant, start_date: datetime, end_date: datetime,,,,,,,,,,,,
+    ) -> list[CalendarEvent]:,,,,,,,,,,,,,,,
"+        """"""""""""Return calendar events within a datetime range.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.TODO",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task.get(""""date"""")",,,,,,,,,,,,,,,
"+            and (start := to_date(task[""""date""""]))",,,,,,,,,,,,,,,
+            and (start_date.date() <= start <= end_date.date()),,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaDailiesCalendarEntity(HabiticaCalendarEntity):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica dailies calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    entity_description = CalendarEntityDescription(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def event(self) -> CalendarEvent | None:,,,,,,,,,,,,,,,
"+        """"""""""""Return the next upcoming event.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        today = datetime.combine(,,,,,,,,,,,,,,,
+            dt_util.now().date(), time(), dt_util.DEFAULT_TIME_ZONE,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+        events = [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
+                start=(start := next_recurrence.date()),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.DAILY",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task[""""everyX""""]",,,,,,,,,,,,,,,
+            if (next_recurrence := build_rrule(task).after(today, inc=True)),,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+        events_sorted = sorted(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            key=lambda event: (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                self.coordinator.data.user[""""tasksOrder""""][""""dailys""""].index(event.uid)",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return events_sorted[0] if events_sorted else None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_get_events(,,,,,,,,,,,,,,,
#NAME?, hass: HomeAssistant, start_date: datetime, end_date: datetime,,,,,,,,,,,,
+    ) -> list[CalendarEvent]:,,,,,,,,,,,,,,,
"+        """"""""""""Return calendar events within a datetime range.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+        today = to_date(self.coordinator.data.user[""""lastCron""""])",,,,,,,,,,,,,,,
+        # returns only todays and future dailies.,,,,,,,,,,,,,,,
+        # If a daily is completed it will not be shown for today but still future recurrences,,,,,,,,,,,,,,,
+        # If the cron hasn't run, not completed dailies are yesterdailies and displayed yesterday,,,,,,,,,,,,,,
+        return [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+                rrule=str(build_rrule(task))[30:],,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-13T14:55:43Z] What's the intent behind `[30:]`? Skipping the first line of a multi-line rrule or something? This is pretty subtle, can this be done another way (or omitted)?,,,,,,,,,,,,,,
(from author) [2024-10-13T15:48:05Z] This is stripping  the dtstart part of the rrule. Otherwise the calendar is unable to parse the rule. I was looking for a method to get a rule from rrule without the dtstart part but couldn't find one ,,,,,,,,,,,,,,,
(from reviewer) [2024-10-13T15:54:10Z] Two suggestions:,,,,,,,,,,,,,,,
- I would suggest extracting a descriptive function name that describes what this is doing. (I happy to know the format this library produces includes dtstart because i've read that library code before, but not sure that is obvious to other readers),,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,179 @@,,,,,,,,,,,,,
"+""""""""""""Calendar platform for Habitica integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?, time, timedelta,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from homeassistant.components.calendar import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from . import HabiticaConfigEntry,,,,,,,,,,,,,,,
+from .coordinator import HabiticaDataUpdateCoordinator,,,,,,,,,,,,,,,
+from .entity import HabiticaBase,,,,,,,,,,,,,,,
+from .types import HabiticaTaskType,,,,,,,,,,,,,,,
+from .util import build_rrule, to_date,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaCalendar(StrEnum):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica calendars.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+    DAILIES = """"dailys""""",,,,,,,,,,,,,,,
"+    TODOS = """"todos""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+async def async_setup_entry(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+) -> None:,,,,,,,,,,,,,,,
"+    """"""""""""Set up the calendar platform.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async_add_entities(,,,,,,,,,,,,,,,
+        [,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaCalendarEntity(HabiticaBase, CalendarEntity):,,,,,,,,,,,,,,
"+    """"""""""""Base Habitica calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Initialize calendar entity.""""""""""""",,,,,,,,,,,,,,,
+        super().__init__(coordinator, self.entity_description),,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaTodosCalendarEntity(HabiticaCalendarEntity):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica todos calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    entity_description = CalendarEntityDescription(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def event(self) -> CalendarEvent | None:,,,,,,,,,,,,,,,
"+        """"""""""""Return the next upcoming event.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        events = [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.TODO",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task.get(""""date"""")",,,,,,,,,,,,,,,
"+            and (start := to_date(task[""""date""""]))",,,,,,,,,,,,,,,
+            and start >= dt_util.now().date(),,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+        events_sorted = sorted(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            key=lambda event: (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                self.coordinator.data.user[""""tasksOrder""""][""""todos""""].index(event.uid)",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return events_sorted[0] if events_sorted else None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_get_events(,,,,,,,,,,,,,,,
#NAME?, hass: HomeAssistant, start_date: datetime, end_date: datetime,,,,,,,,,,,,
+    ) -> list[CalendarEvent]:,,,,,,,,,,,,,,,
"+        """"""""""""Return calendar events within a datetime range.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.TODO",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task.get(""""date"""")",,,,,,,,,,,,,,,
"+            and (start := to_date(task[""""date""""]))",,,,,,,,,,,,,,,
+            and (start_date.date() <= start <= end_date.date()),,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaDailiesCalendarEntity(HabiticaCalendarEntity):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica dailies calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    entity_description = CalendarEntityDescription(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def event(self) -> CalendarEvent | None:,,,,,,,,,,,,,,,
"+        """"""""""""Return the next upcoming event.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        today = datetime.combine(,,,,,,,,,,,,,,,
+            dt_util.now().date(), time(), dt_util.DEFAULT_TIME_ZONE,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+        events = [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
+                start=(start := next_recurrence.date()),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.DAILY",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task[""""everyX""""]",,,,,,,,,,,,,,,
+            if (next_recurrence := build_rrule(task).after(today, inc=True)),,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+        events_sorted = sorted(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            key=lambda event: (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                self.coordinator.data.user[""""tasksOrder""""][""""dailys""""].index(event.uid)",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return events_sorted[0] if events_sorted else None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_get_events(,,,,,,,,,,,,,,,
#NAME?, hass: HomeAssistant, start_date: datetime, end_date: datetime,,,,,,,,,,,,
+    ) -> list[CalendarEvent]:,,,,,,,,,,,,,,,
"+        """"""""""""Return calendar events within a datetime range.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+        today = to_date(self.coordinator.data.user[""""lastCron""""])",,,,,,,,,,,,,,,
+        # returns only todays and future dailies.,,,,,,,,,,,,,,,
+        # If a daily is completed it will not be shown for today but still future recurrences,,,,,,,,,,,,,,,
+        # If the cron hasn't run, not completed dailies are yesterdailies and displayed yesterday,,,,,,,,,,,,,,
+        return [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+                rrule=str(build_rrule(task))[30:],,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.DAILY and task[""""everyX""""]",,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-13T14:58:35Z] Can you help me understand what the intent is here behind this check? Is `everyX` sometimes `0`? (Seems like the rrule would want to handle this, so not sure i follow this),,,,,,,,,,,,,,
(from author) [2024-10-13T15:40:14Z] yes, there are dailies without a recurrence, they are called grey dailies and they can be completed whenever but become never due.,,,,,,,,,,,,,
rrule seems to not be able to parse that.,,,,,,,,,,,,,,,
(from reviewer) [2024-10-13T15:54:57Z] Does that mean they show up every day? or more? If so then maybe that can be set in the rrule,,,,,,,,,,,,,,,
(from author) [2024-10-13T16:20:44Z] on the dailies list in habitica all tasks show up, by default, although one can filter for dailies that are due or grey(completed or not due today). It is still possible to complete dailies that are not due to get the reward but they won't cause damage if they are not completed, so technically grey tasks are optional. An task without a recurrence is always optional, so I think they shouldn't show up in the calendar at all.,,,,,,,,,,,
(from author) [2024-10-13T23:52:56Z] I must correct myself, `rrule` is not to blame, it can parse a 0 interval correctly, it's Home Assistant that freaks out, i think it's getting into an infinite loop somewhere,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
---BEGIN THREAD---,,,,,,,,,,,,,,,
Diff Hunk:,,,,,,,,,,,,,,,
@@ -0,0 +1,179 @@,,,,,,,,,,,,,
"+""""""""""""Calendar platform for Habitica integration.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?, time, timedelta,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from homeassistant.components.calendar import (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+from . import HabiticaConfigEntry,,,,,,,,,,,,,,,
+from .coordinator import HabiticaDataUpdateCoordinator,,,,,,,,,,,,,,,
+from .entity import HabiticaBase,,,,,,,,,,,,,,,
+from .types import HabiticaTaskType,,,,,,,,,,,,,,,
+from .util import build_rrule, to_date,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaCalendar(StrEnum):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica calendars.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+    DAILIES = """"dailys""""",,,,,,,,,,,,,,,
"+    TODOS = """"todos""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+async def async_setup_entry(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+) -> None:,,,,,,,,,,,,,,,
"+    """"""""""""Set up the calendar platform.""""""""""""",,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async_add_entities(,,,,,,,,,,,,,,,
+        [,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaCalendarEntity(HabiticaBase, CalendarEntity):,,,,,,,,,,,,,,
"+    """"""""""""Base Habitica calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    def __init__(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ) -> None:,,,,,,,,,,,,,,,
"+        """"""""""""Initialize calendar entity.""""""""""""",,,,,,,,,,,,,,,
+        super().__init__(coordinator, self.entity_description),,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaTodosCalendarEntity(HabiticaCalendarEntity):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica todos calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    entity_description = CalendarEntityDescription(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def event(self) -> CalendarEvent | None:,,,,,,,,,,,,,,,
"+        """"""""""""Return the next upcoming event.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        events = [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.TODO",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task.get(""""date"""")",,,,,,,,,,,,,,,
"+            and (start := to_date(task[""""date""""]))",,,,,,,,,,,,,,,
+            and start >= dt_util.now().date(),,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+        events_sorted = sorted(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            key=lambda event: (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                self.coordinator.data.user[""""tasksOrder""""][""""todos""""].index(event.uid)",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return events_sorted[0] if events_sorted else None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_get_events(,,,,,,,,,,,,,,,
#NAME?, hass: HomeAssistant, start_date: datetime, end_date: datetime,,,,,,,,,,,,
+    ) -> list[CalendarEvent]:,,,,,,,,,,,,,,,
"+        """"""""""""Return calendar events within a datetime range.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.TODO",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task.get(""""date"""")",,,,,,,,,,,,,,,
"+            and (start := to_date(task[""""date""""]))",,,,,,,,,,,,,,,
+            and (start_date.date() <= start <= end_date.date()),,,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+class HabiticaDailiesCalendarEntity(HabiticaCalendarEntity):,,,,,,,,,,,,,,,
"+    """"""""""""Habitica dailies calendar entity.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    entity_description = CalendarEntityDescription(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+    def event(self) -> CalendarEvent | None:,,,,,,,,,,,,,,,
"+        """"""""""""Return the next upcoming event.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        today = datetime.combine(,,,,,,,,,,,,,,,
+            dt_util.now().date(), time(), dt_util.DEFAULT_TIME_ZONE,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+        events = [,,,,,,,,,,,,,,,
+            CalendarEvent(,,,,,,,,,,,,,,,
+                start=(start := next_recurrence.date()),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                summary=task[""""text""""]",,,,,,,,,,,,,,,
"+                description=task[""""notes""""]",,,,,,,,,,,,,,,
"+                uid=task[""""id""""]",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+            if task[""""type""""] == HabiticaTaskType.DAILY",,,,,,,,,,,,,,,
"+            and not task[""""completed""""]",,,,,,,,,,,,,,,
"+            and task[""""everyX""""]",,,,,,,,,,,,,,,
+            if (next_recurrence := build_rrule(task).after(today, inc=True)),,,,,,,,,,,,,,
+        ],,,,,,,,,,,,,,,
+        events_sorted = sorted(,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
+            key=lambda event: (,,,,,,,,,,,,,,,
#NAME?,,,,,,,,,,,,,,,
"+                self.coordinator.data.user[""""tasksOrder""""][""""dailys""""].index(event.uid)",,,,,,,,,,,,,,,
+            ),,,,,,,,,,,,,,,
+        ),,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+        return events_sorted[0] if events_sorted else None,,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
+    async def async_get_events(,,,,,,,,,,,,,,,
#NAME?, hass: HomeAssistant, start_date: datetime, end_date: datetime,,,,,,,,,,,,
+    ) -> list[CalendarEvent]:,,,,,,,,,,,,,,,
"+        """"""""""""Return calendar events within a datetime range.""""""""""""",,,,,,,,,,,,,,,
+,,,,,,,,,,,,,,,
"+        today = to_date(self.coordinator.data.user[""""lastCron""""])",,,,,,,,,,,,,,,
+        # returns only todays and future dailies.,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-13T15:02:33Z] This also is not meeting the get_event spec. get_events should work for any  start/end date range. A calendar can render events from the past as well, and triggers work based on past events.,,,,,,,,,,,,,,
(from author) [2024-10-13T16:38:04Z] In Habitica the start of the day can be set to a different time (in my account it is 4:00 am for example. If at that time all dailies that were due have been completed the cron runs at 4 and resets all dailies, marking the start of the day. If there are incompleted dailies from the past day (called yesterdailies), the user gets a last chance to mark tasks as completed (in case the task was done but forgotten to mark as completed) and then the user presses the button 'start my day', which then marks the start of the day. That's what I want to reflect here. ,,,,,,,,,,,,
That's also why it doesn't make sense to render events from the past, dailies are reset every day. ,,,,,,,,,,,,,,
---END THREAD---,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from reviewer) [2024-10-13T15:09:55Z] I realize what you're effectively wanting here is a different behavior from calendar events, given these are todos. This hasn't really been agreed upon, so i'm reviewing this in the currently defined calendar event spec.  There is a proposed recurring [todo spec here]( https://docs.google.com/document/d/1MNe6AYevNrd4aFPryBXf_zAG1d30OpwEPv_1hn_ufbo/edit?tab=t.0#heading=h.kfndxule2rks) but it hasn't really been decided upon yet.,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from author) [2024-10-13T15:53:20Z] > I realize what you're effectively wanting here is a different behavior from calendar events, given these are todos. This hasn't really been agreed upon, so i'm reviewing this in the currently defined calendar event spec. There is a proposed recurring [todo spec here](https://docs.google.com/document/d/1MNe6AYevNrd4aFPryBXf_zAG1d30OpwEPv_1hn_ufbo/edit?tab=t.0#heading=h.kfndxule2rks) but it hasn't really been decided upon yet.,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Had a quick look and I think that sounds promising. If it gets approved I'm eager to implement it for Habitica 😁,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from author) [2024-10-28T12:12:28Z] > Thanks, getting close on my end i think, appreciate you making all these large changes.,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
And I really appreciate your help in improving this PR and the patience with me🤗,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
(from author) [2024-10-29T18:53:36Z] @allenporter ,,,,,,,,,,,,,,,
Yay, we're done  ^^ ,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,
Thanks Allen," that was a great learning experience. I hope I wasn't too annoying for you (considering I just startet learning Python at the beginning of the year) 😬""",,,,,,,,,,,,,,
128247,Palazzetti CBox,2024-10-12 16:12:27+00:00,2024-10-13 19:01:48+00:00,closed,16,0,0,https://github.com/home-assistant/core/pull/128247,New integration (thank you!),604,2024-10-12T18:57:23Z,palazzetti,dotvav,,
128170,Add repeat media controls to Bang & Olufsen,2024-10-11 15:00:53+00:00,2024-10-26 19:02:01+00:00,merged,4,5,14,https://github.com/home-assistant/core/pull/128170,New feature (which adds functionality to an existing integration),109,2024-10-25T18:10:09Z,bang_olufsen,mj23000,"---BEGIN THREAD---
Diff Hunk:
@@ -36,6 +40,19 @@ class BangOlufsenSource:
     ""unknown"": MediaPlayerState.IDLE,
 }
 
+# Dict used for translating Home Assistant settings to device repeat settings.
+BANG_OLUFSEN_REPEAT_FROM_HA: dict[RepeatMode, str] = {
+    RepeatMode.ALL: ""all"",
+    RepeatMode.ONE: ""track"",
+    RepeatMode.OFF: ""none"",
+}
+# Dict used for translating device repeat settings to Home Assistant settings.
+BANG_OLUFSEN_REPEAT_TO_HA: dict[str, RepeatMode] = {
+    ""all"": RepeatMode.ALL,
+    ""track"": RepeatMode.ONE,
+    ""none"": RepeatMode.OFF,
+}

(from reviewer) [2024-10-11T17:38:01Z] ```suggestion
BANG_OLUFSEN_REPEAT_TO_HA: dict[str, RepeatMode] = {
    value: key for key, value in BANG_OLUFSEN_REPEAT_FROM_HA.items()
}
```
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -129,6 +139,7 @@ def __init__(self, entry: ConfigEntry, client: MozartClient) -> None:
             serial_number=self._unique_id,
         )
         self._attr_unique_id = self._unique_id
+        self._attr_should_poll = True

(from reviewer) [2024-10-11T17:39:48Z] Why do we first set it to false, to only now set it to true?
(from author) [2024-10-11T21:28:41Z] Yeah that makes no sense at this point. All other entities in the [HACS](https://github.com/bang-olufsen/bang_olufsen-hacs) version of the integration and the Event entities in https://github.com/home-assistant/core/pull/127550 are not polling, so I would say setting it to False makes sense by default as this is the only contradiction.
---END THREAD---

---BEGIN THREAD---
Diff Hunk:
@@ -218,6 +229,16 @@ async def _initialize(self) -> None:
 
         await self._async_update_sound_modes()
 
+    async def async_update(self) -> None:
+        """"""Update queue settings.""""""
+        # The WebSocket event listener is the main handler for connection state.
+        # The polling updates do therefore not set the device as available or unavailable
+        with contextlib.suppress(ApiException, ClientConnectorError, TimeoutError):

(from reviewer) [2024-10-11T17:40:04Z] Should we rather catch them and log something?
(from author) [2024-10-11T21:28:56Z] The WebSocket listener already logs when connection is lost, so if this also logs there would be two log messages informing the user of pretty much the same thing.
---END THREAD---",